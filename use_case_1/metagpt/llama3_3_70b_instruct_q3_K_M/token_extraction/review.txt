
# System
Role: You are a professional software engineer, and your main task is to review and revise the code. You need to ensure that the code conforms to the google-style standards, is elegantly designed and modularized, easy to read and maintain.
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## System Design
{"Implementation approach":"We will utilize the Pygame library to create a snake game in Python. The game will feature a grid-based board with clear boundaries, smooth snake movement, and collision detection. We will implement a scoring system that increases when the snake eats food and a restart feature when the snake collides with the boundary or itself.","File list":["main.py","game.py","snake.py","food.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -board: Board\n        -snake: Snake\n        -food: Food\n        +__init__()\n        +run()\n        +handle_events()\n        +update_game_state()\n        +draw_game_elements()\n    }\n    class Board {\n        -width: int\n        -height: int\n        -grid_size: int\n        +__init__(width: int, height: int, grid_size: int)\n        +draw_grid()\n    }\n    class Snake {\n        -body: list\n        -direction: str\n        +__init__()\n        +move()\n        +grow()\n        +check_collision()\n    }\n    class Food {\n        -x: int\n        -y: int\n        +__init__(x: int, y: int)\n        +generate_new_food()\n    }\n    Game --> Board\n    Game --> Snake\n    Game --> Food\n","Program call flow":"\nsequenceDiagram\n    participant G as Game\n    participant B as Board\n    participant S as Snake\n    participant F as Food\n    G->>B: initialize_board(width, height, grid_size)\n    B-->>G: return board\n    G->>S: initialize_snake()\n    S-->>G: return snake\n    G->>F: generate_food()\n    F-->>G: return food\n    G->>G: run_game_loop()\n    G->>G: handle_events()\n    G->>S: update_snake_position()\n    S-->>G: return new_snake_position\n    G->>F: check_for_food_collision()\n    F-->>G: return food_collision_result\n    G->>G: update_game_state()\n    G->>B: draw_board()\n    B-->>G: return drawn_board\n    G->>S: draw_snake()\n    S-->>G: return drawn_snake\n    G->>F: draw_food()\n    F-->>G: return drawn_food\n","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Task
{"Required Python packages":["pygame"],"Required Other language third-party packages":["No third-party dependencies required"],"Logic Analysis":[["game.py","Contains Game class and run, handle_events, update_game_state, draw_game_elements functions"],["snake.py","Contains Snake class and move, grow, check_collision functions"],["food.py","Contains Food class and generate_new_food function"],["main.py","Contains main function, from game import Game"]],"Task list":["game.py","snake.py","food.py","main.py"],"Full API spec":"","Shared Knowledge":"`game.py` contains functions shared across the project. The grid size and snake movement speed need to be clarified.","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Code Files



## Code to be Reviewed: game.py
```Code
import pygame
import sys

class Board:
    def __init__(self, width: int = 800, height: int = 600, grid_size: int = 20):
        """
        Initialize the game board with a given width, height, and grid size.

        Args:
            width (int): The width of the board. Defaults to 800.
            height (int): The height of the board. Defaults to 600.
            grid_size (int): The size of each grid cell. Defaults to 20.
        """
        self.width = width
        self.height = height
        self.grid_size = grid_size

    def draw_grid(self, screen):
        """
        Draw the grid on the given screen.

        Args:
            screen: The Pygame screen to draw on.
        """
        for x in range(0, self.width, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (x, 0), (x, self.height))
        for y in range(0, self.height, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (0, y), (self.width, y))


class Snake:
    def __init__(self):
        """
        Initialize the snake with a default body and direction.
        """
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        """
        Move the snake in its current direction.
        """
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        """
        Grow the snake by adding a new segment to its body.
        """
        self.body.insert(0, self.body[0])

    def check_collision(self, board):
        """
        Check if the snake has collided with the board or itself.

        Args:
            board (Board): The game board.

        Returns:
            bool: True if a collision is detected, False otherwise.
        """
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False


class Food:
    def __init__(self, x: int = 400, y: int = 300):
        """
        Initialize the food at a given position.

        Args:
            x (int): The x-coordinate of the food. Defaults to 400.
            y (int): The y-coordinate of the food. Defaults to 300.
        """
        self.x = x
        self.y = y

    def generate_new_food(self, board):
        """
        Generate new food at a random position on the board.

        Args:
            board (Board): The game board.
        """
        import random
        self.x = random.randint(0, board.width - 20) // 20 * 20
        self.y = random.randint(0, board.height - 20) // 20 * 20


class Game:
    def __init__(self):
        """
        Initialize the game with a default board, snake, and food.
        """
        self.board = Board()
        self.snake = Snake()
        self.food = Food()

    def run(self):
        """
        Run the game loop.
        """
        pygame.init()
        screen = pygame.display.set_mode((self.board.width, self.board.height))
        clock = pygame.time.Clock()
        while True:
            self.handle_events()
            self.update_game_state()
            self.draw_game_elements(screen)
            pygame.display.flip()
            clock.tick(10)

    def handle_events(self):
        """
        Handle any events such as key presses or quit events.
        """
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_UP and self.snake.direction != 'DOWN':
                    self.snake.direction = 'UP'
                elif event.key == pygame.K_DOWN and self.snake.direction != 'UP':
                    self.snake.direction = 'DOWN'
                elif event.key == pygame.K_LEFT and self.snake.direction != 'RIGHT':
                    self.snake.direction = 'LEFT'
                elif event.key == pygame.K_RIGHT and self.snake.direction != 'LEFT':
                    self.snake.direction = 'RIGHT'

    def update_game_state(self):
        """
        Update the game state by moving the snake, checking for collisions, and updating the food.
        """
        self.snake.move()
        if self.snake.check_collision(self.board):
            pygame.quit()
            sys.exit()
        if (self.snake.body[-1][0] == self.food.x and
                self.snake.body[-1][1] == self.food.y):
            self.snake.grow()
            self.food.generate_new_food(self.board)

    def draw_game_elements(self, screen):
        """
        Draw the game elements such as the board, snake, and food.

        Args:
            screen: The Pygame screen to draw on.
        """
        screen.fill((0, 0, 0))
        self.board.draw_grid(screen)
        for segment in self.snake.body:
            pygame.draw.rect(screen, (0, 255, 0), (segment[0], segment[1], 20, 20))
        pygame.draw.rect(screen, (255, 0, 0), (self.food.x, self.food.y, 20, 20))


def main():
    game = Game()
    game.run()


if __name__ == '__main__':
    main()


```



# Format example 1
## Code Review: game.py
1. No, we should fix the logic of class A due to ...
2. ...
3. ...
4. No, function B is not implemented, ...
5. ...
6. ...

## Actions
1. Fix the `handle_events` method to update the game state only if a move is successful.
   ```python
   def handle_events(self):
       for event in pygame.event.get():
           if event.type == pygame.QUIT:
               return False
           if event.type == pygame.KEYDOWN:
               moved = False
               if event.key == pygame.K_UP:
                   moved = self.game.move('UP')
               elif event.key == pygame.K_DOWN:
                   moved = self.game.move('DOWN')
               elif event.key == pygame.K_LEFT:
                   moved = self.game.move('LEFT')
               elif event.key == pygame.K_RIGHT:
                   moved = self.game.move('RIGHT')
               if moved:
                   # Update the game state only if a move was successful
                   self.render()
       return True
   ```
2. Implement function B

## Code Review Result
LBTM

# Format example 2
## Code Review: game.py
1. Yes.
2. Yes.
3. Yes.
4. Yes.
5. Yes.
6. Yes.

## Actions
pass

## Code Review Result
LGTM



# Instruction: Based on the actual code situation, follow one of the "Format example". Return only 1 file under review.

## Code Review: Ordered List. Based on the "Code to be Reviewed", provide key, clear, concise, and specific answer. If any answer is no, explain how to fix it step by step.
1. Is the code implemented as per the requirements? If not, how to achieve it? Analyse it step by step.
2. Is the code logic completely correct? If there are errors, please indicate how to correct them.
3. Does the existing code follow the "Data structures and interfaces"?
4. Are all functions implemented? If there is no implementation, please indicate how to achieve it step by step.
5. Have all necessary pre-dependencies been imported? If not, indicate which ones need to be imported
6. Are methods from other files being reused correctly?

## Actions: Ordered List. Things that should be done after CR, such as implementing class A and function B

## Code Review Result: str. If the code doesn't have bugs, we don't need to rewrite it, so answer LGTM and stop. ONLY ANSWER LGTM/LBTM.
LGTM/LBTM






# System
Role: You are a professional software engineer, and your main task is to review and revise the code. You need to ensure that the code conforms to the google-style standards, is elegantly designed and modularized, easy to read and maintain.
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## System Design
{"Implementation approach":"We will utilize the Pygame library to create a snake game in Python. The game will feature a grid-based board with clear boundaries, smooth snake movement, and collision detection. We will implement a scoring system that increases when the snake eats food and a restart feature when the snake collides with the boundary or itself.","File list":["main.py","game.py","snake.py","food.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -board: Board\n        -snake: Snake\n        -food: Food\n        +__init__()\n        +run()\n        +handle_events()\n        +update_game_state()\n        +draw_game_elements()\n    }\n    class Board {\n        -width: int\n        -height: int\n        -grid_size: int\n        +__init__(width: int, height: int, grid_size: int)\n        +draw_grid()\n    }\n    class Snake {\n        -body: list\n        -direction: str\n        +__init__()\n        +move()\n        +grow()\n        +check_collision()\n    }\n    class Food {\n        -x: int\n        -y: int\n        +__init__(x: int, y: int)\n        +generate_new_food()\n    }\n    Game --> Board\n    Game --> Snake\n    Game --> Food\n","Program call flow":"\nsequenceDiagram\n    participant G as Game\n    participant B as Board\n    participant S as Snake\n    participant F as Food\n    G->>B: initialize_board(width, height, grid_size)\n    B-->>G: return board\n    G->>S: initialize_snake()\n    S-->>G: return snake\n    G->>F: generate_food()\n    F-->>G: return food\n    G->>G: run_game_loop()\n    G->>G: handle_events()\n    G->>S: update_snake_position()\n    S-->>G: return new_snake_position\n    G->>F: check_for_food_collision()\n    F-->>G: return food_collision_result\n    G->>G: update_game_state()\n    G->>B: draw_board()\n    B-->>G: return drawn_board\n    G->>S: draw_snake()\n    S-->>G: return drawn_snake\n    G->>F: draw_food()\n    F-->>G: return drawn_food\n","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Task
{"Required Python packages":["pygame"],"Required Other language third-party packages":["No third-party dependencies required"],"Logic Analysis":[["game.py","Contains Game class and run, handle_events, update_game_state, draw_game_elements functions"],["snake.py","Contains Snake class and move, grow, check_collision functions"],["food.py","Contains Food class and generate_new_food function"],["main.py","Contains main function, from game import Game"]],"Task list":["game.py","snake.py","food.py","main.py"],"Full API spec":"","Shared Knowledge":"`game.py` contains functions shared across the project. The grid size and snake movement speed need to be clarified.","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Code Files



## Code to be Reviewed: game.py
```Code
import pygame
import sys

class Board:
    def __init__(self, width: int = 800, height: int = 600, grid_size: int = 20):
        """
        Initialize the game board with a given width, height, and grid size.

        Args:
            width (int): The width of the board. Defaults to 800.
            height (int): The height of the board. Defaults to 600.
            grid_size (int): The size of each grid cell. Defaults to 20.
        """
        self.width = width
        self.height = height
        self.grid_size = grid_size

    def draw_grid(self, screen):
        """
        Draw the grid on the given screen.

        Args:
            screen: The Pygame screen to draw on.
        """
        for x in range(0, self.width, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (x, 0), (x, self.height))
        for y in range(0, self.height, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (0, y), (self.width, y))


class Snake:
    def __init__(self):
        """
        Initialize the snake with a default body and direction.
        """
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        """
        Move the snake in its current direction.
        """
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        """
        Grow the snake by adding a new segment to its body.
        """
        self.body.insert(0, self.body[0])

    def check_collision(self, board):
        """
        Check if the snake has collided with the board or itself.

        Args:
            board (Board): The game board.

        Returns:
            bool: True if a collision is detected, False otherwise.
        """
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False


class Food:
    def __init__(self, x: int = 400, y: int = 300):
        """
        Initialize the food at a given position.

        Args:
            x (int): The x-coordinate of the food. Defaults to 400.
            y (int): The y-coordinate of the food. Defaults to 300.
        """
        self.x = x
        self.y = y

    def generate_new_food(self, board):
        """
        Generate new food at a random position on the board.

        Args:
            board (Board): The game board.
        """
        import random
        self.x = random.randint(0, board.width - 20) // 20 * 20
        self.y = random.randint(0, board.height - 20) // 20 * 20


class Game:
    def __init__(self):
        """
        Initialize the game with a default board, snake, and food.
        """
        self.board = Board()
        self.snake = Snake()
        self.food = Food()

    def run(self):
        """
        Run the game loop.
        """
        pygame.init()
        screen = pygame.display.set_mode((self.board.width, self.board.height))
        clock = pygame.time.Clock()
        while True:
            self.handle_events()
            self.update_game_state()
            self.draw_game_elements(screen)
            pygame.display.flip()
            clock.tick(10)

    def handle_events(self):
        """
        Handle any events such as key presses or quit events.
        """
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_UP and self.snake.direction != 'DOWN':
                    self.snake.direction = 'UP'
                elif event.key == pygame.K_DOWN and self.snake.direction != 'UP':
                    self.snake.direction = 'DOWN'
                elif event.key == pygame.K_LEFT and self.snake.direction != 'RIGHT':
                    self.snake.direction = 'LEFT'
                elif event.key == pygame.K_RIGHT and self.snake.direction != 'LEFT':
                    self.snake.direction = 'RIGHT'

    def update_game_state(self):
        """
        Update the game state by moving the snake, checking for collisions, and updating the food.
        """
        self.snake.move()
        if self.snake.check_collision(self.board):
            pygame.quit()
            sys.exit()
        if (self.snake.body[-1][0] == self.food.x and
                self.snake.body[-1][1] == self.food.y):
            self.snake.grow()
            self.food.generate_new_food(self.board)

    def draw_game_elements(self, screen):
        """
        Draw the game elements such as the board, snake, and food.

        Args:
            screen: The Pygame screen to draw on.
        """
        screen.fill((0, 0, 0))
        self.board.draw_grid(screen)
        for segment in self.snake.body:
            pygame.draw.rect(screen, (0, 255, 0), (segment[0], segment[1], 20, 20))
        pygame.draw.rect(screen, (255, 0, 0), (self.food.x, self.food.y, 20, 20))


def main():
    game = Game()
    game.run()


if __name__ == '__main__':
    main()


```

## Code Review: game.py
1. Yes, the code is implemented as per the requirements. It includes all necessary classes such as `Board`, `Snake`, `Food`, and `Game`. Each class has its respective methods to handle different aspects of the game.
2. The code logic seems mostly correct but there are a few potential issues:
   - In the `Snake` class, the `grow` method inserts a new segment at the beginning of the body list. However, this might not be the intended behavior because it doesn't actually grow the snake in the direction it's moving. Instead, it should add a new segment to the end of the body when the snake eats food.
   - The collision detection in the `Snake` class checks if the head of the snake is outside the board or if it collides with any other part of its body. However, this check might not be sufficient because it doesn't account for cases where the snake's head might overlap with its own body due to the grid-based movement.
   - The `Food` class generates new food at a random position on the board. However, there's no guarantee that this new food won't spawn inside the snake's body, which could lead to instant collision and game over.
3. Yes, the existing code follows the "Data structures and interfaces" provided in the problem description. It includes classes for `Game`, `Board`, `Snake`, and `Food` with their respective methods as specified.
4. Yes, all functions are implemented. The code includes implementations for initializing the game board, moving the snake, checking collisions, generating new food, handling events, updating the game state, and drawing game elements.
5. Yes, all necessary pre-dependencies have been imported. The code uses `pygame` for creating the game window, handling events, and drawing graphics. It also imports `sys` for exiting the game when the user closes the window.
6. No methods from other files are being reused in this code snippet because it's a self-contained implementation of the snake game.

## Actions
1. Modify the `Snake` class's `grow` method to correctly add new segments to the end of the body when the snake eats food.
2. Enhance the collision detection logic in the `Snake` class to account for potential overlaps between the snake's head and its own body.
3. Update the `Food` class to ensure that new food doesn't spawn inside the snake's body.

## Code Review Result
LBTM

# Instruction: rewrite code based on the Code Review and Actions
## Rewrite Code: CodeBlock. If it still has some bugs, rewrite game.py with triple quotes. Do your utmost to optimize THIS SINGLE FILE. Return all completed codes and prohibit the return of unfinished codes.
```Code
## game.py
...
```





# System
Role: You are a professional software engineer, and your main task is to review and revise the code. You need to ensure that the code conforms to the google-style standards, is elegantly designed and modularized, easy to read and maintain.
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## System Design
{"Implementation approach":"We will utilize the Pygame library to create a snake game in Python. The game will feature a grid-based board with clear boundaries, smooth snake movement, and collision detection. We will implement a scoring system that increases when the snake eats food and a restart feature when the snake collides with the boundary or itself.","File list":["main.py","game.py","snake.py","food.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -board: Board\n        -snake: Snake\n        -food: Food\n        +__init__()\n        +run()\n        +handle_events()\n        +update_game_state()\n        +draw_game_elements()\n    }\n    class Board {\n        -width: int\n        -height: int\n        -grid_size: int\n        +__init__(width: int, height: int, grid_size: int)\n        +draw_grid()\n    }\n    class Snake {\n        -body: list\n        -direction: str\n        +__init__()\n        +move()\n        +grow()\n        +check_collision()\n    }\n    class Food {\n        -x: int\n        -y: int\n        +__init__(x: int, y: int)\n        +generate_new_food()\n    }\n    Game --> Board\n    Game --> Snake\n    Game --> Food\n","Program call flow":"\nsequenceDiagram\n    participant G as Game\n    participant B as Board\n    participant S as Snake\n    participant F as Food\n    G->>B: initialize_board(width, height, grid_size)\n    B-->>G: return board\n    G->>S: initialize_snake()\n    S-->>G: return snake\n    G->>F: generate_food()\n    F-->>G: return food\n    G->>G: run_game_loop()\n    G->>G: handle_events()\n    G->>S: update_snake_position()\n    S-->>G: return new_snake_position\n    G->>F: check_for_food_collision()\n    F-->>G: return food_collision_result\n    G->>G: update_game_state()\n    G->>B: draw_board()\n    B-->>G: return drawn_board\n    G->>S: draw_snake()\n    S-->>G: return drawn_snake\n    G->>F: draw_food()\n    F-->>G: return drawn_food\n","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Task
{"Required Python packages":["pygame"],"Required Other language third-party packages":["No third-party dependencies required"],"Logic Analysis":[["game.py","Contains Game class and run, handle_events, update_game_state, draw_game_elements functions"],["snake.py","Contains Snake class and move, grow, check_collision functions"],["food.py","Contains Food class and generate_new_food function"],["main.py","Contains main function, from game import Game"]],"Task list":["game.py","snake.py","food.py","main.py"],"Full API spec":"","Shared Knowledge":"`game.py` contains functions shared across the project. The grid size and snake movement speed need to be clarified.","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Code Files



## Code to be Reviewed: game.py
```Code
import pygame
import sys
import random

class Board:
    def __init__(self, width=800, height=600, grid_size=20):
        self.width = width
        self.height = height
        self.grid_size = grid_size

    def draw_grid(self, screen):
        for x in range(0, self.width, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (x, 0), (x, self.height))
        for y in range(0, self.height, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (0, y), (self.width, y))


class Snake:
    def __init__(self):
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        self.body.insert(0, self.body[0])

    def check_collision(self, board):
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False


class Food:
    def __init__(self, x=400, y=300):
        self.x = x
        self.y = y

    def generate_new_food(self, board, snake):
        while True:
            self.x = random.randint(0, board.width - 20) // 20 * 20
            self.y = random.randint(0, board.height - 20) // 20 * 20
            if (self.x, self.y) not in snake.body:
                break


class Game:
    def __init__(self):
        self.board = Board()
        self.snake = Snake()
        self.food = Food()

    def run(self):
        pygame.init()
        screen = pygame.display.set_mode((self.board.width, self.board.height))
        clock = pygame.time.Clock()
        while True:
            self.handle_events()
            self.update_game_state()
            self.draw_game_elements(screen)
            pygame.display.flip()
            clock.tick(10)

    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_UP and self.snake.direction != 'DOWN':
                    self.snake.direction = 'UP'
                elif event.key == pygame.K_DOWN and self.snake.direction != 'UP':
                    self.snake.direction = 'DOWN'
                elif event.key == pygame.K_LEFT and self.snake.direction != 'RIGHT':
                    self.snake.direction = 'LEFT'
                elif event.key == pygame.K_RIGHT and self.snake.direction != 'LEFT':
                    self.snake.direction = 'RIGHT'

    def update_game_state(self):
        self.snake.move()
        if self.snake.check_collision(self.board):
            pygame.quit()
            sys.exit()
        if (self.snake.body[-1][0] == self.food.x and
                self.snake.body[-1][1] == self.food.y):
            self.snake.grow()
            self.food.generate_new_food(self.board, self.snake)

    def draw_game_elements(self, screen):
        screen.fill((0, 0, 0))
        self.board.draw_grid(screen)
        for segment in self.snake.body:
            pygame.draw.rect(screen, (0, 255, 0), (segment[0], segment[1], 20, 20))
        pygame.draw.rect(screen, (255, 0, 0), (self.food.x, self.food.y, 20, 20))


def main():
    game = Game()
    game.run()


if __name__ == '__main__':
    main()


```



# Format example 1
## Code Review: game.py
1. No, we should fix the logic of class A due to ...
2. ...
3. ...
4. No, function B is not implemented, ...
5. ...
6. ...

## Actions
1. Fix the `handle_events` method to update the game state only if a move is successful.
   ```python
   def handle_events(self):
       for event in pygame.event.get():
           if event.type == pygame.QUIT:
               return False
           if event.type == pygame.KEYDOWN:
               moved = False
               if event.key == pygame.K_UP:
                   moved = self.game.move('UP')
               elif event.key == pygame.K_DOWN:
                   moved = self.game.move('DOWN')
               elif event.key == pygame.K_LEFT:
                   moved = self.game.move('LEFT')
               elif event.key == pygame.K_RIGHT:
                   moved = self.game.move('RIGHT')
               if moved:
                   # Update the game state only if a move was successful
                   self.render()
       return True
   ```
2. Implement function B

## Code Review Result
LBTM

# Format example 2
## Code Review: game.py
1. Yes.
2. Yes.
3. Yes.
4. Yes.
5. Yes.
6. Yes.

## Actions
pass

## Code Review Result
LGTM



# Instruction: Based on the actual code situation, follow one of the "Format example". Return only 1 file under review.

## Code Review: Ordered List. Based on the "Code to be Reviewed", provide key, clear, concise, and specific answer. If any answer is no, explain how to fix it step by step.
1. Is the code implemented as per the requirements? If not, how to achieve it? Analyse it step by step.
2. Is the code logic completely correct? If there are errors, please indicate how to correct them.
3. Does the existing code follow the "Data structures and interfaces"?
4. Are all functions implemented? If there is no implementation, please indicate how to achieve it step by step.
5. Have all necessary pre-dependencies been imported? If not, indicate which ones need to be imported
6. Are methods from other files being reused correctly?

## Actions: Ordered List. Things that should be done after CR, such as implementing class A and function B

## Code Review Result: str. If the code doesn't have bugs, we don't need to rewrite it, so answer LGTM and stop. ONLY ANSWER LGTM/LBTM.
LGTM/LBTM






# System
Role: You are a professional software engineer, and your main task is to review and revise the code. You need to ensure that the code conforms to the google-style standards, is elegantly designed and modularized, easy to read and maintain.
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## System Design
{"Implementation approach":"We will utilize the Pygame library to create a snake game in Python. The game will feature a grid-based board with clear boundaries, smooth snake movement, and collision detection. We will implement a scoring system that increases when the snake eats food and a restart feature when the snake collides with the boundary or itself.","File list":["main.py","game.py","snake.py","food.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -board: Board\n        -snake: Snake\n        -food: Food\n        +__init__()\n        +run()\n        +handle_events()\n        +update_game_state()\n        +draw_game_elements()\n    }\n    class Board {\n        -width: int\n        -height: int\n        -grid_size: int\n        +__init__(width: int, height: int, grid_size: int)\n        +draw_grid()\n    }\n    class Snake {\n        -body: list\n        -direction: str\n        +__init__()\n        +move()\n        +grow()\n        +check_collision()\n    }\n    class Food {\n        -x: int\n        -y: int\n        +__init__(x: int, y: int)\n        +generate_new_food()\n    }\n    Game --> Board\n    Game --> Snake\n    Game --> Food\n","Program call flow":"\nsequenceDiagram\n    participant G as Game\n    participant B as Board\n    participant S as Snake\n    participant F as Food\n    G->>B: initialize_board(width, height, grid_size)\n    B-->>G: return board\n    G->>S: initialize_snake()\n    S-->>G: return snake\n    G->>F: generate_food()\n    F-->>G: return food\n    G->>G: run_game_loop()\n    G->>G: handle_events()\n    G->>S: update_snake_position()\n    S-->>G: return new_snake_position\n    G->>F: check_for_food_collision()\n    F-->>G: return food_collision_result\n    G->>G: update_game_state()\n    G->>B: draw_board()\n    B-->>G: return drawn_board\n    G->>S: draw_snake()\n    S-->>G: return drawn_snake\n    G->>F: draw_food()\n    F-->>G: return drawn_food\n","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Task
{"Required Python packages":["pygame"],"Required Other language third-party packages":["No third-party dependencies required"],"Logic Analysis":[["game.py","Contains Game class and run, handle_events, update_game_state, draw_game_elements functions"],["snake.py","Contains Snake class and move, grow, check_collision functions"],["food.py","Contains Food class and generate_new_food function"],["main.py","Contains main function, from game import Game"]],"Task list":["game.py","snake.py","food.py","main.py"],"Full API spec":"","Shared Knowledge":"`game.py` contains functions shared across the project. The grid size and snake movement speed need to be clarified.","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Code Files



## Code to be Reviewed: game.py
```Code
import pygame
import sys
import random

class Board:
    def __init__(self, width=800, height=600, grid_size=20):
        self.width = width
        self.height = height
        self.grid_size = grid_size

    def draw_grid(self, screen):
        for x in range(0, self.width, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (x, 0), (x, self.height))
        for y in range(0, self.height, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (0, y), (self.width, y))


class Snake:
    def __init__(self):
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        self.body.insert(0, self.body[0])

    def check_collision(self, board):
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False


class Food:
    def __init__(self, x=400, y=300):
        self.x = x
        self.y = y

    def generate_new_food(self, board, snake):
        while True:
            self.x = random.randint(0, board.width - 20) // 20 * 20
            self.y = random.randint(0, board.height - 20) // 20 * 20
            if (self.x, self.y) not in snake.body:
                break


class Game:
    def __init__(self):
        self.board = Board()
        self.snake = Snake()
        self.food = Food()

    def run(self):
        pygame.init()
        screen = pygame.display.set_mode((self.board.width, self.board.height))
        clock = pygame.time.Clock()
        while True:
            self.handle_events()
            self.update_game_state()
            self.draw_game_elements(screen)
            pygame.display.flip()
            clock.tick(10)

    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_UP and self.snake.direction != 'DOWN':
                    self.snake.direction = 'UP'
                elif event.key == pygame.K_DOWN and self.snake.direction != 'UP':
                    self.snake.direction = 'DOWN'
                elif event.key == pygame.K_LEFT and self.snake.direction != 'RIGHT':
                    self.snake.direction = 'LEFT'
                elif event.key == pygame.K_RIGHT and self.snake.direction != 'LEFT':
                    self.snake.direction = 'RIGHT'

    def update_game_state(self):
        self.snake.move()
        if self.snake.check_collision(self.board):
            pygame.quit()
            sys.exit()
        if (self.snake.body[-1][0] == self.food.x and
                self.snake.body[-1][1] == self.food.y):
            self.snake.grow()
            self.food.generate_new_food(self.board, self.snake)

    def draw_game_elements(self, screen):
        screen.fill((0, 0, 0))
        self.board.draw_grid(screen)
        for segment in self.snake.body:
            pygame.draw.rect(screen, (0, 255, 0), (segment[0], segment[1], 20, 20))
        pygame.draw.rect(screen, (255, 0, 0), (self.food.x, self.food.y, 20, 20))


def main():
    game = Game()
    game.run()


if __name__ == '__main__':
    main()


```

## Code Review: game.py
1. Yes, the code is implemented as per the requirements. It meets all the necessary conditions for a snake game using Pygame, including a grid-based board, smooth snake movement, collision detection, scoring system, and restart feature.
2. The code logic is mostly correct. However, there are a few potential issues:
   - In the `Snake` class, the `grow` method inserts a new segment at the beginning of the body list, which might not be the intended behavior when the snake grows. Instead, it should add a new segment to the end of the body list.
   - The `Food` class generates new food positions randomly, but it does not guarantee that the new position will not overlap with the snake's body or the board boundaries. Although the current implementation checks for overlap with the snake's body, it does not account for boundary conditions explicitly.
   - In the `Game` class, the `update_game_state` method checks for collisions and updates the game state accordingly. However, when a collision occurs, the game quits immediately without providing any feedback or option to restart.
3. Yes, the existing code follows the "Data structures and interfaces" provided in the problem statement. It defines classes for `Game`, `Board`, `Snake`, and `Food` with their respective attributes and methods as specified.
4. Yes, all functions are implemented. The code includes implementations for initializing the game, handling events, updating the game state, drawing game elements, and moving the snake.
5. Yes, all necessary pre-dependencies have been imported. The code imports Pygame, sys, and random modules as required for the game implementation.
6. Yes, methods from other files are not being reused in this specific code snippet since it is a self-contained implementation of the snake game.

## Actions
1. Consider modifying the `Snake` class's `grow` method to append new segments to the end of the body list instead of inserting at the beginning.
2. Enhance the `Food` class's `generate_new_food` method to ensure that new food positions do not overlap with the snake's body or the board boundaries, providing a more robust collision detection.
3. Modify the `Game` class's `update_game_state` method to provide feedback or an option to restart when a collision occurs, improving the overall gaming experience.

## Code Review Result
LBTM

# Instruction: rewrite code based on the Code Review and Actions
## Rewrite Code: CodeBlock. If it still has some bugs, rewrite game.py with triple quotes. Do your utmost to optimize THIS SINGLE FILE. Return all completed codes and prohibit the return of unfinished codes.
```Code
## game.py
...
```





NOTICE
Role: You are a professional engineer; the main goal is to write google-style, elegant, modular, easy to read and maintain code
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## Design
{"Implementation approach":"We will utilize the Pygame library to create a snake game in Python. The game will feature a grid-based board with clear boundaries, smooth snake movement, and collision detection. We will implement a scoring system that increases when the snake eats food and a restart feature when the snake collides with the boundary or itself.","File list":["main.py","game.py","snake.py","food.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -board: Board\n        -snake: Snake\n        -food: Food\n        +__init__()\n        +run()\n        +handle_events()\n        +update_game_state()\n        +draw_game_elements()\n    }\n    class Board {\n        -width: int\n        -height: int\n        -grid_size: int\n        +__init__(width: int, height: int, grid_size: int)\n        +draw_grid()\n    }\n    class Snake {\n        -body: list\n        -direction: str\n        +__init__()\n        +move()\n        +grow()\n        +check_collision()\n    }\n    class Food {\n        -x: int\n        -y: int\n        +__init__(x: int, y: int)\n        +generate_new_food()\n    }\n    Game --> Board\n    Game --> Snake\n    Game --> Food\n","Program call flow":"\nsequenceDiagram\n    participant G as Game\n    participant B as Board\n    participant S as Snake\n    participant F as Food\n    G->>B: initialize_board(width, height, grid_size)\n    B-->>G: return board\n    G->>S: initialize_snake()\n    S-->>G: return snake\n    G->>F: generate_food()\n    F-->>G: return food\n    G->>G: run_game_loop()\n    G->>G: handle_events()\n    G->>S: update_snake_position()\n    S-->>G: return new_snake_position\n    G->>F: check_for_food_collision()\n    F-->>G: return food_collision_result\n    G->>G: update_game_state()\n    G->>B: draw_board()\n    B-->>G: return drawn_board\n    G->>S: draw_snake()\n    S-->>G: return drawn_snake\n    G->>F: draw_food()\n    F-->>G: return drawn_food\n","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Task
{"Required Python packages":["pygame"],"Required Other language third-party packages":["No third-party dependencies required"],"Logic Analysis":[["game.py","Contains Game class and run, handle_events, update_game_state, draw_game_elements functions"],["snake.py","Contains Snake class and move, grow, check_collision functions"],["food.py","Contains Food class and generate_new_food function"],["main.py","Contains main function, from game import Game"]],"Task list":["game.py","snake.py","food.py","main.py"],"Full API spec":"","Shared Knowledge":"`game.py` contains functions shared across the project. The grid size and snake movement speed need to be clarified.","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Legacy Code
```Code
----- game.py
```import pygame
import sys
import random

class Board:
    def __init__(self, width=800, height=600, grid_size=20):
        self.width = width
        self.height = height
        self.grid_size = grid_size

    def draw_grid(self, screen):
        for x in range(0, self.width, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (x, 0), (x, self.height))
        for y in range(0, self.height, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (0, y), (self.width, y))


class Snake:
    def __init__(self):
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        self.body.insert(0, self.body[0])

    def check_collision(self, board):
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False


class Food:
    def __init__(self, x=400, y=300):
        self.x = x
        self.y = y

    def generate_new_food(self, board, snake):
        while True:
            self.x = random.randint(0, board.width - 20) // 20 * 20
            self.y = random.randint(0, board.height - 20) // 20 * 20
            if (self.x, self.y) not in snake.body:
                break


class Game:
    def __init__(self):
        self.board = Board()
        self.snake = Snake()
        self.food = Food()

    def run(self):
        pygame.init()
        screen = pygame.display.set_mode((self.board.width, self.board.height))
        clock = pygame.time.Clock()
        while True:
            self.handle_events()
            self.update_game_state()
            self.draw_game_elements(screen)
            pygame.display.flip()
            clock.tick(10)

    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_UP and self.snake.direction != 'DOWN':
                    self.snake.direction = 'UP'
                elif event.key == pygame.K_DOWN and self.snake.direction != 'UP':
                    self.snake.direction = 'DOWN'
                elif event.key == pygame.K_LEFT and self.snake.direction != 'RIGHT':
                    self.snake.direction = 'LEFT'
                elif event.key == pygame.K_RIGHT and self.snake.direction != 'LEFT':
                    self.snake.direction = 'RIGHT'

    def update_game_state(self):
        self.snake.move()
        if self.snake.check_collision(self.board):
            print("Game Over! Final Score: ", len(self.snake.body))
            play_again = input("Play again? (yes/no): ")
            if play_again.lower() == "yes":
                self.__init__()
            else:
                pygame.quit()
                sys.exit()
        if (self.snake.body[-1][0] == self.food.x and
                self.snake.body[-1][1] == self.food.y):
            self.snake.grow()
            self.food.generate_new_food(self.board, self.snake)

    def draw_game_elements(self, screen):
        screen.fill((0, 0, 0))
        self.board.draw_grid(screen)
        for segment in self.snake.body:
            pygame.draw.rect(screen, (0, 255, 0), (segment[0], segment[1], 20, 20))
        pygame.draw.rect(screen, (255, 0, 0), (self.food.x, self.food.y, 20, 20))


def main():
    game = Game()
    game.run()


if __name__ == '__main__':
    main()

```
```

## Debug logs
```text



```

## Bug Feedback logs
```text

```

# Format example
## Code: snake.py
```python
## snake.py
...
```

# Instruction: Based on the context, follow "Format example", write code.

## Code: snake.py. Write code with triple quoto, based on the following attentions and context.
1. Only One file: do your best to implement THIS ONLY ONE FILE.
2. COMPLETE CODE: Your code will be part of the entire project, so please implement complete, reliable, reusable code snippets.
3. Set default value: If there is any setting, ALWAYS SET A DEFAULT VALUE, ALWAYS USE STRONG TYPE AND EXPLICIT VARIABLE. AVOID circular import.
4. Follow design: YOU MUST FOLLOW "Data structures and interfaces". DONT CHANGE ANY DESIGN. Do not use public member functions that do not exist in your design.
5. CAREFULLY CHECK THAT YOU DONT MISS ANY NECESSARY CLASS/FUNCTION IN THIS FILE.
6. Before using a external variable/module, make sure you import it first.
7. Write out EVERY CODE DETAIL, DON'T LEAVE TODO.






# System
Role: You are a professional software engineer, and your main task is to review and revise the code. You need to ensure that the code conforms to the google-style standards, is elegantly designed and modularized, easy to read and maintain.
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## System Design
{"Implementation approach":"We will utilize the Pygame library to create a snake game in Python. The game will feature a grid-based board with clear boundaries, smooth snake movement, and collision detection. We will implement a scoring system that increases when the snake eats food and a restart feature when the snake collides with the boundary or itself.","File list":["main.py","game.py","snake.py","food.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -board: Board\n        -snake: Snake\n        -food: Food\n        +__init__()\n        +run()\n        +handle_events()\n        +update_game_state()\n        +draw_game_elements()\n    }\n    class Board {\n        -width: int\n        -height: int\n        -grid_size: int\n        +__init__(width: int, height: int, grid_size: int)\n        +draw_grid()\n    }\n    class Snake {\n        -body: list\n        -direction: str\n        +__init__()\n        +move()\n        +grow()\n        +check_collision()\n    }\n    class Food {\n        -x: int\n        -y: int\n        +__init__(x: int, y: int)\n        +generate_new_food()\n    }\n    Game --> Board\n    Game --> Snake\n    Game --> Food\n","Program call flow":"\nsequenceDiagram\n    participant G as Game\n    participant B as Board\n    participant S as Snake\n    participant F as Food\n    G->>B: initialize_board(width, height, grid_size)\n    B-->>G: return board\n    G->>S: initialize_snake()\n    S-->>G: return snake\n    G->>F: generate_food()\n    F-->>G: return food\n    G->>G: run_game_loop()\n    G->>G: handle_events()\n    G->>S: update_snake_position()\n    S-->>G: return new_snake_position\n    G->>F: check_for_food_collision()\n    F-->>G: return food_collision_result\n    G->>G: update_game_state()\n    G->>B: draw_board()\n    B-->>G: return drawn_board\n    G->>S: draw_snake()\n    S-->>G: return drawn_snake\n    G->>F: draw_food()\n    F-->>G: return drawn_food\n","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Task
{"Required Python packages":["pygame"],"Required Other language third-party packages":["No third-party dependencies required"],"Logic Analysis":[["game.py","Contains Game class and run, handle_events, update_game_state, draw_game_elements functions"],["snake.py","Contains Snake class and move, grow, check_collision functions"],["food.py","Contains Food class and generate_new_food function"],["main.py","Contains main function, from game import Game"]],"Task list":["game.py","snake.py","food.py","main.py"],"Full API spec":"","Shared Knowledge":"`game.py` contains functions shared across the project. The grid size and snake movement speed need to be clarified.","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Code Files
----- game.py
```import pygame
import sys
import random

class Board:
    def __init__(self, width=800, height=600, grid_size=20):
        self.width = width
        self.height = height
        self.grid_size = grid_size

    def draw_grid(self, screen):
        for x in range(0, self.width, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (x, 0), (x, self.height))
        for y in range(0, self.height, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (0, y), (self.width, y))


class Snake:
    def __init__(self):
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        self.body.insert(0, self.body[0])

    def check_collision(self, board):
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False


class Food:
    def __init__(self, x=400, y=300):
        self.x = x
        self.y = y

    def generate_new_food(self, board, snake):
        while True:
            self.x = random.randint(0, board.width - 20) // 20 * 20
            self.y = random.randint(0, board.height - 20) // 20 * 20
            if (self.x, self.y) not in snake.body:
                break


class Game:
    def __init__(self):
        self.board = Board()
        self.snake = Snake()
        self.food = Food()

    def run(self):
        pygame.init()
        screen = pygame.display.set_mode((self.board.width, self.board.height))
        clock = pygame.time.Clock()
        while True:
            self.handle_events()
            self.update_game_state()
            self.draw_game_elements(screen)
            pygame.display.flip()
            clock.tick(10)

    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_UP and self.snake.direction != 'DOWN':
                    self.snake.direction = 'UP'
                elif event.key == pygame.K_DOWN and self.snake.direction != 'UP':
                    self.snake.direction = 'DOWN'
                elif event.key == pygame.K_LEFT and self.snake.direction != 'RIGHT':
                    self.snake.direction = 'LEFT'
                elif event.key == pygame.K_RIGHT and self.snake.direction != 'LEFT':
                    self.snake.direction = 'RIGHT'

    def update_game_state(self):
        self.snake.move()
        if self.snake.check_collision(self.board):
            print("Game Over! Final Score: ", len(self.snake.body))
            play_again = input("Play again? (yes/no): ")
            if play_again.lower() == "yes":
                self.__init__()
            else:
                pygame.quit()
                sys.exit()
        if (self.snake.body[-1][0] == self.food.x and
                self.snake.body[-1][1] == self.food.y):
            self.snake.grow()
            self.food.generate_new_food(self.board, self.snake)

    def draw_game_elements(self, screen):
        screen.fill((0, 0, 0))
        self.board.draw_grid(screen)
        for segment in self.snake.body:
            pygame.draw.rect(screen, (0, 255, 0), (segment[0], segment[1], 20, 20))
        pygame.draw.rect(screen, (255, 0, 0), (self.food.x, self.food.y, 20, 20))


def main():
    game = Game()
    game.run()


if __name__ == '__main__':
    main()

```


## Code to be Reviewed: snake.py
```Code
# snake.py

class Snake:
    def __init__(self):
        """
        Initialize the Snake object with default values.
        
        Attributes:
            body (list): A list of tuples representing the snake's body positions.
            direction (str): The current direction of the snake.
        """
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        """
        Move the snake one step in the current direction.
        
        Updates the snake's body positions based on the current direction.
        """
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        """
        Grow the snake by adding a new segment to its body.
        
        Inserts a new segment at the beginning of the snake's body.
        """
        self.body.insert(0, self.body[0])

    def check_collision(self, board):
        """
        Check if the snake has collided with the board or itself.
        
        Args:
            board (Board): The game board object.
        
        Returns:
            bool: True if collision is detected, False otherwise.
        """
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False

```



# Format example 1
## Code Review: snake.py
1. No, we should fix the logic of class A due to ...
2. ...
3. ...
4. No, function B is not implemented, ...
5. ...
6. ...

## Actions
1. Fix the `handle_events` method to update the game state only if a move is successful.
   ```python
   def handle_events(self):
       for event in pygame.event.get():
           if event.type == pygame.QUIT:
               return False
           if event.type == pygame.KEYDOWN:
               moved = False
               if event.key == pygame.K_UP:
                   moved = self.game.move('UP')
               elif event.key == pygame.K_DOWN:
                   moved = self.game.move('DOWN')
               elif event.key == pygame.K_LEFT:
                   moved = self.game.move('LEFT')
               elif event.key == pygame.K_RIGHT:
                   moved = self.game.move('RIGHT')
               if moved:
                   # Update the game state only if a move was successful
                   self.render()
       return True
   ```
2. Implement function B

## Code Review Result
LBTM

# Format example 2
## Code Review: snake.py
1. Yes.
2. Yes.
3. Yes.
4. Yes.
5. Yes.
6. Yes.

## Actions
pass

## Code Review Result
LGTM



# Instruction: Based on the actual code situation, follow one of the "Format example". Return only 1 file under review.

## Code Review: Ordered List. Based on the "Code to be Reviewed", provide key, clear, concise, and specific answer. If any answer is no, explain how to fix it step by step.
1. Is the code implemented as per the requirements? If not, how to achieve it? Analyse it step by step.
2. Is the code logic completely correct? If there are errors, please indicate how to correct them.
3. Does the existing code follow the "Data structures and interfaces"?
4. Are all functions implemented? If there is no implementation, please indicate how to achieve it step by step.
5. Have all necessary pre-dependencies been imported? If not, indicate which ones need to be imported
6. Are methods from other files being reused correctly?

## Actions: Ordered List. Things that should be done after CR, such as implementing class A and function B

## Code Review Result: str. If the code doesn't have bugs, we don't need to rewrite it, so answer LGTM and stop. ONLY ANSWER LGTM/LBTM.
LGTM/LBTM






# System
Role: You are a professional software engineer, and your main task is to review and revise the code. You need to ensure that the code conforms to the google-style standards, is elegantly designed and modularized, easy to read and maintain.
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## System Design
{"Implementation approach":"We will utilize the Pygame library to create a snake game in Python. The game will feature a grid-based board with clear boundaries, smooth snake movement, and collision detection. We will implement a scoring system that increases when the snake eats food and a restart feature when the snake collides with the boundary or itself.","File list":["main.py","game.py","snake.py","food.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -board: Board\n        -snake: Snake\n        -food: Food\n        +__init__()\n        +run()\n        +handle_events()\n        +update_game_state()\n        +draw_game_elements()\n    }\n    class Board {\n        -width: int\n        -height: int\n        -grid_size: int\n        +__init__(width: int, height: int, grid_size: int)\n        +draw_grid()\n    }\n    class Snake {\n        -body: list\n        -direction: str\n        +__init__()\n        +move()\n        +grow()\n        +check_collision()\n    }\n    class Food {\n        -x: int\n        -y: int\n        +__init__(x: int, y: int)\n        +generate_new_food()\n    }\n    Game --> Board\n    Game --> Snake\n    Game --> Food\n","Program call flow":"\nsequenceDiagram\n    participant G as Game\n    participant B as Board\n    participant S as Snake\n    participant F as Food\n    G->>B: initialize_board(width, height, grid_size)\n    B-->>G: return board\n    G->>S: initialize_snake()\n    S-->>G: return snake\n    G->>F: generate_food()\n    F-->>G: return food\n    G->>G: run_game_loop()\n    G->>G: handle_events()\n    G->>S: update_snake_position()\n    S-->>G: return new_snake_position\n    G->>F: check_for_food_collision()\n    F-->>G: return food_collision_result\n    G->>G: update_game_state()\n    G->>B: draw_board()\n    B-->>G: return drawn_board\n    G->>S: draw_snake()\n    S-->>G: return drawn_snake\n    G->>F: draw_food()\n    F-->>G: return drawn_food\n","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Task
{"Required Python packages":["pygame"],"Required Other language third-party packages":["No third-party dependencies required"],"Logic Analysis":[["game.py","Contains Game class and run, handle_events, update_game_state, draw_game_elements functions"],["snake.py","Contains Snake class and move, grow, check_collision functions"],["food.py","Contains Food class and generate_new_food function"],["main.py","Contains main function, from game import Game"]],"Task list":["game.py","snake.py","food.py","main.py"],"Full API spec":"","Shared Knowledge":"`game.py` contains functions shared across the project. The grid size and snake movement speed need to be clarified.","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Code Files
----- game.py
```import pygame
import sys
import random

class Board:
    def __init__(self, width=800, height=600, grid_size=20):
        self.width = width
        self.height = height
        self.grid_size = grid_size

    def draw_grid(self, screen):
        for x in range(0, self.width, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (x, 0), (x, self.height))
        for y in range(0, self.height, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (0, y), (self.width, y))


class Snake:
    def __init__(self):
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        self.body.insert(0, self.body[0])

    def check_collision(self, board):
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False


class Food:
    def __init__(self, x=400, y=300):
        self.x = x
        self.y = y

    def generate_new_food(self, board, snake):
        while True:
            self.x = random.randint(0, board.width - 20) // 20 * 20
            self.y = random.randint(0, board.height - 20) // 20 * 20
            if (self.x, self.y) not in snake.body:
                break


class Game:
    def __init__(self):
        self.board = Board()
        self.snake = Snake()
        self.food = Food()

    def run(self):
        pygame.init()
        screen = pygame.display.set_mode((self.board.width, self.board.height))
        clock = pygame.time.Clock()
        while True:
            self.handle_events()
            self.update_game_state()
            self.draw_game_elements(screen)
            pygame.display.flip()
            clock.tick(10)

    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_UP and self.snake.direction != 'DOWN':
                    self.snake.direction = 'UP'
                elif event.key == pygame.K_DOWN and self.snake.direction != 'UP':
                    self.snake.direction = 'DOWN'
                elif event.key == pygame.K_LEFT and self.snake.direction != 'RIGHT':
                    self.snake.direction = 'LEFT'
                elif event.key == pygame.K_RIGHT and self.snake.direction != 'LEFT':
                    self.snake.direction = 'RIGHT'

    def update_game_state(self):
        self.snake.move()
        if self.snake.check_collision(self.board):
            print("Game Over! Final Score: ", len(self.snake.body))
            play_again = input("Play again? (yes/no): ")
            if play_again.lower() == "yes":
                self.__init__()
            else:
                pygame.quit()
                sys.exit()
        if (self.snake.body[-1][0] == self.food.x and
                self.snake.body[-1][1] == self.food.y):
            self.snake.grow()
            self.food.generate_new_food(self.board, self.snake)

    def draw_game_elements(self, screen):
        screen.fill((0, 0, 0))
        self.board.draw_grid(screen)
        for segment in self.snake.body:
            pygame.draw.rect(screen, (0, 255, 0), (segment[0], segment[1], 20, 20))
        pygame.draw.rect(screen, (255, 0, 0), (self.food.x, self.food.y, 20, 20))


def main():
    game = Game()
    game.run()


if __name__ == '__main__':
    main()

```


## Code to be Reviewed: snake.py
```Code
# snake.py

class Snake:
    def __init__(self):
        """
        Initialize the Snake object with default values.
        
        Attributes:
            body (list): A list of tuples representing the snake's body positions.
            direction (str): The current direction of the snake.
        """
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        """
        Move the snake one step in the current direction.
        
        Updates the snake's body positions based on the current direction.
        """
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        """
        Grow the snake by adding a new segment to its body.
        
        Inserts a new segment at the beginning of the snake's body.
        """
        self.body.insert(0, self.body[0])

    def check_collision(self, board):
        """
        Check if the snake has collided with the board or itself.
        
        Args:
            board (Board): The game board object.
        
        Returns:
            bool: True if collision is detected, False otherwise.
        """
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False

```

## Code Review: snake.py
1. Yes, the code is implemented as per the requirements. The Snake class has the necessary methods for movement, growth, and collision detection.
2. The code logic appears to be mostly correct. However, there's a potential issue in the `grow` method where it inserts a new segment at the beginning of the snake's body by copying the first element (`self.body[0]`). This might not be the intended behavior when the snake grows, as it should add a new segment in the direction of movement, not duplicate an existing one. To fix this, the `grow` method should add a new segment based on the current direction and the last segment's position.
3. The existing code follows the "Data structures and interfaces" provided, with the Snake class having attributes for its body and direction, and methods for moving, growing, and checking collisions.
4. All functions are implemented within the Snake class itself. However, the usage of these functions (like `move`, `grow`, and `check_collision`) in the context of a larger game loop or event handling is not shown here but is presumably handled elsewhere (e.g., in the Game class).
5. The necessary pre-dependencies for this specific file (`snake.py`) seem to be imported correctly, assuming that the Board class is defined elsewhere and properly imported where needed.
6. Methods from other files are not directly reused within this snippet of `snake.py`, but it's designed to work with a Board object and presumably other game elements (like Food) in a larger context.

## Actions
1. Review the `grow` method to ensure it correctly adds new segments based on the snake's direction.
2. Ensure proper integration with the Game class and other game elements for comprehensive functionality.

## Code Review Result
LBTM

# Instruction: rewrite code based on the Code Review and Actions
## Rewrite Code: CodeBlock. If it still has some bugs, rewrite snake.py with triple quotes. Do your utmost to optimize THIS SINGLE FILE. Return all completed codes and prohibit the return of unfinished codes.
```Code
## snake.py
...
```





# System
Role: You are a professional software engineer, and your main task is to review and revise the code. You need to ensure that the code conforms to the google-style standards, is elegantly designed and modularized, easy to read and maintain.
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## System Design
{"Implementation approach":"We will utilize the Pygame library to create a snake game in Python. The game will feature a grid-based board with clear boundaries, smooth snake movement, and collision detection. We will implement a scoring system that increases when the snake eats food and a restart feature when the snake collides with the boundary or itself.","File list":["main.py","game.py","snake.py","food.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -board: Board\n        -snake: Snake\n        -food: Food\n        +__init__()\n        +run()\n        +handle_events()\n        +update_game_state()\n        +draw_game_elements()\n    }\n    class Board {\n        -width: int\n        -height: int\n        -grid_size: int\n        +__init__(width: int, height: int, grid_size: int)\n        +draw_grid()\n    }\n    class Snake {\n        -body: list\n        -direction: str\n        +__init__()\n        +move()\n        +grow()\n        +check_collision()\n    }\n    class Food {\n        -x: int\n        -y: int\n        +__init__(x: int, y: int)\n        +generate_new_food()\n    }\n    Game --> Board\n    Game --> Snake\n    Game --> Food\n","Program call flow":"\nsequenceDiagram\n    participant G as Game\n    participant B as Board\n    participant S as Snake\n    participant F as Food\n    G->>B: initialize_board(width, height, grid_size)\n    B-->>G: return board\n    G->>S: initialize_snake()\n    S-->>G: return snake\n    G->>F: generate_food()\n    F-->>G: return food\n    G->>G: run_game_loop()\n    G->>G: handle_events()\n    G->>S: update_snake_position()\n    S-->>G: return new_snake_position\n    G->>F: check_for_food_collision()\n    F-->>G: return food_collision_result\n    G->>G: update_game_state()\n    G->>B: draw_board()\n    B-->>G: return drawn_board\n    G->>S: draw_snake()\n    S-->>G: return drawn_snake\n    G->>F: draw_food()\n    F-->>G: return drawn_food\n","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Task
{"Required Python packages":["pygame"],"Required Other language third-party packages":["No third-party dependencies required"],"Logic Analysis":[["game.py","Contains Game class and run, handle_events, update_game_state, draw_game_elements functions"],["snake.py","Contains Snake class and move, grow, check_collision functions"],["food.py","Contains Food class and generate_new_food function"],["main.py","Contains main function, from game import Game"]],"Task list":["game.py","snake.py","food.py","main.py"],"Full API spec":"","Shared Knowledge":"`game.py` contains functions shared across the project. The grid size and snake movement speed need to be clarified.","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Code Files
----- game.py
```import pygame
import sys
import random

class Board:
    def __init__(self, width=800, height=600, grid_size=20):
        self.width = width
        self.height = height
        self.grid_size = grid_size

    def draw_grid(self, screen):
        for x in range(0, self.width, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (x, 0), (x, self.height))
        for y in range(0, self.height, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (0, y), (self.width, y))


class Snake:
    def __init__(self):
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        self.body.insert(0, self.body[0])

    def check_collision(self, board):
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False


class Food:
    def __init__(self, x=400, y=300):
        self.x = x
        self.y = y

    def generate_new_food(self, board, snake):
        while True:
            self.x = random.randint(0, board.width - 20) // 20 * 20
            self.y = random.randint(0, board.height - 20) // 20 * 20
            if (self.x, self.y) not in snake.body:
                break


class Game:
    def __init__(self):
        self.board = Board()
        self.snake = Snake()
        self.food = Food()

    def run(self):
        pygame.init()
        screen = pygame.display.set_mode((self.board.width, self.board.height))
        clock = pygame.time.Clock()
        while True:
            self.handle_events()
            self.update_game_state()
            self.draw_game_elements(screen)
            pygame.display.flip()
            clock.tick(10)

    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_UP and self.snake.direction != 'DOWN':
                    self.snake.direction = 'UP'
                elif event.key == pygame.K_DOWN and self.snake.direction != 'UP':
                    self.snake.direction = 'DOWN'
                elif event.key == pygame.K_LEFT and self.snake.direction != 'RIGHT':
                    self.snake.direction = 'LEFT'
                elif event.key == pygame.K_RIGHT and self.snake.direction != 'LEFT':
                    self.snake.direction = 'RIGHT'

    def update_game_state(self):
        self.snake.move()
        if self.snake.check_collision(self.board):
            print("Game Over! Final Score: ", len(self.snake.body))
            play_again = input("Play again? (yes/no): ")
            if play_again.lower() == "yes":
                self.__init__()
            else:
                pygame.quit()
                sys.exit()
        if (self.snake.body[-1][0] == self.food.x and
                self.snake.body[-1][1] == self.food.y):
            self.snake.grow()
            self.food.generate_new_food(self.board, self.snake)

    def draw_game_elements(self, screen):
        screen.fill((0, 0, 0))
        self.board.draw_grid(screen)
        for segment in self.snake.body:
            pygame.draw.rect(screen, (0, 255, 0), (segment[0], segment[1], 20, 20))
        pygame.draw.rect(screen, (255, 0, 0), (self.food.x, self.food.y, 20, 20))


def main():
    game = Game()
    game.run()


if __name__ == '__main__':
    main()

```


## Code to be Reviewed: snake.py
```Code
# snake.py

class Snake:
    def __init__(self):
        """
        Initialize the Snake object with default values.
        
        Attributes:
            body (list): A list of tuples representing the snake's body positions.
            direction (str): The current direction of the snake.
        """
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        """
        Move the snake one step in the current direction.
        
        Updates the snake's body positions based on the current direction.
        """
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        """
        Grow the snake by adding a new segment to its body.
        
        Inserts a new segment at the end of the snake's body based on the current direction.
        """
        last_segment = self.body[-1]
        if self.direction == 'RIGHT':
            new_segment = (last_segment[0] - 20, last_segment[1])
        elif self.direction == 'LEFT':
            new_segment = (last_segment[0] + 20, last_segment[1])
        elif self.direction == 'UP':
            new_segment = (last_segment[0], last_segment[1] + 20)
        elif self.direction == 'DOWN':
            new_segment = (last_segment[0], last_segment[1] - 20)
        self.body.insert(0, new_segment)

    def check_collision(self, board):
        """
        Check if the snake has collided with the board or itself.
        
        Args:
            board (Board): The game board object.
        
        Returns:
            bool: True if collision is detected, False otherwise.
        """
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False


```



# Format example 1
## Code Review: snake.py
1. No, we should fix the logic of class A due to ...
2. ...
3. ...
4. No, function B is not implemented, ...
5. ...
6. ...

## Actions
1. Fix the `handle_events` method to update the game state only if a move is successful.
   ```python
   def handle_events(self):
       for event in pygame.event.get():
           if event.type == pygame.QUIT:
               return False
           if event.type == pygame.KEYDOWN:
               moved = False
               if event.key == pygame.K_UP:
                   moved = self.game.move('UP')
               elif event.key == pygame.K_DOWN:
                   moved = self.game.move('DOWN')
               elif event.key == pygame.K_LEFT:
                   moved = self.game.move('LEFT')
               elif event.key == pygame.K_RIGHT:
                   moved = self.game.move('RIGHT')
               if moved:
                   # Update the game state only if a move was successful
                   self.render()
       return True
   ```
2. Implement function B

## Code Review Result
LBTM

# Format example 2
## Code Review: snake.py
1. Yes.
2. Yes.
3. Yes.
4. Yes.
5. Yes.
6. Yes.

## Actions
pass

## Code Review Result
LGTM



# Instruction: Based on the actual code situation, follow one of the "Format example". Return only 1 file under review.

## Code Review: Ordered List. Based on the "Code to be Reviewed", provide key, clear, concise, and specific answer. If any answer is no, explain how to fix it step by step.
1. Is the code implemented as per the requirements? If not, how to achieve it? Analyse it step by step.
2. Is the code logic completely correct? If there are errors, please indicate how to correct them.
3. Does the existing code follow the "Data structures and interfaces"?
4. Are all functions implemented? If there is no implementation, please indicate how to achieve it step by step.
5. Have all necessary pre-dependencies been imported? If not, indicate which ones need to be imported
6. Are methods from other files being reused correctly?

## Actions: Ordered List. Things that should be done after CR, such as implementing class A and function B

## Code Review Result: str. If the code doesn't have bugs, we don't need to rewrite it, so answer LGTM and stop. ONLY ANSWER LGTM/LBTM.
LGTM/LBTM






# System
Role: You are a professional software engineer, and your main task is to review and revise the code. You need to ensure that the code conforms to the google-style standards, is elegantly designed and modularized, easy to read and maintain.
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## System Design
{"Implementation approach":"We will utilize the Pygame library to create a snake game in Python. The game will feature a grid-based board with clear boundaries, smooth snake movement, and collision detection. We will implement a scoring system that increases when the snake eats food and a restart feature when the snake collides with the boundary or itself.","File list":["main.py","game.py","snake.py","food.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -board: Board\n        -snake: Snake\n        -food: Food\n        +__init__()\n        +run()\n        +handle_events()\n        +update_game_state()\n        +draw_game_elements()\n    }\n    class Board {\n        -width: int\n        -height: int\n        -grid_size: int\n        +__init__(width: int, height: int, grid_size: int)\n        +draw_grid()\n    }\n    class Snake {\n        -body: list\n        -direction: str\n        +__init__()\n        +move()\n        +grow()\n        +check_collision()\n    }\n    class Food {\n        -x: int\n        -y: int\n        +__init__(x: int, y: int)\n        +generate_new_food()\n    }\n    Game --> Board\n    Game --> Snake\n    Game --> Food\n","Program call flow":"\nsequenceDiagram\n    participant G as Game\n    participant B as Board\n    participant S as Snake\n    participant F as Food\n    G->>B: initialize_board(width, height, grid_size)\n    B-->>G: return board\n    G->>S: initialize_snake()\n    S-->>G: return snake\n    G->>F: generate_food()\n    F-->>G: return food\n    G->>G: run_game_loop()\n    G->>G: handle_events()\n    G->>S: update_snake_position()\n    S-->>G: return new_snake_position\n    G->>F: check_for_food_collision()\n    F-->>G: return food_collision_result\n    G->>G: update_game_state()\n    G->>B: draw_board()\n    B-->>G: return drawn_board\n    G->>S: draw_snake()\n    S-->>G: return drawn_snake\n    G->>F: draw_food()\n    F-->>G: return drawn_food\n","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Task
{"Required Python packages":["pygame"],"Required Other language third-party packages":["No third-party dependencies required"],"Logic Analysis":[["game.py","Contains Game class and run, handle_events, update_game_state, draw_game_elements functions"],["snake.py","Contains Snake class and move, grow, check_collision functions"],["food.py","Contains Food class and generate_new_food function"],["main.py","Contains main function, from game import Game"]],"Task list":["game.py","snake.py","food.py","main.py"],"Full API spec":"","Shared Knowledge":"`game.py` contains functions shared across the project. The grid size and snake movement speed need to be clarified.","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Code Files
----- game.py
```import pygame
import sys
import random

class Board:
    def __init__(self, width=800, height=600, grid_size=20):
        self.width = width
        self.height = height
        self.grid_size = grid_size

    def draw_grid(self, screen):
        for x in range(0, self.width, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (x, 0), (x, self.height))
        for y in range(0, self.height, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (0, y), (self.width, y))


class Snake:
    def __init__(self):
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        self.body.insert(0, self.body[0])

    def check_collision(self, board):
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False


class Food:
    def __init__(self, x=400, y=300):
        self.x = x
        self.y = y

    def generate_new_food(self, board, snake):
        while True:
            self.x = random.randint(0, board.width - 20) // 20 * 20
            self.y = random.randint(0, board.height - 20) // 20 * 20
            if (self.x, self.y) not in snake.body:
                break


class Game:
    def __init__(self):
        self.board = Board()
        self.snake = Snake()
        self.food = Food()

    def run(self):
        pygame.init()
        screen = pygame.display.set_mode((self.board.width, self.board.height))
        clock = pygame.time.Clock()
        while True:
            self.handle_events()
            self.update_game_state()
            self.draw_game_elements(screen)
            pygame.display.flip()
            clock.tick(10)

    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_UP and self.snake.direction != 'DOWN':
                    self.snake.direction = 'UP'
                elif event.key == pygame.K_DOWN and self.snake.direction != 'UP':
                    self.snake.direction = 'DOWN'
                elif event.key == pygame.K_LEFT and self.snake.direction != 'RIGHT':
                    self.snake.direction = 'LEFT'
                elif event.key == pygame.K_RIGHT and self.snake.direction != 'LEFT':
                    self.snake.direction = 'RIGHT'

    def update_game_state(self):
        self.snake.move()
        if self.snake.check_collision(self.board):
            print("Game Over! Final Score: ", len(self.snake.body))
            play_again = input("Play again? (yes/no): ")
            if play_again.lower() == "yes":
                self.__init__()
            else:
                pygame.quit()
                sys.exit()
        if (self.snake.body[-1][0] == self.food.x and
                self.snake.body[-1][1] == self.food.y):
            self.snake.grow()
            self.food.generate_new_food(self.board, self.snake)

    def draw_game_elements(self, screen):
        screen.fill((0, 0, 0))
        self.board.draw_grid(screen)
        for segment in self.snake.body:
            pygame.draw.rect(screen, (0, 255, 0), (segment[0], segment[1], 20, 20))
        pygame.draw.rect(screen, (255, 0, 0), (self.food.x, self.food.y, 20, 20))


def main():
    game = Game()
    game.run()


if __name__ == '__main__':
    main()

```


## Code to be Reviewed: snake.py
```Code
# snake.py

class Snake:
    def __init__(self):
        """
        Initialize the Snake object with default values.
        
        Attributes:
            body (list): A list of tuples representing the snake's body positions.
            direction (str): The current direction of the snake.
        """
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        """
        Move the snake one step in the current direction.
        
        Updates the snake's body positions based on the current direction.
        """
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        """
        Grow the snake by adding a new segment to its body.
        
        Inserts a new segment at the end of the snake's body based on the current direction.
        """
        last_segment = self.body[-1]
        if self.direction == 'RIGHT':
            new_segment = (last_segment[0] - 20, last_segment[1])
        elif self.direction == 'LEFT':
            new_segment = (last_segment[0] + 20, last_segment[1])
        elif self.direction == 'UP':
            new_segment = (last_segment[0], last_segment[1] + 20)
        elif self.direction == 'DOWN':
            new_segment = (last_segment[0], last_segment[1] - 20)
        self.body.insert(0, new_segment)

    def check_collision(self, board):
        """
        Check if the snake has collided with the board or itself.
        
        Args:
            board (Board): The game board object.
        
        Returns:
            bool: True if collision is detected, False otherwise.
        """
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False


```

## Code Review: snake.py
1. No, the code does not fully implement the requirements as per the provided "Data structures and interfaces". The `grow` method in the `Snake` class is incorrectly implemented. It should add a new segment to the end of the snake's body when the snake eats food, but instead, it inserts a new segment at the beginning of the snake's body based on the current direction.
2. No, there are errors in the code logic. The `grow` method should be corrected to add a new segment to the end of the snake's body. Additionally, the `check_collision` method does not handle the case where the snake collides with itself correctly. It only checks if the head of the snake is in the same position as any other segment, but it does not consider the case where the snake's head is in the same position as its own body.
3. No, the existing code does not follow the "Data structures and interfaces" provided. The `Snake` class should have a `move` method that updates the snake's position based on its current direction, and a `grow` method that adds a new segment to the end of the snake's body when the snake eats food.
4. No, not all functions are implemented correctly. The `grow` method is incorrectly implemented, and the `check_collision` method does not handle all possible collision cases.
5. Yes, all necessary pre-dependencies have been imported.
6. No, methods from other files are not being reused correctly. The `Snake` class should be used in conjunction with the `Game` class to update the game state and handle events.

## Actions
1. Correct the implementation of the `grow` method in the `Snake` class to add a new segment to the end of the snake's body.
2. Implement the `check_collision` method to correctly handle all possible collision cases, including collisions with the board and itself.
3. Use the `Snake` class in conjunction with the `Game` class to update the game state and handle events.

## Code Review Result
LBTM

# Instruction: rewrite code based on the Code Review and Actions
## Rewrite Code: CodeBlock. If it still has some bugs, rewrite snake.py with triple quotes. Do your utmost to optimize THIS SINGLE FILE. Return all completed codes and prohibit the return of unfinished codes.
```Code
## snake.py
...
```





NOTICE
Role: You are a professional engineer; the main goal is to write google-style, elegant, modular, easy to read and maintain code
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## Design
{"Implementation approach":"We will utilize the Pygame library to create a snake game in Python. The game will feature a grid-based board with clear boundaries, smooth snake movement, and collision detection. We will implement a scoring system that increases when the snake eats food and a restart feature when the snake collides with the boundary or itself.","File list":["main.py","game.py","snake.py","food.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -board: Board\n        -snake: Snake\n        -food: Food\n        +__init__()\n        +run()\n        +handle_events()\n        +update_game_state()\n        +draw_game_elements()\n    }\n    class Board {\n        -width: int\n        -height: int\n        -grid_size: int\n        +__init__(width: int, height: int, grid_size: int)\n        +draw_grid()\n    }\n    class Snake {\n        -body: list\n        -direction: str\n        +__init__()\n        +move()\n        +grow()\n        +check_collision()\n    }\n    class Food {\n        -x: int\n        -y: int\n        +__init__(x: int, y: int)\n        +generate_new_food()\n    }\n    Game --> Board\n    Game --> Snake\n    Game --> Food\n","Program call flow":"\nsequenceDiagram\n    participant G as Game\n    participant B as Board\n    participant S as Snake\n    participant F as Food\n    G->>B: initialize_board(width, height, grid_size)\n    B-->>G: return board\n    G->>S: initialize_snake()\n    S-->>G: return snake\n    G->>F: generate_food()\n    F-->>G: return food\n    G->>G: run_game_loop()\n    G->>G: handle_events()\n    G->>S: update_snake_position()\n    S-->>G: return new_snake_position\n    G->>F: check_for_food_collision()\n    F-->>G: return food_collision_result\n    G->>G: update_game_state()\n    G->>B: draw_board()\n    B-->>G: return drawn_board\n    G->>S: draw_snake()\n    S-->>G: return drawn_snake\n    G->>F: draw_food()\n    F-->>G: return drawn_food\n","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Task
{"Required Python packages":["pygame"],"Required Other language third-party packages":["No third-party dependencies required"],"Logic Analysis":[["game.py","Contains Game class and run, handle_events, update_game_state, draw_game_elements functions"],["snake.py","Contains Snake class and move, grow, check_collision functions"],["food.py","Contains Food class and generate_new_food function"],["main.py","Contains main function, from game import Game"]],"Task list":["game.py","snake.py","food.py","main.py"],"Full API spec":"","Shared Knowledge":"`game.py` contains functions shared across the project. The grid size and snake movement speed need to be clarified.","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Legacy Code
```Code
----- game.py
```import pygame
import sys
import random

class Board:
    def __init__(self, width=800, height=600, grid_size=20):
        self.width = width
        self.height = height
        self.grid_size = grid_size

    def draw_grid(self, screen):
        for x in range(0, self.width, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (x, 0), (x, self.height))
        for y in range(0, self.height, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (0, y), (self.width, y))


class Snake:
    def __init__(self):
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        self.body.insert(0, self.body[0])

    def check_collision(self, board):
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False


class Food:
    def __init__(self, x=400, y=300):
        self.x = x
        self.y = y

    def generate_new_food(self, board, snake):
        while True:
            self.x = random.randint(0, board.width - 20) // 20 * 20
            self.y = random.randint(0, board.height - 20) // 20 * 20
            if (self.x, self.y) not in snake.body:
                break


class Game:
    def __init__(self):
        self.board = Board()
        self.snake = Snake()
        self.food = Food()

    def run(self):
        pygame.init()
        screen = pygame.display.set_mode((self.board.width, self.board.height))
        clock = pygame.time.Clock()
        while True:
            self.handle_events()
            self.update_game_state()
            self.draw_game_elements(screen)
            pygame.display.flip()
            clock.tick(10)

    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_UP and self.snake.direction != 'DOWN':
                    self.snake.direction = 'UP'
                elif event.key == pygame.K_DOWN and self.snake.direction != 'UP':
                    self.snake.direction = 'DOWN'
                elif event.key == pygame.K_LEFT and self.snake.direction != 'RIGHT':
                    self.snake.direction = 'LEFT'
                elif event.key == pygame.K_RIGHT and self.snake.direction != 'LEFT':
                    self.snake.direction = 'RIGHT'

    def update_game_state(self):
        self.snake.move()
        if self.snake.check_collision(self.board):
            print("Game Over! Final Score: ", len(self.snake.body))
            play_again = input("Play again? (yes/no): ")
            if play_again.lower() == "yes":
                self.__init__()
            else:
                pygame.quit()
                sys.exit()
        if (self.snake.body[-1][0] == self.food.x and
                self.snake.body[-1][1] == self.food.y):
            self.snake.grow()
            self.food.generate_new_food(self.board, self.snake)

    def draw_game_elements(self, screen):
        screen.fill((0, 0, 0))
        self.board.draw_grid(screen)
        for segment in self.snake.body:
            pygame.draw.rect(screen, (0, 255, 0), (segment[0], segment[1], 20, 20))
        pygame.draw.rect(screen, (255, 0, 0), (self.food.x, self.food.y, 20, 20))


def main():
    game = Game()
    game.run()


if __name__ == '__main__':
    main()

```
----- snake.py
```## snake.py
class Snake:
    def __init__(self):
        """
        Initialize the Snake object with default values.
        
        Attributes:
            body (list): A list of tuples representing the snake's body positions.
            direction (str): The current direction of the snake.
        """
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        """
        Move the snake one step in the current direction.
        
        Updates the snake's body positions based on the current direction.
        """
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        """
        Grow the snake by adding a new segment to its body.
        
        Appends a new segment at the end of the snake's body based on the current direction.
        """
        last_segment = self.body[-1]
        if self.direction == 'RIGHT':
            new_segment = (last_segment[0] + 20, last_segment[1])
        elif self.direction == 'LEFT':
            new_segment = (last_segment[0] - 20, last_segment[1])
        elif self.direction == 'UP':
            new_segment = (last_segment[0], last_segment[1] - 20)
        elif self.direction == 'DOWN':
            new_segment = (last_segment[0], last_segment[1] + 20)
        self.body.append(new_segment)

    def check_collision(self, board):
        """
        Check if the snake has collided with the board or itself.
        
        Args:
            board (Board): The game board object.
        
        Returns:
            bool: True if collision is detected, False otherwise.
        """
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False
```
```

## Debug logs
```text



```

## Bug Feedback logs
```text

```

# Format example
## Code: food.py
```python
## food.py
...
```

# Instruction: Based on the context, follow "Format example", write code.

## Code: food.py. Write code with triple quoto, based on the following attentions and context.
1. Only One file: do your best to implement THIS ONLY ONE FILE.
2. COMPLETE CODE: Your code will be part of the entire project, so please implement complete, reliable, reusable code snippets.
3. Set default value: If there is any setting, ALWAYS SET A DEFAULT VALUE, ALWAYS USE STRONG TYPE AND EXPLICIT VARIABLE. AVOID circular import.
4. Follow design: YOU MUST FOLLOW "Data structures and interfaces". DONT CHANGE ANY DESIGN. Do not use public member functions that do not exist in your design.
5. CAREFULLY CHECK THAT YOU DONT MISS ANY NECESSARY CLASS/FUNCTION IN THIS FILE.
6. Before using a external variable/module, make sure you import it first.
7. Write out EVERY CODE DETAIL, DON'T LEAVE TODO.






# System
Role: You are a professional software engineer, and your main task is to review and revise the code. You need to ensure that the code conforms to the google-style standards, is elegantly designed and modularized, easy to read and maintain.
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## System Design
{"Implementation approach":"We will utilize the Pygame library to create a snake game in Python. The game will feature a grid-based board with clear boundaries, smooth snake movement, and collision detection. We will implement a scoring system that increases when the snake eats food and a restart feature when the snake collides with the boundary or itself.","File list":["main.py","game.py","snake.py","food.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -board: Board\n        -snake: Snake\n        -food: Food\n        +__init__()\n        +run()\n        +handle_events()\n        +update_game_state()\n        +draw_game_elements()\n    }\n    class Board {\n        -width: int\n        -height: int\n        -grid_size: int\n        +__init__(width: int, height: int, grid_size: int)\n        +draw_grid()\n    }\n    class Snake {\n        -body: list\n        -direction: str\n        +__init__()\n        +move()\n        +grow()\n        +check_collision()\n    }\n    class Food {\n        -x: int\n        -y: int\n        +__init__(x: int, y: int)\n        +generate_new_food()\n    }\n    Game --> Board\n    Game --> Snake\n    Game --> Food\n","Program call flow":"\nsequenceDiagram\n    participant G as Game\n    participant B as Board\n    participant S as Snake\n    participant F as Food\n    G->>B: initialize_board(width, height, grid_size)\n    B-->>G: return board\n    G->>S: initialize_snake()\n    S-->>G: return snake\n    G->>F: generate_food()\n    F-->>G: return food\n    G->>G: run_game_loop()\n    G->>G: handle_events()\n    G->>S: update_snake_position()\n    S-->>G: return new_snake_position\n    G->>F: check_for_food_collision()\n    F-->>G: return food_collision_result\n    G->>G: update_game_state()\n    G->>B: draw_board()\n    B-->>G: return drawn_board\n    G->>S: draw_snake()\n    S-->>G: return drawn_snake\n    G->>F: draw_food()\n    F-->>G: return drawn_food\n","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Task
{"Required Python packages":["pygame"],"Required Other language third-party packages":["No third-party dependencies required"],"Logic Analysis":[["game.py","Contains Game class and run, handle_events, update_game_state, draw_game_elements functions"],["snake.py","Contains Snake class and move, grow, check_collision functions"],["food.py","Contains Food class and generate_new_food function"],["main.py","Contains main function, from game import Game"]],"Task list":["game.py","snake.py","food.py","main.py"],"Full API spec":"","Shared Knowledge":"`game.py` contains functions shared across the project. The grid size and snake movement speed need to be clarified.","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Code Files
----- game.py
```import pygame
import sys
import random

class Board:
    def __init__(self, width=800, height=600, grid_size=20):
        self.width = width
        self.height = height
        self.grid_size = grid_size

    def draw_grid(self, screen):
        for x in range(0, self.width, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (x, 0), (x, self.height))
        for y in range(0, self.height, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (0, y), (self.width, y))


class Snake:
    def __init__(self):
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        self.body.insert(0, self.body[0])

    def check_collision(self, board):
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False


class Food:
    def __init__(self, x=400, y=300):
        self.x = x
        self.y = y

    def generate_new_food(self, board, snake):
        while True:
            self.x = random.randint(0, board.width - 20) // 20 * 20
            self.y = random.randint(0, board.height - 20) // 20 * 20
            if (self.x, self.y) not in snake.body:
                break


class Game:
    def __init__(self):
        self.board = Board()
        self.snake = Snake()
        self.food = Food()

    def run(self):
        pygame.init()
        screen = pygame.display.set_mode((self.board.width, self.board.height))
        clock = pygame.time.Clock()
        while True:
            self.handle_events()
            self.update_game_state()
            self.draw_game_elements(screen)
            pygame.display.flip()
            clock.tick(10)

    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_UP and self.snake.direction != 'DOWN':
                    self.snake.direction = 'UP'
                elif event.key == pygame.K_DOWN and self.snake.direction != 'UP':
                    self.snake.direction = 'DOWN'
                elif event.key == pygame.K_LEFT and self.snake.direction != 'RIGHT':
                    self.snake.direction = 'LEFT'
                elif event.key == pygame.K_RIGHT and self.snake.direction != 'LEFT':
                    self.snake.direction = 'RIGHT'

    def update_game_state(self):
        self.snake.move()
        if self.snake.check_collision(self.board):
            print("Game Over! Final Score: ", len(self.snake.body))
            play_again = input("Play again? (yes/no): ")
            if play_again.lower() == "yes":
                self.__init__()
            else:
                pygame.quit()
                sys.exit()
        if (self.snake.body[-1][0] == self.food.x and
                self.snake.body[-1][1] == self.food.y):
            self.snake.grow()
            self.food.generate_new_food(self.board, self.snake)

    def draw_game_elements(self, screen):
        screen.fill((0, 0, 0))
        self.board.draw_grid(screen)
        for segment in self.snake.body:
            pygame.draw.rect(screen, (0, 255, 0), (segment[0], segment[1], 20, 20))
        pygame.draw.rect(screen, (255, 0, 0), (self.food.x, self.food.y, 20, 20))


def main():
    game = Game()
    game.run()


if __name__ == '__main__':
    main()

```
----- snake.py
```## snake.py
class Snake:
    def __init__(self):
        """
        Initialize the Snake object with default values.
        
        Attributes:
            body (list): A list of tuples representing the snake's body positions.
            direction (str): The current direction of the snake.
        """
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        """
        Move the snake one step in the current direction.
        
        Updates the snake's body positions based on the current direction.
        """
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        """
        Grow the snake by adding a new segment to its body.
        
        Appends a new segment at the end of the snake's body based on the current direction.
        """
        last_segment = self.body[-1]
        if self.direction == 'RIGHT':
            new_segment = (last_segment[0] + 20, last_segment[1])
        elif self.direction == 'LEFT':
            new_segment = (last_segment[0] - 20, last_segment[1])
        elif self.direction == 'UP':
            new_segment = (last_segment[0], last_segment[1] - 20)
        elif self.direction == 'DOWN':
            new_segment = (last_segment[0], last_segment[1] + 20)
        self.body.append(new_segment)

    def check_collision(self, board):
        """
        Check if the snake has collided with the board or itself.
        
        Args:
            board (Board): The game board object.
        
        Returns:
            bool: True if collision is detected, False otherwise.
        """
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False
```


## Code to be Reviewed: food.py
```Code
class Food:
    def __init__(self, x: int = 400, y: int = 300):
        """
        Initialize the Food object with default values.
        
        Attributes:
            x (int): The x-coordinate of the food on the game board. Defaults to 400.
            y (int): The y-coordinate of the food on the game board. Defaults to 300.
        """
        self.x = x
        self.y = y

    def generate_new_food(self, board: 'Board', snake: 'Snake'):
        """
        Generate new food at a random position on the game board.
        
        Args:
            board (Board): The game board object.
            snake (Snake): The snake object.
        
        Returns:
            None
        """
        while True:
            self.x = random.randint(0, board.width - 20) // 20 * 20
            self.y = random.randint(0, board.height - 20) // 20 * 20
            if (self.x, self.y) not in snake.body:
                break

```



# Format example 1
## Code Review: food.py
1. No, we should fix the logic of class A due to ...
2. ...
3. ...
4. No, function B is not implemented, ...
5. ...
6. ...

## Actions
1. Fix the `handle_events` method to update the game state only if a move is successful.
   ```python
   def handle_events(self):
       for event in pygame.event.get():
           if event.type == pygame.QUIT:
               return False
           if event.type == pygame.KEYDOWN:
               moved = False
               if event.key == pygame.K_UP:
                   moved = self.game.move('UP')
               elif event.key == pygame.K_DOWN:
                   moved = self.game.move('DOWN')
               elif event.key == pygame.K_LEFT:
                   moved = self.game.move('LEFT')
               elif event.key == pygame.K_RIGHT:
                   moved = self.game.move('RIGHT')
               if moved:
                   # Update the game state only if a move was successful
                   self.render()
       return True
   ```
2. Implement function B

## Code Review Result
LBTM

# Format example 2
## Code Review: food.py
1. Yes.
2. Yes.
3. Yes.
4. Yes.
5. Yes.
6. Yes.

## Actions
pass

## Code Review Result
LGTM



# Instruction: Based on the actual code situation, follow one of the "Format example". Return only 1 file under review.

## Code Review: Ordered List. Based on the "Code to be Reviewed", provide key, clear, concise, and specific answer. If any answer is no, explain how to fix it step by step.
1. Is the code implemented as per the requirements? If not, how to achieve it? Analyse it step by step.
2. Is the code logic completely correct? If there are errors, please indicate how to correct them.
3. Does the existing code follow the "Data structures and interfaces"?
4. Are all functions implemented? If there is no implementation, please indicate how to achieve it step by step.
5. Have all necessary pre-dependencies been imported? If not, indicate which ones need to be imported
6. Are methods from other files being reused correctly?

## Actions: Ordered List. Things that should be done after CR, such as implementing class A and function B

## Code Review Result: str. If the code doesn't have bugs, we don't need to rewrite it, so answer LGTM and stop. ONLY ANSWER LGTM/LBTM.
LGTM/LBTM






# System
Role: You are a professional software engineer, and your main task is to review and revise the code. You need to ensure that the code conforms to the google-style standards, is elegantly designed and modularized, easy to read and maintain.
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## System Design
{"Implementation approach":"We will utilize the Pygame library to create a snake game in Python. The game will feature a grid-based board with clear boundaries, smooth snake movement, and collision detection. We will implement a scoring system that increases when the snake eats food and a restart feature when the snake collides with the boundary or itself.","File list":["main.py","game.py","snake.py","food.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -board: Board\n        -snake: Snake\n        -food: Food\n        +__init__()\n        +run()\n        +handle_events()\n        +update_game_state()\n        +draw_game_elements()\n    }\n    class Board {\n        -width: int\n        -height: int\n        -grid_size: int\n        +__init__(width: int, height: int, grid_size: int)\n        +draw_grid()\n    }\n    class Snake {\n        -body: list\n        -direction: str\n        +__init__()\n        +move()\n        +grow()\n        +check_collision()\n    }\n    class Food {\n        -x: int\n        -y: int\n        +__init__(x: int, y: int)\n        +generate_new_food()\n    }\n    Game --> Board\n    Game --> Snake\n    Game --> Food\n","Program call flow":"\nsequenceDiagram\n    participant G as Game\n    participant B as Board\n    participant S as Snake\n    participant F as Food\n    G->>B: initialize_board(width, height, grid_size)\n    B-->>G: return board\n    G->>S: initialize_snake()\n    S-->>G: return snake\n    G->>F: generate_food()\n    F-->>G: return food\n    G->>G: run_game_loop()\n    G->>G: handle_events()\n    G->>S: update_snake_position()\n    S-->>G: return new_snake_position\n    G->>F: check_for_food_collision()\n    F-->>G: return food_collision_result\n    G->>G: update_game_state()\n    G->>B: draw_board()\n    B-->>G: return drawn_board\n    G->>S: draw_snake()\n    S-->>G: return drawn_snake\n    G->>F: draw_food()\n    F-->>G: return drawn_food\n","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Task
{"Required Python packages":["pygame"],"Required Other language third-party packages":["No third-party dependencies required"],"Logic Analysis":[["game.py","Contains Game class and run, handle_events, update_game_state, draw_game_elements functions"],["snake.py","Contains Snake class and move, grow, check_collision functions"],["food.py","Contains Food class and generate_new_food function"],["main.py","Contains main function, from game import Game"]],"Task list":["game.py","snake.py","food.py","main.py"],"Full API spec":"","Shared Knowledge":"`game.py` contains functions shared across the project. The grid size and snake movement speed need to be clarified.","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Code Files
----- game.py
```import pygame
import sys
import random

class Board:
    def __init__(self, width=800, height=600, grid_size=20):
        self.width = width
        self.height = height
        self.grid_size = grid_size

    def draw_grid(self, screen):
        for x in range(0, self.width, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (x, 0), (x, self.height))
        for y in range(0, self.height, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (0, y), (self.width, y))


class Snake:
    def __init__(self):
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        self.body.insert(0, self.body[0])

    def check_collision(self, board):
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False


class Food:
    def __init__(self, x=400, y=300):
        self.x = x
        self.y = y

    def generate_new_food(self, board, snake):
        while True:
            self.x = random.randint(0, board.width - 20) // 20 * 20
            self.y = random.randint(0, board.height - 20) // 20 * 20
            if (self.x, self.y) not in snake.body:
                break


class Game:
    def __init__(self):
        self.board = Board()
        self.snake = Snake()
        self.food = Food()

    def run(self):
        pygame.init()
        screen = pygame.display.set_mode((self.board.width, self.board.height))
        clock = pygame.time.Clock()
        while True:
            self.handle_events()
            self.update_game_state()
            self.draw_game_elements(screen)
            pygame.display.flip()
            clock.tick(10)

    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_UP and self.snake.direction != 'DOWN':
                    self.snake.direction = 'UP'
                elif event.key == pygame.K_DOWN and self.snake.direction != 'UP':
                    self.snake.direction = 'DOWN'
                elif event.key == pygame.K_LEFT and self.snake.direction != 'RIGHT':
                    self.snake.direction = 'LEFT'
                elif event.key == pygame.K_RIGHT and self.snake.direction != 'LEFT':
                    self.snake.direction = 'RIGHT'

    def update_game_state(self):
        self.snake.move()
        if self.snake.check_collision(self.board):
            print("Game Over! Final Score: ", len(self.snake.body))
            play_again = input("Play again? (yes/no): ")
            if play_again.lower() == "yes":
                self.__init__()
            else:
                pygame.quit()
                sys.exit()
        if (self.snake.body[-1][0] == self.food.x and
                self.snake.body[-1][1] == self.food.y):
            self.snake.grow()
            self.food.generate_new_food(self.board, self.snake)

    def draw_game_elements(self, screen):
        screen.fill((0, 0, 0))
        self.board.draw_grid(screen)
        for segment in self.snake.body:
            pygame.draw.rect(screen, (0, 255, 0), (segment[0], segment[1], 20, 20))
        pygame.draw.rect(screen, (255, 0, 0), (self.food.x, self.food.y, 20, 20))


def main():
    game = Game()
    game.run()


if __name__ == '__main__':
    main()

```
----- snake.py
```## snake.py
class Snake:
    def __init__(self):
        """
        Initialize the Snake object with default values.
        
        Attributes:
            body (list): A list of tuples representing the snake's body positions.
            direction (str): The current direction of the snake.
        """
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        """
        Move the snake one step in the current direction.
        
        Updates the snake's body positions based on the current direction.
        """
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        """
        Grow the snake by adding a new segment to its body.
        
        Appends a new segment at the end of the snake's body based on the current direction.
        """
        last_segment = self.body[-1]
        if self.direction == 'RIGHT':
            new_segment = (last_segment[0] + 20, last_segment[1])
        elif self.direction == 'LEFT':
            new_segment = (last_segment[0] - 20, last_segment[1])
        elif self.direction == 'UP':
            new_segment = (last_segment[0], last_segment[1] - 20)
        elif self.direction == 'DOWN':
            new_segment = (last_segment[0], last_segment[1] + 20)
        self.body.append(new_segment)

    def check_collision(self, board):
        """
        Check if the snake has collided with the board or itself.
        
        Args:
            board (Board): The game board object.
        
        Returns:
            bool: True if collision is detected, False otherwise.
        """
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False
```


## Code to be Reviewed: food.py
```Code
class Food:
    def __init__(self, x: int = 400, y: int = 300):
        """
        Initialize the Food object with default values.
        
        Attributes:
            x (int): The x-coordinate of the food on the game board. Defaults to 400.
            y (int): The y-coordinate of the food on the game board. Defaults to 300.
        """
        self.x = x
        self.y = y

    def generate_new_food(self, board: 'Board', snake: 'Snake'):
        """
        Generate new food at a random position on the game board.
        
        Args:
            board (Board): The game board object.
            snake (Snake): The snake object.
        
        Returns:
            None
        """
        while True:
            self.x = random.randint(0, board.width - 20) // 20 * 20
            self.y = random.randint(0, board.height - 20) // 20 * 20
            if (self.x, self.y) not in snake.body:
                break

```

## Code Review: food.py
1. Yes, the `Food` class is implemented as per the requirements. It has an initializer method (`__init__`) that sets the x and y coordinates of the food, and a `generate_new_food` method that generates new food at a random position on the game board.
2. The code logic appears to be mostly correct. However, there might be a potential issue with the `generate_new_food` method. If the snake's body covers the entire board, this method could enter an infinite loop. To fix this, we could add a check to ensure that there is at least one empty space on the board before generating new food.
3. Yes, the existing code follows the "Data structures and interfaces" as specified in the class diagram. The `Food` class has the required attributes (`x` and `y`) and methods (`__init__` and `generate_new_food`).
4. Yes, all functions are implemented. The `Food` class has the required methods, and they seem to be correctly implemented.
5. Yes, all necessary pre-dependencies have been imported. The `random` module is imported for generating random numbers, and the `Board` and `Snake` classes are assumed to be defined elsewhere in the codebase.
6. Yes, methods from other files appear to be reused correctly. The `generate_new_food` method uses the `board` and `snake` objects as expected.

## Actions
1. Consider adding a check in the `generate_new_food` method to prevent an infinite loop if the snake covers the entire board.

## Code Review Result
LBTM

# Instruction: rewrite code based on the Code Review and Actions
## Rewrite Code: CodeBlock. If it still has some bugs, rewrite food.py with triple quotes. Do your utmost to optimize THIS SINGLE FILE. Return all completed codes and prohibit the return of unfinished codes.
```Code
## food.py
...
```





# System
Role: You are a professional software engineer, and your main task is to review and revise the code. You need to ensure that the code conforms to the google-style standards, is elegantly designed and modularized, easy to read and maintain.
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## System Design
{"Implementation approach":"We will utilize the Pygame library to create a snake game in Python. The game will feature a grid-based board with clear boundaries, smooth snake movement, and collision detection. We will implement a scoring system that increases when the snake eats food and a restart feature when the snake collides with the boundary or itself.","File list":["main.py","game.py","snake.py","food.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -board: Board\n        -snake: Snake\n        -food: Food\n        +__init__()\n        +run()\n        +handle_events()\n        +update_game_state()\n        +draw_game_elements()\n    }\n    class Board {\n        -width: int\n        -height: int\n        -grid_size: int\n        +__init__(width: int, height: int, grid_size: int)\n        +draw_grid()\n    }\n    class Snake {\n        -body: list\n        -direction: str\n        +__init__()\n        +move()\n        +grow()\n        +check_collision()\n    }\n    class Food {\n        -x: int\n        -y: int\n        +__init__(x: int, y: int)\n        +generate_new_food()\n    }\n    Game --> Board\n    Game --> Snake\n    Game --> Food\n","Program call flow":"\nsequenceDiagram\n    participant G as Game\n    participant B as Board\n    participant S as Snake\n    participant F as Food\n    G->>B: initialize_board(width, height, grid_size)\n    B-->>G: return board\n    G->>S: initialize_snake()\n    S-->>G: return snake\n    G->>F: generate_food()\n    F-->>G: return food\n    G->>G: run_game_loop()\n    G->>G: handle_events()\n    G->>S: update_snake_position()\n    S-->>G: return new_snake_position\n    G->>F: check_for_food_collision()\n    F-->>G: return food_collision_result\n    G->>G: update_game_state()\n    G->>B: draw_board()\n    B-->>G: return drawn_board\n    G->>S: draw_snake()\n    S-->>G: return drawn_snake\n    G->>F: draw_food()\n    F-->>G: return drawn_food\n","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Task
{"Required Python packages":["pygame"],"Required Other language third-party packages":["No third-party dependencies required"],"Logic Analysis":[["game.py","Contains Game class and run, handle_events, update_game_state, draw_game_elements functions"],["snake.py","Contains Snake class and move, grow, check_collision functions"],["food.py","Contains Food class and generate_new_food function"],["main.py","Contains main function, from game import Game"]],"Task list":["game.py","snake.py","food.py","main.py"],"Full API spec":"","Shared Knowledge":"`game.py` contains functions shared across the project. The grid size and snake movement speed need to be clarified.","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Code Files
----- game.py
```import pygame
import sys
import random

class Board:
    def __init__(self, width=800, height=600, grid_size=20):
        self.width = width
        self.height = height
        self.grid_size = grid_size

    def draw_grid(self, screen):
        for x in range(0, self.width, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (x, 0), (x, self.height))
        for y in range(0, self.height, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (0, y), (self.width, y))


class Snake:
    def __init__(self):
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        self.body.insert(0, self.body[0])

    def check_collision(self, board):
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False


class Food:
    def __init__(self, x=400, y=300):
        self.x = x
        self.y = y

    def generate_new_food(self, board, snake):
        while True:
            self.x = random.randint(0, board.width - 20) // 20 * 20
            self.y = random.randint(0, board.height - 20) // 20 * 20
            if (self.x, self.y) not in snake.body:
                break


class Game:
    def __init__(self):
        self.board = Board()
        self.snake = Snake()
        self.food = Food()

    def run(self):
        pygame.init()
        screen = pygame.display.set_mode((self.board.width, self.board.height))
        clock = pygame.time.Clock()
        while True:
            self.handle_events()
            self.update_game_state()
            self.draw_game_elements(screen)
            pygame.display.flip()
            clock.tick(10)

    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_UP and self.snake.direction != 'DOWN':
                    self.snake.direction = 'UP'
                elif event.key == pygame.K_DOWN and self.snake.direction != 'UP':
                    self.snake.direction = 'DOWN'
                elif event.key == pygame.K_LEFT and self.snake.direction != 'RIGHT':
                    self.snake.direction = 'LEFT'
                elif event.key == pygame.K_RIGHT and self.snake.direction != 'LEFT':
                    self.snake.direction = 'RIGHT'

    def update_game_state(self):
        self.snake.move()
        if self.snake.check_collision(self.board):
            print("Game Over! Final Score: ", len(self.snake.body))
            play_again = input("Play again? (yes/no): ")
            if play_again.lower() == "yes":
                self.__init__()
            else:
                pygame.quit()
                sys.exit()
        if (self.snake.body[-1][0] == self.food.x and
                self.snake.body[-1][1] == self.food.y):
            self.snake.grow()
            self.food.generate_new_food(self.board, self.snake)

    def draw_game_elements(self, screen):
        screen.fill((0, 0, 0))
        self.board.draw_grid(screen)
        for segment in self.snake.body:
            pygame.draw.rect(screen, (0, 255, 0), (segment[0], segment[1], 20, 20))
        pygame.draw.rect(screen, (255, 0, 0), (self.food.x, self.food.y, 20, 20))


def main():
    game = Game()
    game.run()


if __name__ == '__main__':
    main()

```
----- snake.py
```## snake.py
class Snake:
    def __init__(self):
        """
        Initialize the Snake object with default values.
        
        Attributes:
            body (list): A list of tuples representing the snake's body positions.
            direction (str): The current direction of the snake.
        """
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        """
        Move the snake one step in the current direction.
        
        Updates the snake's body positions based on the current direction.
        """
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        """
        Grow the snake by adding a new segment to its body.
        
        Appends a new segment at the end of the snake's body based on the current direction.
        """
        last_segment = self.body[-1]
        if self.direction == 'RIGHT':
            new_segment = (last_segment[0] + 20, last_segment[1])
        elif self.direction == 'LEFT':
            new_segment = (last_segment[0] - 20, last_segment[1])
        elif self.direction == 'UP':
            new_segment = (last_segment[0], last_segment[1] - 20)
        elif self.direction == 'DOWN':
            new_segment = (last_segment[0], last_segment[1] + 20)
        self.body.append(new_segment)

    def check_collision(self, board):
        """
        Check if the snake has collided with the board or itself.
        
        Args:
            board (Board): The game board object.
        
        Returns:
            bool: True if collision is detected, False otherwise.
        """
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False
```


## Code to be Reviewed: food.py
```Code
import random
from game import Board, Snake  # Import required classes


class Food:
    def __init__(self, x: int = 400, y: int = 300):
        """
        Initialize the Food object with default values.
        
        Attributes:
            x (int): The x-coordinate of the food on the game board. Defaults to 400.
            y (int): The y-coordinate of the food on the game board. Defaults to 300.
        """
        self.x = x
        self.y = y

    def generate_new_food(self, board: Board, snake: Snake):
        """
        Generate new food at a random position on the game board.
        
        Args:
            board (Board): The game board object.
            snake (Snake): The snake object.
        
        Returns:
            None
        """
        empty_spaces = [(x, y) for x in range(0, board.width, 20) 
                        for y in range(0, board.height, 20) 
                        if (x, y) not in snake.body]
        
        if empty_spaces:  # Check if there are any empty spaces
            self.x, self.y = random.choice(empty_spaces)
        else:
            print("No empty spaces on the board. Game Over.")
            # You could also add a game over condition here


```



# Format example 1
## Code Review: food.py
1. No, we should fix the logic of class A due to ...
2. ...
3. ...
4. No, function B is not implemented, ...
5. ...
6. ...

## Actions
1. Fix the `handle_events` method to update the game state only if a move is successful.
   ```python
   def handle_events(self):
       for event in pygame.event.get():
           if event.type == pygame.QUIT:
               return False
           if event.type == pygame.KEYDOWN:
               moved = False
               if event.key == pygame.K_UP:
                   moved = self.game.move('UP')
               elif event.key == pygame.K_DOWN:
                   moved = self.game.move('DOWN')
               elif event.key == pygame.K_LEFT:
                   moved = self.game.move('LEFT')
               elif event.key == pygame.K_RIGHT:
                   moved = self.game.move('RIGHT')
               if moved:
                   # Update the game state only if a move was successful
                   self.render()
       return True
   ```
2. Implement function B

## Code Review Result
LBTM

# Format example 2
## Code Review: food.py
1. Yes.
2. Yes.
3. Yes.
4. Yes.
5. Yes.
6. Yes.

## Actions
pass

## Code Review Result
LGTM



# Instruction: Based on the actual code situation, follow one of the "Format example". Return only 1 file under review.

## Code Review: Ordered List. Based on the "Code to be Reviewed", provide key, clear, concise, and specific answer. If any answer is no, explain how to fix it step by step.
1. Is the code implemented as per the requirements? If not, how to achieve it? Analyse it step by step.
2. Is the code logic completely correct? If there are errors, please indicate how to correct them.
3. Does the existing code follow the "Data structures and interfaces"?
4. Are all functions implemented? If there is no implementation, please indicate how to achieve it step by step.
5. Have all necessary pre-dependencies been imported? If not, indicate which ones need to be imported
6. Are methods from other files being reused correctly?

## Actions: Ordered List. Things that should be done after CR, such as implementing class A and function B

## Code Review Result: str. If the code doesn't have bugs, we don't need to rewrite it, so answer LGTM and stop. ONLY ANSWER LGTM/LBTM.
LGTM/LBTM






# System
Role: You are a professional software engineer, and your main task is to review and revise the code. You need to ensure that the code conforms to the google-style standards, is elegantly designed and modularized, easy to read and maintain.
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## System Design
{"Implementation approach":"We will utilize the Pygame library to create a snake game in Python. The game will feature a grid-based board with clear boundaries, smooth snake movement, and collision detection. We will implement a scoring system that increases when the snake eats food and a restart feature when the snake collides with the boundary or itself.","File list":["main.py","game.py","snake.py","food.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -board: Board\n        -snake: Snake\n        -food: Food\n        +__init__()\n        +run()\n        +handle_events()\n        +update_game_state()\n        +draw_game_elements()\n    }\n    class Board {\n        -width: int\n        -height: int\n        -grid_size: int\n        +__init__(width: int, height: int, grid_size: int)\n        +draw_grid()\n    }\n    class Snake {\n        -body: list\n        -direction: str\n        +__init__()\n        +move()\n        +grow()\n        +check_collision()\n    }\n    class Food {\n        -x: int\n        -y: int\n        +__init__(x: int, y: int)\n        +generate_new_food()\n    }\n    Game --> Board\n    Game --> Snake\n    Game --> Food\n","Program call flow":"\nsequenceDiagram\n    participant G as Game\n    participant B as Board\n    participant S as Snake\n    participant F as Food\n    G->>B: initialize_board(width, height, grid_size)\n    B-->>G: return board\n    G->>S: initialize_snake()\n    S-->>G: return snake\n    G->>F: generate_food()\n    F-->>G: return food\n    G->>G: run_game_loop()\n    G->>G: handle_events()\n    G->>S: update_snake_position()\n    S-->>G: return new_snake_position\n    G->>F: check_for_food_collision()\n    F-->>G: return food_collision_result\n    G->>G: update_game_state()\n    G->>B: draw_board()\n    B-->>G: return drawn_board\n    G->>S: draw_snake()\n    S-->>G: return drawn_snake\n    G->>F: draw_food()\n    F-->>G: return drawn_food\n","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Task
{"Required Python packages":["pygame"],"Required Other language third-party packages":["No third-party dependencies required"],"Logic Analysis":[["game.py","Contains Game class and run, handle_events, update_game_state, draw_game_elements functions"],["snake.py","Contains Snake class and move, grow, check_collision functions"],["food.py","Contains Food class and generate_new_food function"],["main.py","Contains main function, from game import Game"]],"Task list":["game.py","snake.py","food.py","main.py"],"Full API spec":"","Shared Knowledge":"`game.py` contains functions shared across the project. The grid size and snake movement speed need to be clarified.","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Code Files
----- game.py
```import pygame
import sys
import random

class Board:
    def __init__(self, width=800, height=600, grid_size=20):
        self.width = width
        self.height = height
        self.grid_size = grid_size

    def draw_grid(self, screen):
        for x in range(0, self.width, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (x, 0), (x, self.height))
        for y in range(0, self.height, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (0, y), (self.width, y))


class Snake:
    def __init__(self):
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        self.body.insert(0, self.body[0])

    def check_collision(self, board):
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False


class Food:
    def __init__(self, x=400, y=300):
        self.x = x
        self.y = y

    def generate_new_food(self, board, snake):
        while True:
            self.x = random.randint(0, board.width - 20) // 20 * 20
            self.y = random.randint(0, board.height - 20) // 20 * 20
            if (self.x, self.y) not in snake.body:
                break


class Game:
    def __init__(self):
        self.board = Board()
        self.snake = Snake()
        self.food = Food()

    def run(self):
        pygame.init()
        screen = pygame.display.set_mode((self.board.width, self.board.height))
        clock = pygame.time.Clock()
        while True:
            self.handle_events()
            self.update_game_state()
            self.draw_game_elements(screen)
            pygame.display.flip()
            clock.tick(10)

    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_UP and self.snake.direction != 'DOWN':
                    self.snake.direction = 'UP'
                elif event.key == pygame.K_DOWN and self.snake.direction != 'UP':
                    self.snake.direction = 'DOWN'
                elif event.key == pygame.K_LEFT and self.snake.direction != 'RIGHT':
                    self.snake.direction = 'LEFT'
                elif event.key == pygame.K_RIGHT and self.snake.direction != 'LEFT':
                    self.snake.direction = 'RIGHT'

    def update_game_state(self):
        self.snake.move()
        if self.snake.check_collision(self.board):
            print("Game Over! Final Score: ", len(self.snake.body))
            play_again = input("Play again? (yes/no): ")
            if play_again.lower() == "yes":
                self.__init__()
            else:
                pygame.quit()
                sys.exit()
        if (self.snake.body[-1][0] == self.food.x and
                self.snake.body[-1][1] == self.food.y):
            self.snake.grow()
            self.food.generate_new_food(self.board, self.snake)

    def draw_game_elements(self, screen):
        screen.fill((0, 0, 0))
        self.board.draw_grid(screen)
        for segment in self.snake.body:
            pygame.draw.rect(screen, (0, 255, 0), (segment[0], segment[1], 20, 20))
        pygame.draw.rect(screen, (255, 0, 0), (self.food.x, self.food.y, 20, 20))


def main():
    game = Game()
    game.run()


if __name__ == '__main__':
    main()

```
----- snake.py
```## snake.py
class Snake:
    def __init__(self):
        """
        Initialize the Snake object with default values.
        
        Attributes:
            body (list): A list of tuples representing the snake's body positions.
            direction (str): The current direction of the snake.
        """
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        """
        Move the snake one step in the current direction.
        
        Updates the snake's body positions based on the current direction.
        """
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        """
        Grow the snake by adding a new segment to its body.
        
        Appends a new segment at the end of the snake's body based on the current direction.
        """
        last_segment = self.body[-1]
        if self.direction == 'RIGHT':
            new_segment = (last_segment[0] + 20, last_segment[1])
        elif self.direction == 'LEFT':
            new_segment = (last_segment[0] - 20, last_segment[1])
        elif self.direction == 'UP':
            new_segment = (last_segment[0], last_segment[1] - 20)
        elif self.direction == 'DOWN':
            new_segment = (last_segment[0], last_segment[1] + 20)
        self.body.append(new_segment)

    def check_collision(self, board):
        """
        Check if the snake has collided with the board or itself.
        
        Args:
            board (Board): The game board object.
        
        Returns:
            bool: True if collision is detected, False otherwise.
        """
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False
```


## Code to be Reviewed: food.py
```Code
import random
from game import Board, Snake  # Import required classes


class Food:
    def __init__(self, x: int = 400, y: int = 300):
        """
        Initialize the Food object with default values.
        
        Attributes:
            x (int): The x-coordinate of the food on the game board. Defaults to 400.
            y (int): The y-coordinate of the food on the game board. Defaults to 300.
        """
        self.x = x
        self.y = y

    def generate_new_food(self, board: Board, snake: Snake):
        """
        Generate new food at a random position on the game board.
        
        Args:
            board (Board): The game board object.
            snake (Snake): The snake object.
        
        Returns:
            None
        """
        empty_spaces = [(x, y) for x in range(0, board.width, 20) 
                        for y in range(0, board.height, 20) 
                        if (x, y) not in snake.body]
        
        if empty_spaces:  # Check if there are any empty spaces
            self.x, self.y = random.choice(empty_spaces)
        else:
            print("No empty spaces on the board. Game Over.")
            # You could also add a game over condition here


```

## Code Review: food.py
1. Yes, the code is implemented as per the requirements. It correctly generates new food at a random position on the game board, avoiding positions occupied by the snake's body.
2. The code logic appears to be mostly correct. However, there's no validation for `board.width` and `board.height` being multiples of 20 (the grid size), which could lead to issues if they are not. Additionally, when there are no empty spaces left on the board, it simply prints a message but does not handle the game over condition properly.
3. Yes, the existing code follows the "Data structures and interfaces" as defined in the problem statement. It uses the `Board` and `Snake` classes as specified.
4. All necessary functions seem to be implemented. The `generate_new_food` method correctly updates the food's position.
5. Yes, all necessary pre-dependencies have been imported. The code imports `random` for generating random positions and `Board` and `Snake` from `game` for accessing game board and snake properties.
6. Methods from other files are being reused correctly. For example, it uses the `body` attribute of the `Snake` class to avoid placing food on the snake.

## Actions
1. Consider adding validation to ensure `board.width` and `board.height` are multiples of 20.
2. Implement a proper game over condition when there are no empty spaces left on the board, possibly by returning a specific value or raising an exception that can be caught and handled in the main game loop.

## Code Review Result
LBTM

# Instruction: rewrite code based on the Code Review and Actions
## Rewrite Code: CodeBlock. If it still has some bugs, rewrite food.py with triple quotes. Do your utmost to optimize THIS SINGLE FILE. Return all completed codes and prohibit the return of unfinished codes.
```Code
## food.py
...
```





NOTICE
Role: You are a professional engineer; the main goal is to write google-style, elegant, modular, easy to read and maintain code
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## Design
{"Implementation approach":"We will utilize the Pygame library to create a snake game in Python. The game will feature a grid-based board with clear boundaries, smooth snake movement, and collision detection. We will implement a scoring system that increases when the snake eats food and a restart feature when the snake collides with the boundary or itself.","File list":["main.py","game.py","snake.py","food.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -board: Board\n        -snake: Snake\n        -food: Food\n        +__init__()\n        +run()\n        +handle_events()\n        +update_game_state()\n        +draw_game_elements()\n    }\n    class Board {\n        -width: int\n        -height: int\n        -grid_size: int\n        +__init__(width: int, height: int, grid_size: int)\n        +draw_grid()\n    }\n    class Snake {\n        -body: list\n        -direction: str\n        +__init__()\n        +move()\n        +grow()\n        +check_collision()\n    }\n    class Food {\n        -x: int\n        -y: int\n        +__init__(x: int, y: int)\n        +generate_new_food()\n    }\n    Game --> Board\n    Game --> Snake\n    Game --> Food\n","Program call flow":"\nsequenceDiagram\n    participant G as Game\n    participant B as Board\n    participant S as Snake\n    participant F as Food\n    G->>B: initialize_board(width, height, grid_size)\n    B-->>G: return board\n    G->>S: initialize_snake()\n    S-->>G: return snake\n    G->>F: generate_food()\n    F-->>G: return food\n    G->>G: run_game_loop()\n    G->>G: handle_events()\n    G->>S: update_snake_position()\n    S-->>G: return new_snake_position\n    G->>F: check_for_food_collision()\n    F-->>G: return food_collision_result\n    G->>G: update_game_state()\n    G->>B: draw_board()\n    B-->>G: return drawn_board\n    G->>S: draw_snake()\n    S-->>G: return drawn_snake\n    G->>F: draw_food()\n    F-->>G: return drawn_food\n","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Task
{"Required Python packages":["pygame"],"Required Other language third-party packages":["No third-party dependencies required"],"Logic Analysis":[["game.py","Contains Game class and run, handle_events, update_game_state, draw_game_elements functions"],["snake.py","Contains Snake class and move, grow, check_collision functions"],["food.py","Contains Food class and generate_new_food function"],["main.py","Contains main function, from game import Game"]],"Task list":["game.py","snake.py","food.py","main.py"],"Full API spec":"","Shared Knowledge":"`game.py` contains functions shared across the project. The grid size and snake movement speed need to be clarified.","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Legacy Code
```Code
----- game.py
```import pygame
import sys
import random

class Board:
    def __init__(self, width=800, height=600, grid_size=20):
        self.width = width
        self.height = height
        self.grid_size = grid_size

    def draw_grid(self, screen):
        for x in range(0, self.width, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (x, 0), (x, self.height))
        for y in range(0, self.height, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (0, y), (self.width, y))


class Snake:
    def __init__(self):
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        self.body.insert(0, self.body[0])

    def check_collision(self, board):
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False


class Food:
    def __init__(self, x=400, y=300):
        self.x = x
        self.y = y

    def generate_new_food(self, board, snake):
        while True:
            self.x = random.randint(0, board.width - 20) // 20 * 20
            self.y = random.randint(0, board.height - 20) // 20 * 20
            if (self.x, self.y) not in snake.body:
                break


class Game:
    def __init__(self):
        self.board = Board()
        self.snake = Snake()
        self.food = Food()

    def run(self):
        pygame.init()
        screen = pygame.display.set_mode((self.board.width, self.board.height))
        clock = pygame.time.Clock()
        while True:
            self.handle_events()
            self.update_game_state()
            self.draw_game_elements(screen)
            pygame.display.flip()
            clock.tick(10)

    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_UP and self.snake.direction != 'DOWN':
                    self.snake.direction = 'UP'
                elif event.key == pygame.K_DOWN and self.snake.direction != 'UP':
                    self.snake.direction = 'DOWN'
                elif event.key == pygame.K_LEFT and self.snake.direction != 'RIGHT':
                    self.snake.direction = 'LEFT'
                elif event.key == pygame.K_RIGHT and self.snake.direction != 'LEFT':
                    self.snake.direction = 'RIGHT'

    def update_game_state(self):
        self.snake.move()
        if self.snake.check_collision(self.board):
            print("Game Over! Final Score: ", len(self.snake.body))
            play_again = input("Play again? (yes/no): ")
            if play_again.lower() == "yes":
                self.__init__()
            else:
                pygame.quit()
                sys.exit()
        if (self.snake.body[-1][0] == self.food.x and
                self.snake.body[-1][1] == self.food.y):
            self.snake.grow()
            self.food.generate_new_food(self.board, self.snake)

    def draw_game_elements(self, screen):
        screen.fill((0, 0, 0))
        self.board.draw_grid(screen)
        for segment in self.snake.body:
            pygame.draw.rect(screen, (0, 255, 0), (segment[0], segment[1], 20, 20))
        pygame.draw.rect(screen, (255, 0, 0), (self.food.x, self.food.y, 20, 20))


def main():
    game = Game()
    game.run()


if __name__ == '__main__':
    main()

```
----- snake.py
```## snake.py
class Snake:
    def __init__(self):
        """
        Initialize the Snake object with default values.
        
        Attributes:
            body (list): A list of tuples representing the snake's body positions.
            direction (str): The current direction of the snake.
        """
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        """
        Move the snake one step in the current direction.
        
        Updates the snake's body positions based on the current direction.
        """
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        """
        Grow the snake by adding a new segment to its body.
        
        Appends a new segment at the end of the snake's body based on the current direction.
        """
        last_segment = self.body[-1]
        if self.direction == 'RIGHT':
            new_segment = (last_segment[0] + 20, last_segment[1])
        elif self.direction == 'LEFT':
            new_segment = (last_segment[0] - 20, last_segment[1])
        elif self.direction == 'UP':
            new_segment = (last_segment[0], last_segment[1] - 20)
        elif self.direction == 'DOWN':
            new_segment = (last_segment[0], last_segment[1] + 20)
        self.body.append(new_segment)

    def check_collision(self, board):
        """
        Check if the snake has collided with the board or itself.
        
        Args:
            board (Board): The game board object.
        
        Returns:
            bool: True if collision is detected, False otherwise.
        """
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False
```
----- food.py
```import random
from game import Board, Snake

class Food:
    def __init__(self, x: int = 400, y: int = 300):
        """
        Initialize the Food object with default values.
        
        Attributes:
            x (int): The x-coordinate of the food on the game board. Defaults to 400.
            y (int): The y-coordinate of the food on the game board. Defaults to 300.
        """
        self.x = x
        self.y = y

    def generate_new_food(self, board: Board, snake: Snake):
        """
        Generate new food at a random position on the game board.
        
        Args:
            board (Board): The game board object.
            snake (Snake): The snake object.
        
        Returns:
            None
        """
        # Check if board dimensions are valid (multiples of 20)
        if board.width % 20 != 0 or board.height % 20 != 0:
            raise ValueError("Board width and height must be multiples of 20.")
        
        # Generate a list of all possible positions on the board
        possible_positions = [(x, y) for x in range(0, board.width, 20) 
                             for y in range(0, board.height, 20)]
        
        # Filter out positions that are part of the snake's body
        valid_positions = [pos for pos in possible_positions if pos not in snake.body]
        
        # If there are no valid positions, handle game over condition
        if not valid_positions:
            raise Exception("No empty spaces on the board. Game Over.")
        
        # Randomly select a position from the valid ones
        self.x, self.y = random.choice(valid_positions)
```
```

## Debug logs
```text



```

## Bug Feedback logs
```text

```

# Format example
## Code: main.py
```python
## main.py
...
```

# Instruction: Based on the context, follow "Format example", write code.

## Code: main.py. Write code with triple quoto, based on the following attentions and context.
1. Only One file: do your best to implement THIS ONLY ONE FILE.
2. COMPLETE CODE: Your code will be part of the entire project, so please implement complete, reliable, reusable code snippets.
3. Set default value: If there is any setting, ALWAYS SET A DEFAULT VALUE, ALWAYS USE STRONG TYPE AND EXPLICIT VARIABLE. AVOID circular import.
4. Follow design: YOU MUST FOLLOW "Data structures and interfaces". DONT CHANGE ANY DESIGN. Do not use public member functions that do not exist in your design.
5. CAREFULLY CHECK THAT YOU DONT MISS ANY NECESSARY CLASS/FUNCTION IN THIS FILE.
6. Before using a external variable/module, make sure you import it first.
7. Write out EVERY CODE DETAIL, DON'T LEAVE TODO.






# System
Role: You are a professional software engineer, and your main task is to review and revise the code. You need to ensure that the code conforms to the google-style standards, is elegantly designed and modularized, easy to read and maintain.
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## System Design
{"Implementation approach":"We will utilize the Pygame library to create a snake game in Python. The game will feature a grid-based board with clear boundaries, smooth snake movement, and collision detection. We will implement a scoring system that increases when the snake eats food and a restart feature when the snake collides with the boundary or itself.","File list":["main.py","game.py","snake.py","food.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -board: Board\n        -snake: Snake\n        -food: Food\n        +__init__()\n        +run()\n        +handle_events()\n        +update_game_state()\n        +draw_game_elements()\n    }\n    class Board {\n        -width: int\n        -height: int\n        -grid_size: int\n        +__init__(width: int, height: int, grid_size: int)\n        +draw_grid()\n    }\n    class Snake {\n        -body: list\n        -direction: str\n        +__init__()\n        +move()\n        +grow()\n        +check_collision()\n    }\n    class Food {\n        -x: int\n        -y: int\n        +__init__(x: int, y: int)\n        +generate_new_food()\n    }\n    Game --> Board\n    Game --> Snake\n    Game --> Food\n","Program call flow":"\nsequenceDiagram\n    participant G as Game\n    participant B as Board\n    participant S as Snake\n    participant F as Food\n    G->>B: initialize_board(width, height, grid_size)\n    B-->>G: return board\n    G->>S: initialize_snake()\n    S-->>G: return snake\n    G->>F: generate_food()\n    F-->>G: return food\n    G->>G: run_game_loop()\n    G->>G: handle_events()\n    G->>S: update_snake_position()\n    S-->>G: return new_snake_position\n    G->>F: check_for_food_collision()\n    F-->>G: return food_collision_result\n    G->>G: update_game_state()\n    G->>B: draw_board()\n    B-->>G: return drawn_board\n    G->>S: draw_snake()\n    S-->>G: return drawn_snake\n    G->>F: draw_food()\n    F-->>G: return drawn_food\n","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Task
{"Required Python packages":["pygame"],"Required Other language third-party packages":["No third-party dependencies required"],"Logic Analysis":[["game.py","Contains Game class and run, handle_events, update_game_state, draw_game_elements functions"],["snake.py","Contains Snake class and move, grow, check_collision functions"],["food.py","Contains Food class and generate_new_food function"],["main.py","Contains main function, from game import Game"]],"Task list":["game.py","snake.py","food.py","main.py"],"Full API spec":"","Shared Knowledge":"`game.py` contains functions shared across the project. The grid size and snake movement speed need to be clarified.","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Code Files
----- game.py
```import pygame
import sys
import random

class Board:
    def __init__(self, width=800, height=600, grid_size=20):
        self.width = width
        self.height = height
        self.grid_size = grid_size

    def draw_grid(self, screen):
        for x in range(0, self.width, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (x, 0), (x, self.height))
        for y in range(0, self.height, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (0, y), (self.width, y))


class Snake:
    def __init__(self):
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        self.body.insert(0, self.body[0])

    def check_collision(self, board):
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False


class Food:
    def __init__(self, x=400, y=300):
        self.x = x
        self.y = y

    def generate_new_food(self, board, snake):
        while True:
            self.x = random.randint(0, board.width - 20) // 20 * 20
            self.y = random.randint(0, board.height - 20) // 20 * 20
            if (self.x, self.y) not in snake.body:
                break


class Game:
    def __init__(self):
        self.board = Board()
        self.snake = Snake()
        self.food = Food()

    def run(self):
        pygame.init()
        screen = pygame.display.set_mode((self.board.width, self.board.height))
        clock = pygame.time.Clock()
        while True:
            self.handle_events()
            self.update_game_state()
            self.draw_game_elements(screen)
            pygame.display.flip()
            clock.tick(10)

    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_UP and self.snake.direction != 'DOWN':
                    self.snake.direction = 'UP'
                elif event.key == pygame.K_DOWN and self.snake.direction != 'UP':
                    self.snake.direction = 'DOWN'
                elif event.key == pygame.K_LEFT and self.snake.direction != 'RIGHT':
                    self.snake.direction = 'LEFT'
                elif event.key == pygame.K_RIGHT and self.snake.direction != 'LEFT':
                    self.snake.direction = 'RIGHT'

    def update_game_state(self):
        self.snake.move()
        if self.snake.check_collision(self.board):
            print("Game Over! Final Score: ", len(self.snake.body))
            play_again = input("Play again? (yes/no): ")
            if play_again.lower() == "yes":
                self.__init__()
            else:
                pygame.quit()
                sys.exit()
        if (self.snake.body[-1][0] == self.food.x and
                self.snake.body[-1][1] == self.food.y):
            self.snake.grow()
            self.food.generate_new_food(self.board, self.snake)

    def draw_game_elements(self, screen):
        screen.fill((0, 0, 0))
        self.board.draw_grid(screen)
        for segment in self.snake.body:
            pygame.draw.rect(screen, (0, 255, 0), (segment[0], segment[1], 20, 20))
        pygame.draw.rect(screen, (255, 0, 0), (self.food.x, self.food.y, 20, 20))


def main():
    game = Game()
    game.run()


if __name__ == '__main__':
    main()

```
----- snake.py
```## snake.py
class Snake:
    def __init__(self):
        """
        Initialize the Snake object with default values.
        
        Attributes:
            body (list): A list of tuples representing the snake's body positions.
            direction (str): The current direction of the snake.
        """
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        """
        Move the snake one step in the current direction.
        
        Updates the snake's body positions based on the current direction.
        """
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        """
        Grow the snake by adding a new segment to its body.
        
        Appends a new segment at the end of the snake's body based on the current direction.
        """
        last_segment = self.body[-1]
        if self.direction == 'RIGHT':
            new_segment = (last_segment[0] + 20, last_segment[1])
        elif self.direction == 'LEFT':
            new_segment = (last_segment[0] - 20, last_segment[1])
        elif self.direction == 'UP':
            new_segment = (last_segment[0], last_segment[1] - 20)
        elif self.direction == 'DOWN':
            new_segment = (last_segment[0], last_segment[1] + 20)
        self.body.append(new_segment)

    def check_collision(self, board):
        """
        Check if the snake has collided with the board or itself.
        
        Args:
            board (Board): The game board object.
        
        Returns:
            bool: True if collision is detected, False otherwise.
        """
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False
```
----- food.py
```import random
from game import Board, Snake

class Food:
    def __init__(self, x: int = 400, y: int = 300):
        """
        Initialize the Food object with default values.
        
        Attributes:
            x (int): The x-coordinate of the food on the game board. Defaults to 400.
            y (int): The y-coordinate of the food on the game board. Defaults to 300.
        """
        self.x = x
        self.y = y

    def generate_new_food(self, board: Board, snake: Snake):
        """
        Generate new food at a random position on the game board.
        
        Args:
            board (Board): The game board object.
            snake (Snake): The snake object.
        
        Returns:
            None
        """
        # Check if board dimensions are valid (multiples of 20)
        if board.width % 20 != 0 or board.height % 20 != 0:
            raise ValueError("Board width and height must be multiples of 20.")
        
        # Generate a list of all possible positions on the board
        possible_positions = [(x, y) for x in range(0, board.width, 20) 
                             for y in range(0, board.height, 20)]
        
        # Filter out positions that are part of the snake's body
        valid_positions = [pos for pos in possible_positions if pos not in snake.body]
        
        # If there are no valid positions, handle game over condition
        if not valid_positions:
            raise Exception("No empty spaces on the board. Game Over.")
        
        # Randomly select a position from the valid ones
        self.x, self.y = random.choice(valid_positions)
```


## Code to be Reviewed: main.py
```Code
import pygame
import sys
import random

class Board:
    def __init__(self, width: int = 800, height: int = 600, grid_size: int = 20):
        """
        Initialize the Board object with default values.
        
        Attributes:
            width (int): The width of the game board. Defaults to 800.
            height (int): The height of the game board. Defaults to 600.
            grid_size (int): The size of each grid cell on the board. Defaults to 20.
        """
        self.width = width
        self.height = height
        self.grid_size = grid_size

    def draw_grid(self, screen):
        """
        Draw the grid lines on the game board.
        
        Args:
            screen: The Pygame screen object.
        """
        for x in range(0, self.width, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (x, 0), (x, self.height))
        for y in range(0, self.height, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (0, y), (self.width, y))


class Snake:
    def __init__(self):
        """
        Initialize the Snake object with default values.
        
        Attributes:
            body (list): A list of tuples representing the snake's body positions.
            direction (str): The current direction of the snake.
        """
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        """
        Move the snake one step in the current direction.
        
        Updates the snake's body positions based on the current direction.
        """
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        """
        Grow the snake by adding a new segment to its body.
        
        Appends a new segment at the end of the snake's body based on the current direction.
        """
        last_segment = self.body[-1]
        if self.direction == 'RIGHT':
            new_segment = (last_segment[0] + 20, last_segment[1])
        elif self.direction == 'LEFT':
            new_segment = (last_segment[0] - 20, last_segment[1])
        elif self.direction == 'UP':
            new_segment = (last_segment[0], last_segment[1] - 20)
        elif self.direction == 'DOWN':
            new_segment = (last_segment[0], last_segment[1] + 20)
        self.body.append(new_segment)

    def check_collision(self, board):
        """
        Check if the snake has collided with the board or itself.
        
        Args:
            board (Board): The game board object.
        
        Returns:
            bool: True if collision is detected, False otherwise.
        """
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False


class Food:
    def __init__(self, x: int = 400, y: int = 300):
        """
        Initialize the Food object with default values.
        
        Attributes:
            x (int): The x-coordinate of the food on the game board. Defaults to 400.
            y (int): The y-coordinate of the food on the game board. Defaults to 300.
        """
        self.x = x
        self.y = y

    def generate_new_food(self, board: Board, snake: Snake):
        """
        Generate new food at a random position on the game board.
        
        Args:
            board (Board): The game board object.
            snake (Snake): The snake object.
        
        Returns:
            None
        """
        # Check if board dimensions are valid (multiples of 20)
        if board.width % 20 != 0 or board.height % 20 != 0:
            raise ValueError("Board width and height must be multiples of 20.")
        
        # Generate a list of all possible positions on the board
        possible_positions = [(x, y) for x in range(0, board.width, 20) 
                             for y in range(0, board.height, 20)]
        
        # Filter out positions that are part of the snake's body
        valid_positions = [pos for pos in possible_positions if pos not in snake.body]
        
        # If there are no valid positions, handle game over condition
        if not valid_positions:
            raise Exception("No empty spaces on the board. Game Over.")
        
        # Randomly select a position from the valid ones
        self.x, self.y = random.choice(valid_positions)


class Game:
    def __init__(self):
        """
        Initialize the Game object with default values.
        """
        pygame.init()
        self.board = Board()
        self.snake = Snake()
        self.food = Food()
        self.screen = pygame.display.set_mode((self.board.width, self.board.height))
        self.clock = pygame.time.Clock()

    def run(self):
        """
        Run the game loop.
        
        Returns:
            None
        """
        while True:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_UP and self.snake.direction != 'DOWN':
                        self.snake.direction = 'UP'
                    elif event.key == pygame.K_DOWN and self.snake.direction != 'UP':
                        self.snake.direction = 'DOWN'
                    elif event.key == pygame.K_LEFT and self.snake.direction != 'RIGHT':
                        self.snake.direction = 'LEFT'
                    elif event.key == pygame.K_RIGHT and self.snake.direction != 'LEFT':
                        self.snake.direction = 'RIGHT'

            self.snake.move()
            if self.snake.check_collision(self.board):
                print("Game Over")
                break

            if (self.snake.body[-1][0] == self.food.x and 
                    self.snake.body[-1][1] == self.food.y):
                self.snake.grow()
                self.food.generate_new_food(self.board, self.snake)

            self.screen.fill((0, 0, 0))
            self.board.draw_grid(self.screen)
            for pos in self.snake.body:
                pygame.draw.rect(self.screen, (0, 255, 0), (pos[0], pos[1], 20, 20))
            pygame.draw.rect(self.screen, (255, 0, 0), (self.food.x, self.food.y, 20, 20))
            pygame.display.update()
            self.clock.tick(10)


if __name__ == "__main__":
    game = Game()
    game.run()

```



# Format example 1
## Code Review: main.py
1. No, we should fix the logic of class A due to ...
2. ...
3. ...
4. No, function B is not implemented, ...
5. ...
6. ...

## Actions
1. Fix the `handle_events` method to update the game state only if a move is successful.
   ```python
   def handle_events(self):
       for event in pygame.event.get():
           if event.type == pygame.QUIT:
               return False
           if event.type == pygame.KEYDOWN:
               moved = False
               if event.key == pygame.K_UP:
                   moved = self.game.move('UP')
               elif event.key == pygame.K_DOWN:
                   moved = self.game.move('DOWN')
               elif event.key == pygame.K_LEFT:
                   moved = self.game.move('LEFT')
               elif event.key == pygame.K_RIGHT:
                   moved = self.game.move('RIGHT')
               if moved:
                   # Update the game state only if a move was successful
                   self.render()
       return True
   ```
2. Implement function B

## Code Review Result
LBTM

# Format example 2
## Code Review: main.py
1. Yes.
2. Yes.
3. Yes.
4. Yes.
5. Yes.
6. Yes.

## Actions
pass

## Code Review Result
LGTM



# Instruction: Based on the actual code situation, follow one of the "Format example". Return only 1 file under review.

## Code Review: Ordered List. Based on the "Code to be Reviewed", provide key, clear, concise, and specific answer. If any answer is no, explain how to fix it step by step.
1. Is the code implemented as per the requirements? If not, how to achieve it? Analyse it step by step.
2. Is the code logic completely correct? If there are errors, please indicate how to correct them.
3. Does the existing code follow the "Data structures and interfaces"?
4. Are all functions implemented? If there is no implementation, please indicate how to achieve it step by step.
5. Have all necessary pre-dependencies been imported? If not, indicate which ones need to be imported
6. Are methods from other files being reused correctly?

## Actions: Ordered List. Things that should be done after CR, such as implementing class A and function B

## Code Review Result: str. If the code doesn't have bugs, we don't need to rewrite it, so answer LGTM and stop. ONLY ANSWER LGTM/LBTM.
LGTM/LBTM






# System
Role: You are a professional software engineer, and your main task is to review and revise the code. You need to ensure that the code conforms to the google-style standards, is elegantly designed and modularized, easy to read and maintain.
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## System Design
{"Implementation approach":"We will utilize the Pygame library to create a snake game in Python. The game will feature a grid-based board with clear boundaries, smooth snake movement, and collision detection. We will implement a scoring system that increases when the snake eats food and a restart feature when the snake collides with the boundary or itself.","File list":["main.py","game.py","snake.py","food.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -board: Board\n        -snake: Snake\n        -food: Food\n        +__init__()\n        +run()\n        +handle_events()\n        +update_game_state()\n        +draw_game_elements()\n    }\n    class Board {\n        -width: int\n        -height: int\n        -grid_size: int\n        +__init__(width: int, height: int, grid_size: int)\n        +draw_grid()\n    }\n    class Snake {\n        -body: list\n        -direction: str\n        +__init__()\n        +move()\n        +grow()\n        +check_collision()\n    }\n    class Food {\n        -x: int\n        -y: int\n        +__init__(x: int, y: int)\n        +generate_new_food()\n    }\n    Game --> Board\n    Game --> Snake\n    Game --> Food\n","Program call flow":"\nsequenceDiagram\n    participant G as Game\n    participant B as Board\n    participant S as Snake\n    participant F as Food\n    G->>B: initialize_board(width, height, grid_size)\n    B-->>G: return board\n    G->>S: initialize_snake()\n    S-->>G: return snake\n    G->>F: generate_food()\n    F-->>G: return food\n    G->>G: run_game_loop()\n    G->>G: handle_events()\n    G->>S: update_snake_position()\n    S-->>G: return new_snake_position\n    G->>F: check_for_food_collision()\n    F-->>G: return food_collision_result\n    G->>G: update_game_state()\n    G->>B: draw_board()\n    B-->>G: return drawn_board\n    G->>S: draw_snake()\n    S-->>G: return drawn_snake\n    G->>F: draw_food()\n    F-->>G: return drawn_food\n","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Task
{"Required Python packages":["pygame"],"Required Other language third-party packages":["No third-party dependencies required"],"Logic Analysis":[["game.py","Contains Game class and run, handle_events, update_game_state, draw_game_elements functions"],["snake.py","Contains Snake class and move, grow, check_collision functions"],["food.py","Contains Food class and generate_new_food function"],["main.py","Contains main function, from game import Game"]],"Task list":["game.py","snake.py","food.py","main.py"],"Full API spec":"","Shared Knowledge":"`game.py` contains functions shared across the project. The grid size and snake movement speed need to be clarified.","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Code Files
----- game.py
```import pygame
import sys
import random

class Board:
    def __init__(self, width=800, height=600, grid_size=20):
        self.width = width
        self.height = height
        self.grid_size = grid_size

    def draw_grid(self, screen):
        for x in range(0, self.width, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (x, 0), (x, self.height))
        for y in range(0, self.height, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (0, y), (self.width, y))


class Snake:
    def __init__(self):
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        self.body.insert(0, self.body[0])

    def check_collision(self, board):
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False


class Food:
    def __init__(self, x=400, y=300):
        self.x = x
        self.y = y

    def generate_new_food(self, board, snake):
        while True:
            self.x = random.randint(0, board.width - 20) // 20 * 20
            self.y = random.randint(0, board.height - 20) // 20 * 20
            if (self.x, self.y) not in snake.body:
                break


class Game:
    def __init__(self):
        self.board = Board()
        self.snake = Snake()
        self.food = Food()

    def run(self):
        pygame.init()
        screen = pygame.display.set_mode((self.board.width, self.board.height))
        clock = pygame.time.Clock()
        while True:
            self.handle_events()
            self.update_game_state()
            self.draw_game_elements(screen)
            pygame.display.flip()
            clock.tick(10)

    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_UP and self.snake.direction != 'DOWN':
                    self.snake.direction = 'UP'
                elif event.key == pygame.K_DOWN and self.snake.direction != 'UP':
                    self.snake.direction = 'DOWN'
                elif event.key == pygame.K_LEFT and self.snake.direction != 'RIGHT':
                    self.snake.direction = 'LEFT'
                elif event.key == pygame.K_RIGHT and self.snake.direction != 'LEFT':
                    self.snake.direction = 'RIGHT'

    def update_game_state(self):
        self.snake.move()
        if self.snake.check_collision(self.board):
            print("Game Over! Final Score: ", len(self.snake.body))
            play_again = input("Play again? (yes/no): ")
            if play_again.lower() == "yes":
                self.__init__()
            else:
                pygame.quit()
                sys.exit()
        if (self.snake.body[-1][0] == self.food.x and
                self.snake.body[-1][1] == self.food.y):
            self.snake.grow()
            self.food.generate_new_food(self.board, self.snake)

    def draw_game_elements(self, screen):
        screen.fill((0, 0, 0))
        self.board.draw_grid(screen)
        for segment in self.snake.body:
            pygame.draw.rect(screen, (0, 255, 0), (segment[0], segment[1], 20, 20))
        pygame.draw.rect(screen, (255, 0, 0), (self.food.x, self.food.y, 20, 20))


def main():
    game = Game()
    game.run()


if __name__ == '__main__':
    main()

```
----- snake.py
```## snake.py
class Snake:
    def __init__(self):
        """
        Initialize the Snake object with default values.
        
        Attributes:
            body (list): A list of tuples representing the snake's body positions.
            direction (str): The current direction of the snake.
        """
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        """
        Move the snake one step in the current direction.
        
        Updates the snake's body positions based on the current direction.
        """
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        """
        Grow the snake by adding a new segment to its body.
        
        Appends a new segment at the end of the snake's body based on the current direction.
        """
        last_segment = self.body[-1]
        if self.direction == 'RIGHT':
            new_segment = (last_segment[0] + 20, last_segment[1])
        elif self.direction == 'LEFT':
            new_segment = (last_segment[0] - 20, last_segment[1])
        elif self.direction == 'UP':
            new_segment = (last_segment[0], last_segment[1] - 20)
        elif self.direction == 'DOWN':
            new_segment = (last_segment[0], last_segment[1] + 20)
        self.body.append(new_segment)

    def check_collision(self, board):
        """
        Check if the snake has collided with the board or itself.
        
        Args:
            board (Board): The game board object.
        
        Returns:
            bool: True if collision is detected, False otherwise.
        """
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False
```
----- food.py
```import random
from game import Board, Snake

class Food:
    def __init__(self, x: int = 400, y: int = 300):
        """
        Initialize the Food object with default values.
        
        Attributes:
            x (int): The x-coordinate of the food on the game board. Defaults to 400.
            y (int): The y-coordinate of the food on the game board. Defaults to 300.
        """
        self.x = x
        self.y = y

    def generate_new_food(self, board: Board, snake: Snake):
        """
        Generate new food at a random position on the game board.
        
        Args:
            board (Board): The game board object.
            snake (Snake): The snake object.
        
        Returns:
            None
        """
        # Check if board dimensions are valid (multiples of 20)
        if board.width % 20 != 0 or board.height % 20 != 0:
            raise ValueError("Board width and height must be multiples of 20.")
        
        # Generate a list of all possible positions on the board
        possible_positions = [(x, y) for x in range(0, board.width, 20) 
                             for y in range(0, board.height, 20)]
        
        # Filter out positions that are part of the snake's body
        valid_positions = [pos for pos in possible_positions if pos not in snake.body]
        
        # If there are no valid positions, handle game over condition
        if not valid_positions:
            raise Exception("No empty spaces on the board. Game Over.")
        
        # Randomly select a position from the valid ones
        self.x, self.y = random.choice(valid_positions)
```


## Code to be Reviewed: main.py
```Code
import pygame
import sys
import random

class Board:
    def __init__(self, width: int = 800, height: int = 600, grid_size: int = 20):
        """
        Initialize the Board object with default values.
        
        Attributes:
            width (int): The width of the game board. Defaults to 800.
            height (int): The height of the game board. Defaults to 600.
            grid_size (int): The size of each grid cell on the board. Defaults to 20.
        """
        self.width = width
        self.height = height
        self.grid_size = grid_size

    def draw_grid(self, screen):
        """
        Draw the grid lines on the game board.
        
        Args:
            screen: The Pygame screen object.
        """
        for x in range(0, self.width, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (x, 0), (x, self.height))
        for y in range(0, self.height, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (0, y), (self.width, y))


class Snake:
    def __init__(self):
        """
        Initialize the Snake object with default values.
        
        Attributes:
            body (list): A list of tuples representing the snake's body positions.
            direction (str): The current direction of the snake.
        """
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        """
        Move the snake one step in the current direction.
        
        Updates the snake's body positions based on the current direction.
        """
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        """
        Grow the snake by adding a new segment to its body.
        
        Appends a new segment at the end of the snake's body based on the current direction.
        """
        last_segment = self.body[-1]
        if self.direction == 'RIGHT':
            new_segment = (last_segment[0] + 20, last_segment[1])
        elif self.direction == 'LEFT':
            new_segment = (last_segment[0] - 20, last_segment[1])
        elif self.direction == 'UP':
            new_segment = (last_segment[0], last_segment[1] - 20)
        elif self.direction == 'DOWN':
            new_segment = (last_segment[0], last_segment[1] + 20)
        self.body.append(new_segment)

    def check_collision(self, board):
        """
        Check if the snake has collided with the board or itself.
        
        Args:
            board (Board): The game board object.
        
        Returns:
            bool: True if collision is detected, False otherwise.
        """
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False


class Food:
    def __init__(self, x: int = 400, y: int = 300):
        """
        Initialize the Food object with default values.
        
        Attributes:
            x (int): The x-coordinate of the food on the game board. Defaults to 400.
            y (int): The y-coordinate of the food on the game board. Defaults to 300.
        """
        self.x = x
        self.y = y

    def generate_new_food(self, board: Board, snake: Snake):
        """
        Generate new food at a random position on the game board.
        
        Args:
            board (Board): The game board object.
            snake (Snake): The snake object.
        
        Returns:
            None
        """
        # Check if board dimensions are valid (multiples of 20)
        if board.width % 20 != 0 or board.height % 20 != 0:
            raise ValueError("Board width and height must be multiples of 20.")
        
        # Generate a list of all possible positions on the board
        possible_positions = [(x, y) for x in range(0, board.width, 20) 
                             for y in range(0, board.height, 20)]
        
        # Filter out positions that are part of the snake's body
        valid_positions = [pos for pos in possible_positions if pos not in snake.body]
        
        # If there are no valid positions, handle game over condition
        if not valid_positions:
            raise Exception("No empty spaces on the board. Game Over.")
        
        # Randomly select a position from the valid ones
        self.x, self.y = random.choice(valid_positions)


class Game:
    def __init__(self):
        """
        Initialize the Game object with default values.
        """
        pygame.init()
        self.board = Board()
        self.snake = Snake()
        self.food = Food()
        self.screen = pygame.display.set_mode((self.board.width, self.board.height))
        self.clock = pygame.time.Clock()

    def run(self):
        """
        Run the game loop.
        
        Returns:
            None
        """
        while True:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_UP and self.snake.direction != 'DOWN':
                        self.snake.direction = 'UP'
                    elif event.key == pygame.K_DOWN and self.snake.direction != 'UP':
                        self.snake.direction = 'DOWN'
                    elif event.key == pygame.K_LEFT and self.snake.direction != 'RIGHT':
                        self.snake.direction = 'LEFT'
                    elif event.key == pygame.K_RIGHT and self.snake.direction != 'LEFT':
                        self.snake.direction = 'RIGHT'

            self.snake.move()
            if self.snake.check_collision(self.board):
                print("Game Over")
                break

            if (self.snake.body[-1][0] == self.food.x and 
                    self.snake.body[-1][1] == self.food.y):
                self.snake.grow()
                self.food.generate_new_food(self.board, self.snake)

            self.screen.fill((0, 0, 0))
            self.board.draw_grid(self.screen)
            for pos in self.snake.body:
                pygame.draw.rect(self.screen, (0, 255, 0), (pos[0], pos[1], 20, 20))
            pygame.draw.rect(self.screen, (255, 0, 0), (self.food.x, self.food.y, 20, 20))
            pygame.display.update()
            self.clock.tick(10)


if __name__ == "__main__":
    game = Game()
    game.run()

```

## Code Review: main.py
1. No, the code is not fully implemented as per the requirements. The game loop does not handle the game over condition correctly. To achieve this, we need to add a game over screen and reset the game state when the user wants to play again.
   - Step 1: Create a game over screen that displays the final score and asks the user if they want to play again.
   - Step 2: Add a condition in the game loop to check if the game is over. If it is, display the game over screen.
   - Step 3: Reset the game state when the user chooses to play again.

2. No, there are errors in the code logic. The snake's movement is not validated correctly. To correct this, we need to add checks to ensure that the snake does not move back into itself.
   - Step 1: Add a check in the `move` method to prevent the snake from moving back into itself.
   - Step 2: Update the game loop to handle the new movement validation.

3. Yes, the existing code follows the "Data structures and interfaces" as defined in the problem statement.

4. No, not all functions are implemented. The `generate_new_food` method is missing. To achieve this, we need to implement a method that generates new food at a random position on the board.
   - Step 1: Create a new method called `generate_new_food` that takes the board and snake as parameters.
   - Step 2: In this method, generate a random position on the board that is not occupied by the snake.
   - Step 3: Update the food's position to the new generated position.

5. Yes, all necessary pre-dependencies have been imported.

6. Yes, methods from other files are being reused correctly.

## Actions:
1. Implement the game over screen and reset the game state when the user wants to play again.
2. Validate the snake's movement to prevent it from moving back into itself.
3. Implement the `generate_new_food` method.

## Code Review Result:
LBTM

# Instruction: rewrite code based on the Code Review and Actions
## Rewrite Code: CodeBlock. If it still has some bugs, rewrite main.py with triple quotes. Do your utmost to optimize THIS SINGLE FILE. Return all completed codes and prohibit the return of unfinished codes.
```Code
## main.py
...
```





# System
Role: You are a professional software engineer, and your main task is to review and revise the code. You need to ensure that the code conforms to the google-style standards, is elegantly designed and modularized, easy to read and maintain.
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## System Design
{"Implementation approach":"We will utilize the Pygame library to create a snake game in Python. The game will feature a grid-based board with clear boundaries, smooth snake movement, and collision detection. We will implement a scoring system that increases when the snake eats food and a restart feature when the snake collides with the boundary or itself.","File list":["main.py","game.py","snake.py","food.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -board: Board\n        -snake: Snake\n        -food: Food\n        +__init__()\n        +run()\n        +handle_events()\n        +update_game_state()\n        +draw_game_elements()\n    }\n    class Board {\n        -width: int\n        -height: int\n        -grid_size: int\n        +__init__(width: int, height: int, grid_size: int)\n        +draw_grid()\n    }\n    class Snake {\n        -body: list\n        -direction: str\n        +__init__()\n        +move()\n        +grow()\n        +check_collision()\n    }\n    class Food {\n        -x: int\n        -y: int\n        +__init__(x: int, y: int)\n        +generate_new_food()\n    }\n    Game --> Board\n    Game --> Snake\n    Game --> Food\n","Program call flow":"\nsequenceDiagram\n    participant G as Game\n    participant B as Board\n    participant S as Snake\n    participant F as Food\n    G->>B: initialize_board(width, height, grid_size)\n    B-->>G: return board\n    G->>S: initialize_snake()\n    S-->>G: return snake\n    G->>F: generate_food()\n    F-->>G: return food\n    G->>G: run_game_loop()\n    G->>G: handle_events()\n    G->>S: update_snake_position()\n    S-->>G: return new_snake_position\n    G->>F: check_for_food_collision()\n    F-->>G: return food_collision_result\n    G->>G: update_game_state()\n    G->>B: draw_board()\n    B-->>G: return drawn_board\n    G->>S: draw_snake()\n    S-->>G: return drawn_snake\n    G->>F: draw_food()\n    F-->>G: return drawn_food\n","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Task
{"Required Python packages":["pygame"],"Required Other language third-party packages":["No third-party dependencies required"],"Logic Analysis":[["game.py","Contains Game class and run, handle_events, update_game_state, draw_game_elements functions"],["snake.py","Contains Snake class and move, grow, check_collision functions"],["food.py","Contains Food class and generate_new_food function"],["main.py","Contains main function, from game import Game"]],"Task list":["game.py","snake.py","food.py","main.py"],"Full API spec":"","Shared Knowledge":"`game.py` contains functions shared across the project. The grid size and snake movement speed need to be clarified.","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Code Files
----- game.py
```import pygame
import sys
import random

class Board:
    def __init__(self, width=800, height=600, grid_size=20):
        self.width = width
        self.height = height
        self.grid_size = grid_size

    def draw_grid(self, screen):
        for x in range(0, self.width, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (x, 0), (x, self.height))
        for y in range(0, self.height, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (0, y), (self.width, y))


class Snake:
    def __init__(self):
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        self.body.insert(0, self.body[0])

    def check_collision(self, board):
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False


class Food:
    def __init__(self, x=400, y=300):
        self.x = x
        self.y = y

    def generate_new_food(self, board, snake):
        while True:
            self.x = random.randint(0, board.width - 20) // 20 * 20
            self.y = random.randint(0, board.height - 20) // 20 * 20
            if (self.x, self.y) not in snake.body:
                break


class Game:
    def __init__(self):
        self.board = Board()
        self.snake = Snake()
        self.food = Food()

    def run(self):
        pygame.init()
        screen = pygame.display.set_mode((self.board.width, self.board.height))
        clock = pygame.time.Clock()
        while True:
            self.handle_events()
            self.update_game_state()
            self.draw_game_elements(screen)
            pygame.display.flip()
            clock.tick(10)

    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_UP and self.snake.direction != 'DOWN':
                    self.snake.direction = 'UP'
                elif event.key == pygame.K_DOWN and self.snake.direction != 'UP':
                    self.snake.direction = 'DOWN'
                elif event.key == pygame.K_LEFT and self.snake.direction != 'RIGHT':
                    self.snake.direction = 'LEFT'
                elif event.key == pygame.K_RIGHT and self.snake.direction != 'LEFT':
                    self.snake.direction = 'RIGHT'

    def update_game_state(self):
        self.snake.move()
        if self.snake.check_collision(self.board):
            print("Game Over! Final Score: ", len(self.snake.body))
            play_again = input("Play again? (yes/no): ")
            if play_again.lower() == "yes":
                self.__init__()
            else:
                pygame.quit()
                sys.exit()
        if (self.snake.body[-1][0] == self.food.x and
                self.snake.body[-1][1] == self.food.y):
            self.snake.grow()
            self.food.generate_new_food(self.board, self.snake)

    def draw_game_elements(self, screen):
        screen.fill((0, 0, 0))
        self.board.draw_grid(screen)
        for segment in self.snake.body:
            pygame.draw.rect(screen, (0, 255, 0), (segment[0], segment[1], 20, 20))
        pygame.draw.rect(screen, (255, 0, 0), (self.food.x, self.food.y, 20, 20))


def main():
    game = Game()
    game.run()


if __name__ == '__main__':
    main()

```
----- snake.py
```## snake.py
class Snake:
    def __init__(self):
        """
        Initialize the Snake object with default values.
        
        Attributes:
            body (list): A list of tuples representing the snake's body positions.
            direction (str): The current direction of the snake.
        """
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        """
        Move the snake one step in the current direction.
        
        Updates the snake's body positions based on the current direction.
        """
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        """
        Grow the snake by adding a new segment to its body.
        
        Appends a new segment at the end of the snake's body based on the current direction.
        """
        last_segment = self.body[-1]
        if self.direction == 'RIGHT':
            new_segment = (last_segment[0] + 20, last_segment[1])
        elif self.direction == 'LEFT':
            new_segment = (last_segment[0] - 20, last_segment[1])
        elif self.direction == 'UP':
            new_segment = (last_segment[0], last_segment[1] - 20)
        elif self.direction == 'DOWN':
            new_segment = (last_segment[0], last_segment[1] + 20)
        self.body.append(new_segment)

    def check_collision(self, board):
        """
        Check if the snake has collided with the board or itself.
        
        Args:
            board (Board): The game board object.
        
        Returns:
            bool: True if collision is detected, False otherwise.
        """
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False
```
----- food.py
```import random
from game import Board, Snake

class Food:
    def __init__(self, x: int = 400, y: int = 300):
        """
        Initialize the Food object with default values.
        
        Attributes:
            x (int): The x-coordinate of the food on the game board. Defaults to 400.
            y (int): The y-coordinate of the food on the game board. Defaults to 300.
        """
        self.x = x
        self.y = y

    def generate_new_food(self, board: Board, snake: Snake):
        """
        Generate new food at a random position on the game board.
        
        Args:
            board (Board): The game board object.
            snake (Snake): The snake object.
        
        Returns:
            None
        """
        # Check if board dimensions are valid (multiples of 20)
        if board.width % 20 != 0 or board.height % 20 != 0:
            raise ValueError("Board width and height must be multiples of 20.")
        
        # Generate a list of all possible positions on the board
        possible_positions = [(x, y) for x in range(0, board.width, 20) 
                             for y in range(0, board.height, 20)]
        
        # Filter out positions that are part of the snake's body
        valid_positions = [pos for pos in possible_positions if pos not in snake.body]
        
        # If there are no valid positions, handle game over condition
        if not valid_positions:
            raise Exception("No empty spaces on the board. Game Over.")
        
        # Randomly select a position from the valid ones
        self.x, self.y = random.choice(valid_positions)
```


## Code to be Reviewed: main.py
```Code
import pygame
import random
import sys

# Initialize Pygame
pygame.init()

class Board:
    def __init__(self, width=800, height=600, grid_size=20):
        self.width = width
        self.height = height
        self.grid_size = grid_size

    def draw_grid(self, screen):
        for x in range(0, self.width, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (x, 0), (x, self.height))
        for y in range(0, self.height, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (0, y), (self.width, y))


class Snake:
    def __init__(self):
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        last_segment = self.body[-1]
        if self.direction == 'RIGHT':
            new_segment = (last_segment[0] + 20, last_segment[1])
        elif self.direction == 'LEFT':
            new_segment = (last_segment[0] - 20, last_segment[1])
        elif self.direction == 'UP':
            new_segment = (last_segment[0], last_segment[1] - 20)
        elif self.direction == 'DOWN':
            new_segment = (last_segment[0], last_segment[1] + 20)
        self.body.append(new_segment)

    def check_collision(self, board):
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False


class Food:
    def __init__(self, x=400, y=300):
        self.x = x
        self.y = y

    def generate_new_food(self, board, snake):
        possible_positions = [(x, y) for x in range(0, board.width, 20) 
                             for y in range(0, board.height, 20)]
        valid_positions = [pos for pos in possible_positions if pos not in snake.body]
        if not valid_positions:
            raise Exception("No empty spaces on the board. Game Over.")
        self.x, self.y = random.choice(valid_positions)


class Game:
    def __init__(self):
        self.board = Board()
        self.snake = Snake()
        self.food = Food()
        self.screen = pygame.display.set_mode((self.board.width, self.board.height))
        self.clock = pygame.time.Clock()

    def run(self):
        while True:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_UP and self.snake.direction != 'DOWN':
                        self.snake.direction = 'UP'
                    elif event.key == pygame.K_DOWN and self.snake.direction != 'UP':
                        self.snake.direction = 'DOWN'
                    elif event.key == pygame.K_LEFT and self.snake.direction != 'RIGHT':
                        self.snake.direction = 'LEFT'
                    elif event.key == pygame.K_RIGHT and self.snake.direction != 'LEFT':
                        self.snake.direction = 'RIGHT'

            self.snake.move()
            if self.snake.check_collision(self.board):
                print("Game Over")
                break

            if (self.snake.body[-1][0] == self.food.x and 
                    self.snake.body[-1][1] == self.food.y):
                self.snake.grow()
                self.food.generate_new_food(self.board, self.snake)

            self.screen.fill((0, 0, 0))
            self.board.draw_grid(self.screen)
            for pos in self.snake.body:
                pygame.draw.rect(self.screen, (0, 255, 0), (pos[0], pos[1], 20, 20))
            pygame.draw.rect(self.screen, (255, 0, 0), (self.food.x, self.food.y, 20, 20))
            pygame.display.update()
            self.clock.tick(10)


if __name__ == "__main__":
    game = Game()
    game.run()


```



# Format example 1
## Code Review: main.py
1. No, we should fix the logic of class A due to ...
2. ...
3. ...
4. No, function B is not implemented, ...
5. ...
6. ...

## Actions
1. Fix the `handle_events` method to update the game state only if a move is successful.
   ```python
   def handle_events(self):
       for event in pygame.event.get():
           if event.type == pygame.QUIT:
               return False
           if event.type == pygame.KEYDOWN:
               moved = False
               if event.key == pygame.K_UP:
                   moved = self.game.move('UP')
               elif event.key == pygame.K_DOWN:
                   moved = self.game.move('DOWN')
               elif event.key == pygame.K_LEFT:
                   moved = self.game.move('LEFT')
               elif event.key == pygame.K_RIGHT:
                   moved = self.game.move('RIGHT')
               if moved:
                   # Update the game state only if a move was successful
                   self.render()
       return True
   ```
2. Implement function B

## Code Review Result
LBTM

# Format example 2
## Code Review: main.py
1. Yes.
2. Yes.
3. Yes.
4. Yes.
5. Yes.
6. Yes.

## Actions
pass

## Code Review Result
LGTM



# Instruction: Based on the actual code situation, follow one of the "Format example". Return only 1 file under review.

## Code Review: Ordered List. Based on the "Code to be Reviewed", provide key, clear, concise, and specific answer. If any answer is no, explain how to fix it step by step.
1. Is the code implemented as per the requirements? If not, how to achieve it? Analyse it step by step.
2. Is the code logic completely correct? If there are errors, please indicate how to correct them.
3. Does the existing code follow the "Data structures and interfaces"?
4. Are all functions implemented? If there is no implementation, please indicate how to achieve it step by step.
5. Have all necessary pre-dependencies been imported? If not, indicate which ones need to be imported
6. Are methods from other files being reused correctly?

## Actions: Ordered List. Things that should be done after CR, such as implementing class A and function B

## Code Review Result: str. If the code doesn't have bugs, we don't need to rewrite it, so answer LGTM and stop. ONLY ANSWER LGTM/LBTM.
LGTM/LBTM






# System
Role: You are a professional software engineer, and your main task is to review and revise the code. You need to ensure that the code conforms to the google-style standards, is elegantly designed and modularized, easy to read and maintain.
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## System Design
{"Implementation approach":"We will utilize the Pygame library to create a snake game in Python. The game will feature a grid-based board with clear boundaries, smooth snake movement, and collision detection. We will implement a scoring system that increases when the snake eats food and a restart feature when the snake collides with the boundary or itself.","File list":["main.py","game.py","snake.py","food.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -board: Board\n        -snake: Snake\n        -food: Food\n        +__init__()\n        +run()\n        +handle_events()\n        +update_game_state()\n        +draw_game_elements()\n    }\n    class Board {\n        -width: int\n        -height: int\n        -grid_size: int\n        +__init__(width: int, height: int, grid_size: int)\n        +draw_grid()\n    }\n    class Snake {\n        -body: list\n        -direction: str\n        +__init__()\n        +move()\n        +grow()\n        +check_collision()\n    }\n    class Food {\n        -x: int\n        -y: int\n        +__init__(x: int, y: int)\n        +generate_new_food()\n    }\n    Game --> Board\n    Game --> Snake\n    Game --> Food\n","Program call flow":"\nsequenceDiagram\n    participant G as Game\n    participant B as Board\n    participant S as Snake\n    participant F as Food\n    G->>B: initialize_board(width, height, grid_size)\n    B-->>G: return board\n    G->>S: initialize_snake()\n    S-->>G: return snake\n    G->>F: generate_food()\n    F-->>G: return food\n    G->>G: run_game_loop()\n    G->>G: handle_events()\n    G->>S: update_snake_position()\n    S-->>G: return new_snake_position\n    G->>F: check_for_food_collision()\n    F-->>G: return food_collision_result\n    G->>G: update_game_state()\n    G->>B: draw_board()\n    B-->>G: return drawn_board\n    G->>S: draw_snake()\n    S-->>G: return drawn_snake\n    G->>F: draw_food()\n    F-->>G: return drawn_food\n","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Task
{"Required Python packages":["pygame"],"Required Other language third-party packages":["No third-party dependencies required"],"Logic Analysis":[["game.py","Contains Game class and run, handle_events, update_game_state, draw_game_elements functions"],["snake.py","Contains Snake class and move, grow, check_collision functions"],["food.py","Contains Food class and generate_new_food function"],["main.py","Contains main function, from game import Game"]],"Task list":["game.py","snake.py","food.py","main.py"],"Full API spec":"","Shared Knowledge":"`game.py` contains functions shared across the project. The grid size and snake movement speed need to be clarified.","Anything UNCLEAR":"Clarification needed on the exact grid size and snake movement speed."}

## Code Files
----- game.py
```import pygame
import sys
import random

class Board:
    def __init__(self, width=800, height=600, grid_size=20):
        self.width = width
        self.height = height
        self.grid_size = grid_size

    def draw_grid(self, screen):
        for x in range(0, self.width, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (x, 0), (x, self.height))
        for y in range(0, self.height, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (0, y), (self.width, y))


class Snake:
    def __init__(self):
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        self.body.insert(0, self.body[0])

    def check_collision(self, board):
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False


class Food:
    def __init__(self, x=400, y=300):
        self.x = x
        self.y = y

    def generate_new_food(self, board, snake):
        while True:
            self.x = random.randint(0, board.width - 20) // 20 * 20
            self.y = random.randint(0, board.height - 20) // 20 * 20
            if (self.x, self.y) not in snake.body:
                break


class Game:
    def __init__(self):
        self.board = Board()
        self.snake = Snake()
        self.food = Food()

    def run(self):
        pygame.init()
        screen = pygame.display.set_mode((self.board.width, self.board.height))
        clock = pygame.time.Clock()
        while True:
            self.handle_events()
            self.update_game_state()
            self.draw_game_elements(screen)
            pygame.display.flip()
            clock.tick(10)

    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_UP and self.snake.direction != 'DOWN':
                    self.snake.direction = 'UP'
                elif event.key == pygame.K_DOWN and self.snake.direction != 'UP':
                    self.snake.direction = 'DOWN'
                elif event.key == pygame.K_LEFT and self.snake.direction != 'RIGHT':
                    self.snake.direction = 'LEFT'
                elif event.key == pygame.K_RIGHT and self.snake.direction != 'LEFT':
                    self.snake.direction = 'RIGHT'

    def update_game_state(self):
        self.snake.move()
        if self.snake.check_collision(self.board):
            print("Game Over! Final Score: ", len(self.snake.body))
            play_again = input("Play again? (yes/no): ")
            if play_again.lower() == "yes":
                self.__init__()
            else:
                pygame.quit()
                sys.exit()
        if (self.snake.body[-1][0] == self.food.x and
                self.snake.body[-1][1] == self.food.y):
            self.snake.grow()
            self.food.generate_new_food(self.board, self.snake)

    def draw_game_elements(self, screen):
        screen.fill((0, 0, 0))
        self.board.draw_grid(screen)
        for segment in self.snake.body:
            pygame.draw.rect(screen, (0, 255, 0), (segment[0], segment[1], 20, 20))
        pygame.draw.rect(screen, (255, 0, 0), (self.food.x, self.food.y, 20, 20))


def main():
    game = Game()
    game.run()


if __name__ == '__main__':
    main()

```
----- snake.py
```## snake.py
class Snake:
    def __init__(self):
        """
        Initialize the Snake object with default values.
        
        Attributes:
            body (list): A list of tuples representing the snake's body positions.
            direction (str): The current direction of the snake.
        """
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        """
        Move the snake one step in the current direction.
        
        Updates the snake's body positions based on the current direction.
        """
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        """
        Grow the snake by adding a new segment to its body.
        
        Appends a new segment at the end of the snake's body based on the current direction.
        """
        last_segment = self.body[-1]
        if self.direction == 'RIGHT':
            new_segment = (last_segment[0] + 20, last_segment[1])
        elif self.direction == 'LEFT':
            new_segment = (last_segment[0] - 20, last_segment[1])
        elif self.direction == 'UP':
            new_segment = (last_segment[0], last_segment[1] - 20)
        elif self.direction == 'DOWN':
            new_segment = (last_segment[0], last_segment[1] + 20)
        self.body.append(new_segment)

    def check_collision(self, board):
        """
        Check if the snake has collided with the board or itself.
        
        Args:
            board (Board): The game board object.
        
        Returns:
            bool: True if collision is detected, False otherwise.
        """
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False
```
----- food.py
```import random
from game import Board, Snake

class Food:
    def __init__(self, x: int = 400, y: int = 300):
        """
        Initialize the Food object with default values.
        
        Attributes:
            x (int): The x-coordinate of the food on the game board. Defaults to 400.
            y (int): The y-coordinate of the food on the game board. Defaults to 300.
        """
        self.x = x
        self.y = y

    def generate_new_food(self, board: Board, snake: Snake):
        """
        Generate new food at a random position on the game board.
        
        Args:
            board (Board): The game board object.
            snake (Snake): The snake object.
        
        Returns:
            None
        """
        # Check if board dimensions are valid (multiples of 20)
        if board.width % 20 != 0 or board.height % 20 != 0:
            raise ValueError("Board width and height must be multiples of 20.")
        
        # Generate a list of all possible positions on the board
        possible_positions = [(x, y) for x in range(0, board.width, 20) 
                             for y in range(0, board.height, 20)]
        
        # Filter out positions that are part of the snake's body
        valid_positions = [pos for pos in possible_positions if pos not in snake.body]
        
        # If there are no valid positions, handle game over condition
        if not valid_positions:
            raise Exception("No empty spaces on the board. Game Over.")
        
        # Randomly select a position from the valid ones
        self.x, self.y = random.choice(valid_positions)
```


## Code to be Reviewed: main.py
```Code
import pygame
import random
import sys

# Initialize Pygame
pygame.init()

class Board:
    def __init__(self, width=800, height=600, grid_size=20):
        self.width = width
        self.height = height
        self.grid_size = grid_size

    def draw_grid(self, screen):
        for x in range(0, self.width, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (x, 0), (x, self.height))
        for y in range(0, self.height, self.grid_size):
            pygame.draw.line(screen, (200, 200, 200), (0, y), (self.width, y))


class Snake:
    def __init__(self):
        self.body = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'

    def move(self):
        head = self.body[-1]
        if self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        self.body.append(new_head)
        self.body.pop(0)

    def grow(self):
        last_segment = self.body[-1]
        if self.direction == 'RIGHT':
            new_segment = (last_segment[0] + 20, last_segment[1])
        elif self.direction == 'LEFT':
            new_segment = (last_segment[0] - 20, last_segment[1])
        elif self.direction == 'UP':
            new_segment = (last_segment[0], last_segment[1] - 20)
        elif self.direction == 'DOWN':
            new_segment = (last_segment[0], last_segment[1] + 20)
        self.body.append(new_segment)

    def check_collision(self, board):
        head = self.body[-1]
        if (head[0] < 0 or head[0] >= board.width or
                head[1] < 0 or head[1] >= board.height):
            return True
        for segment in self.body[:-1]:
            if segment == head:
                return True
        return False


class Food:
    def __init__(self, x=400, y=300):
        self.x = x
        self.y = y

    def generate_new_food(self, board, snake):
        possible_positions = [(x, y) for x in range(0, board.width, 20) 
                             for y in range(0, board.height, 20)]
        valid_positions = [pos for pos in possible_positions if pos not in snake.body]
        if not valid_positions:
            raise Exception("No empty spaces on the board. Game Over.")
        self.x, self.y = random.choice(valid_positions)


class Game:
    def __init__(self):
        self.board = Board()
        self.snake = Snake()
        self.food = Food()
        self.screen = pygame.display.set_mode((self.board.width, self.board.height))
        self.clock = pygame.time.Clock()

    def run(self):
        while True:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_UP and self.snake.direction != 'DOWN':
                        self.snake.direction = 'UP'
                    elif event.key == pygame.K_DOWN and self.snake.direction != 'UP':
                        self.snake.direction = 'DOWN'
                    elif event.key == pygame.K_LEFT and self.snake.direction != 'RIGHT':
                        self.snake.direction = 'LEFT'
                    elif event.key == pygame.K_RIGHT and self.snake.direction != 'LEFT':
                        self.snake.direction = 'RIGHT'

            self.snake.move()
            if self.snake.check_collision(self.board):
                print("Game Over")
                break

            if (self.snake.body[-1][0] == self.food.x and 
                    self.snake.body[-1][1] == self.food.y):
                self.snake.grow()
                self.food.generate_new_food(self.board, self.snake)

            self.screen.fill((0, 0, 0))
            self.board.draw_grid(self.screen)
            for pos in self.snake.body:
                pygame.draw.rect(self.screen, (0, 255, 0), (pos[0], pos[1], 20, 20))
            pygame.draw.rect(self.screen, (255, 0, 0), (self.food.x, self.food.y, 20, 20))
            pygame.display.update()
            self.clock.tick(10)


if __name__ == "__main__":
    game = Game()
    game.run()


```

## Code Review: main.py
1. No, the code is not fully implemented as per the requirements. To achieve this, the following steps should be taken:
   - Implement the `grow` method in the Snake class to correctly add new segments when the snake eats food.
   - Modify the Food class's `generate_new_food` method to ensure it doesn't place food on top of the snake's body.
   - Add a scoring system and display the score on the screen.
   - Implement game over logic, including displaying a game over message and resetting the game state.

2. No, there are errors in the code logic. To correct them:
   - In the Snake class's `move` method, when moving up or down, the new head position should be calculated based on the current direction, not just adding 20 to the x-coordinate.
   - The Food class's `generate_new_food` method should filter out positions that are part of the snake's body before choosing a random position.

3. Yes, the existing code follows the "Data structures and interfaces" as it uses classes for Board, Snake, Food, and Game, which is a good structure for this type of game.

4. No, not all functions are implemented. To achieve full implementation:
   - Implement the `handle_events` method to handle user input (e.g., moving the snake) and update the game state accordingly.
   - Add a method to update the game state after each move, including checking for collisions with the wall or itself.

5. Yes, all necessary pre-dependencies have been imported.

6. Yes, methods from other files are being reused correctly in this context since the provided code seems self-contained within main.py.

## Actions:
1. Implement the `grow` method in the Snake class.
2. Modify the Food class's `generate_new_food` method to avoid placing food on the snake.
3. Add a scoring system and display the score.
4. Implement game over logic, including displaying a message and resetting the game state.

## Code Review Result:
LBTM

# Instruction: rewrite code based on the Code Review and Actions
## Rewrite Code: CodeBlock. If it still has some bugs, rewrite main.py with triple quotes. Do your utmost to optimize THIS SINGLE FILE. Return all completed codes and prohibit the return of unfinished codes.
```Code
## main.py
...
```




