
## context
{"Language":"en_us","Programming Language":"Python","Original Requirements":"Create a snake game in Python","Project Name":"snake_game","Product Goals":["Create an engaging user experience","Improve accessibility, be responsive","More beautiful UI"],"User Stories":["As a player, I want to be able to choose difficulty levels","As a player, I want to see my score after each game","As a player, I want to get restart button when I lose","As a player, I want to see beautiful UI that make me feel good","As a player, I want to play game via mobile phone"],"Competitive Analysis":["Snake Game A: Simple interface, lacks responsive features","playSnake.co: Beautiful and responsive UI with my best score shown","snakeGame.com: Responsive UI with my best score shown, but many ads"],"Competitive Quadrant Chart":"quadrantChart\n    title \"Reach and engagement of campaigns\"\n    x-axis \"Low Reach\" --> \"High Reach\"\n    y-axis \"Low Engagement\" --> \"High Engagement\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Campaign A\": [0.3, 0.6]\n    \"Campaign B\": [0.45, 0.23]\n    \"Campaign C\": [0.57, 0.69]\n    \"Campaign D\": [0.78, 0.34]\n    \"Campaign E\": [0.40, 0.34]\n    \"Campaign F\": [0.35, 0.78]\n    \"Our Target Product\": [0.5, 0.6]","Requirement Analysis":"","Requirement Pool":[["P0","The main code ..."],["P0","The game algorithm ..."]],"UI Design draft":"Basic function description with a simple style and layout.","Anything UNCLEAR":""}

-----

## format example
[CONTENT]
{
    "Implementation approach": "We will ...",
    "File list": [
        "main.py",
        "game.py"
    ],
    "Data structures and interfaces": "\nclassDiagram\n    class Main {\n        -SearchEngine search_engine\n        +main() str\n    }\n    class SearchEngine {\n        -Index index\n        -Ranking ranking\n        -Summary summary\n        +search(query: str) str\n    }\n    class Index {\n        -KnowledgeBase knowledge_base\n        +create_index(data: dict)\n        +query_index(query: str) list\n    }\n    class Ranking {\n        +rank_results(results: list) list\n    }\n    class Summary {\n        +summarize_results(results: list) str\n    }\n    class KnowledgeBase {\n        +update(data: dict)\n        +fetch_data(query: str) dict\n    }\n    Main --> SearchEngine\n    SearchEngine --> Index\n    SearchEngine --> Ranking\n    SearchEngine --> Summary\n    Index --> KnowledgeBase\n",
    "Program call flow": "\nsequenceDiagram\n    participant M as Main\n    participant SE as SearchEngine\n    participant I as Index\n    participant R as Ranking\n    participant S as Summary\n    participant KB as KnowledgeBase\n    M->>SE: search(query)\n    SE->>I: query_index(query)\n    I->>KB: fetch_data(query)\n    KB-->>I: return data\n    I-->>SE: return results\n    SE->>R: rank_results(results)\n    R-->>SE: return ranked_results\n    SE->>S: summarize_results(ranked_results)\n    S-->>SE: return summary\n    SE-->>M: return summary\n",
    "Anything UNCLEAR": "Clarification needed on third-party API integration, ..."
}
[/CONTENT]

## nodes: "<node>: <type>  # <instruction>"
- Implementation approach: <class 'str'>  # Analyze the difficult points of the requirements, select the appropriate open-source framework
- File list: typing.List[str]  # Only need relative paths. ALWAYS write a main.py or app.py here
- Data structures and interfaces: <class 'str'>  # Use mermaid classDiagram code syntax, including classes, method(__init__ etc.) and functions with type annotations, CLEARLY MARK the RELATIONSHIPS between classes, and comply with PEP8 standards. The data structures SHOULD BE VERY DETAILED and the API should be comprehensive with a complete design.
- Program call flow: <class 'str'>  # Use sequenceDiagram code syntax, COMPLETE and VERY DETAILED, using CLASSES AND API DEFINED ABOVE accurately, covering the CRUD AND INIT of each object, SYNTAX MUST BE CORRECT.
- Anything UNCLEAR: <class 'str'>  # Mention unclear project aspects, then try to clarify it.


## constraint
Language: Please use the same language as Human INPUT.
Format: output wrapped inside [CONTENT][/CONTENT] like format example, nothing else.

## action
Follow instructions of nodes, generate output and make sure it follows the format example.


{
    "Implementation approach": We will use Pygame for creating a simple yet engaging game interface, with responsive features to ensure a smooth gaming experience on mobile devices.
    "File list": [
        "main.py",
        "game.py"
    ],
    "Data structures and interfaces":
```
class SnakeGame:
    def __init__(self):
        self.snake = [(200, 200), (220, 200), (240, 200)]
        self.direction = 'RIGHT'
        self.food = None
        self.score = 0

    def update(self):
        # Update snake position based on direction
        head = self.snake[-1]
        if self.direction == 'UP':
            new_head = (head[0], head[1] - 20)
        elif self.direction == 'DOWN':
            new_head = (head[0], head[1] + 20)
        elif self.direction == 'LEFT':
            new_head = (head[0] - 20, head[1])
        elif self.direction == 'RIGHT':
            new_head = (head[0] + 20, head[1])

        # Check for collision with food
        if self.food == new_head:
            self.score += 10
            self.food = None
            self.generate_food()
        else:
            self.snake.append(new_head)
            if len(self.snake) > 100:
                self.snake.pop(0)

    def generate_food(self):
        # Generate random food position
        import random
        self.food = (random.randint(0, 39) * 20, random.randint(0, 19) * 20)

    def check_game_over(self):
        # Check for collision with boundary or itself
        head = self.snake[-1]
        if (head[0] < 0 or head[0] > 760 or
            head[1] < 0 or head[1] > 480 or
            self.snake[-1] in self.snake[:-1]):
            return True
        return False

    def play(self):
        while not self.check_game_over():
            # Update game state
            self.update()
            # Draw game state
            # ...
            # Handle user input
            # ...

class UI:
    def __init__(self, game):
        self.game = game

    def draw(self):
        # Draw game state
        # ...

    def handle_input(self, event):
        # Handle user input
        # ...
}

class Game:
    def __init__(self):
        self.snake_game = SnakeGame()
        self.ui = UI(self.snake_game)

    def run(self):
        while True:
            # Update game state
            self.snake_game.play()
            # Draw game state
            self.ui.draw()
            # Handle user input
            self.ui.handle_input(event)
}
```
    "Program call flow":
```
sequenceDiagram
participant M as Game
participant S as SnakeGame
participant U as UI
M->>S: update()
S->>U: draw()
U->>M: handle_input(event)
M->>S: play()
S-->>U: return score
U-->>M: display score
M->>S: generate_food()
S-->>U: return food position
U-->>M: display food position
```
    "Anything UNCLEAR": Please clarify the requirements for the game's difficulty levels and scoring system.


## context
{"Language":"en_us","Programming Language":"Python","Original Requirements":"Create a snake game in Python","Project Name":"snake_game","Product Goals":["Create an engaging user experience","Improve accessibility, be responsive","More beautiful UI"],"User Stories":["As a player, I want to be able to choose difficulty levels","As a player, I want to see my score after each game","As a player, I want to get restart button when I lose","As a player, I want to see beautiful UI that make me feel good","As a player, I want to play game via mobile phone"],"Competitive Analysis":["Snake Game A: Simple interface, lacks responsive features","playSnake.co: Beautiful and responsive UI with my best score shown","snakeGame.com: Responsive UI with my best score shown, but many ads"],"Competitive Quadrant Chart":"quadrantChart\n    title \"Reach and engagement of campaigns\"\n    x-axis \"Low Reach\" --> \"High Reach\"\n    y-axis \"Low Engagement\" --> \"High Engagement\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Campaign A\": [0.3, 0.6]\n    \"Campaign B\": [0.45, 0.23]\n    \"Campaign C\": [0.57, 0.69]\n    \"Campaign D\": [0.78, 0.34]\n    \"Campaign E\": [0.40, 0.34]\n    \"Campaign F\": [0.35, 0.78]\n    \"Our Target Product\": [0.5, 0.6]","Requirement Analysis":"","Requirement Pool":[["P0","The main code ..."],["P0","The game algorithm ..."]],"UI Design draft":"Basic function description with a simple style and layout.","Anything UNCLEAR":""}

-----

## format example
[CONTENT]
{
    "Implementation approach": "We will ...",
    "File list": [
        "main.py",
        "game.py"
    ],
    "Data structures and interfaces": "\nclassDiagram\n    class Main {\n        -SearchEngine search_engine\n        +main() str\n    }\n    class SearchEngine {\n        -Index index\n        -Ranking ranking\n        -Summary summary\n        +search(query: str) str\n    }\n    class Index {\n        -KnowledgeBase knowledge_base\n        +create_index(data: dict)\n        +query_index(query: str) list\n    }\n    class Ranking {\n        +rank_results(results: list) list\n    }\n    class Summary {\n        +summarize_results(results: list) str\n    }\n    class KnowledgeBase {\n        +update(data: dict)\n        +fetch_data(query: str) dict\n    }\n    Main --> SearchEngine\n    SearchEngine --> Index\n    SearchEngine --> Ranking\n    SearchEngine --> Summary\n    Index --> KnowledgeBase\n",
    "Program call flow": "\nsequenceDiagram\n    participant M as Main\n    participant SE as SearchEngine\n    participant I as Index\n    participant R as Ranking\n    participant S as Summary\n    participant KB as KnowledgeBase\n    M->>SE: search(query)\n    SE->>I: query_index(query)\n    I->>KB: fetch_data(query)\n    KB-->>I: return data\n    I-->>SE: return results\n    SE->>R: rank_results(results)\n    R-->>SE: return ranked_results\n    SE->>S: summarize_results(ranked_results)\n    S-->>SE: return summary\n    SE-->>M: return summary\n",
    "Anything UNCLEAR": "Clarification needed on third-party API integration, ..."
}
[/CONTENT]

## nodes: "<node>: <type>  # <instruction>"
- Implementation approach: <class 'str'>  # Analyze the difficult points of the requirements, select the appropriate open-source framework
- File list: typing.List[str]  # Only need relative paths. ALWAYS write a main.py or app.py here
- Data structures and interfaces: <class 'str'>  # Use mermaid classDiagram code syntax, including classes, method(__init__ etc.) and functions with type annotations, CLEARLY MARK the RELATIONSHIPS between classes, and comply with PEP8 standards. The data structures SHOULD BE VERY DETAILED and the API should be comprehensive with a complete design.
- Program call flow: <class 'str'>  # Use sequenceDiagram code syntax, COMPLETE and VERY DETAILED, using CLASSES AND API DEFINED ABOVE accurately, covering the CRUD AND INIT of each object, SYNTAX MUST BE CORRECT.
- Anything UNCLEAR: <class 'str'>  # Mention unclear project aspects, then try to clarify it.


## constraint
Language: Please use the same language as Human INPUT.
Format: output wrapped inside [CONTENT][/CONTENT] like format example, nothing else.

## action
Follow instructions of nodes, generate output and make sure it follows the format example.


2025-12-03 10:04:23.381 | INFO     | metagpt.utils.repair_llm_raw_output:repair_invalid_json:237 - repair_invalid_json, raw error: Expecting value: line 2 column 28 (char 29)
2025-12-03 10:04:23.382 | ERROR    | metagpt.utils.common:log_it:554 - Finished call to 'metagpt.actions.action_node.ActionNode._aask_v1' after 8.755(s), this was the 2nd time calling it. exp: RetryError[<Future at 0x779d75735c40 state=finished raised JSONDecodeError>]


## context
{"Language":"en_us","Programming Language":"Python","Original Requirements":"Create a snake game in Python","Project Name":"snake_game","Product Goals":["Create an engaging user experience","Improve accessibility, be responsive","More beautiful UI"],"User Stories":["As a player, I want to be able to choose difficulty levels","As a player, I want to see my score after each game","As a player, I want to get restart button when I lose","As a player, I want to see beautiful UI that make me feel good","As a player, I want to play game via mobile phone"],"Competitive Analysis":["Snake Game A: Simple interface, lacks responsive features","playSnake.co: Beautiful and responsive UI with my best score shown","snakeGame.com: Responsive UI with my best score shown, but many ads"],"Competitive Quadrant Chart":"quadrantChart\n    title \"Reach and engagement of campaigns\"\n    x-axis \"Low Reach\" --> \"High Reach\"\n    y-axis \"Low Engagement\" --> \"High Engagement\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Campaign A\": [0.3, 0.6]\n    \"Campaign B\": [0.45, 0.23]\n    \"Campaign C\": [0.57, 0.69]\n    \"Campaign D\": [0.78, 0.34]\n    \"Campaign E\": [0.40, 0.34]\n    \"Campaign F\": [0.35, 0.78]\n    \"Our Target Product\": [0.5, 0.6]","Requirement Analysis":"","Requirement Pool":[["P0","The main code ..."],["P0","The game algorithm ..."]],"UI Design draft":"Basic function description with a simple style and layout.","Anything UNCLEAR":""}

-----

## format example
[CONTENT]
{
    "Implementation approach": "We will ...",
    "File list": [
        "main.py",
        "game.py"
    ],
    "Data structures and interfaces": "\nclassDiagram\n    class Main {\n        -SearchEngine search_engine\n        +main() str\n    }\n    class SearchEngine {\n        -Index index\n        -Ranking ranking\n        -Summary summary\n        +search(query: str) str\n    }\n    class Index {\n        -KnowledgeBase knowledge_base\n        +create_index(data: dict)\n        +query_index(query: str) list\n    }\n    class Ranking {\n        +rank_results(results: list) list\n    }\n    class Summary {\n        +summarize_results(results: list) str\n    }\n    class KnowledgeBase {\n        +update(data: dict)\n        +fetch_data(query: str) dict\n    }\n    Main --> SearchEngine\n    SearchEngine --> Index\n    SearchEngine --> Ranking\n    SearchEngine --> Summary\n    Index --> KnowledgeBase\n",
    "Program call flow": "\nsequenceDiagram\n    participant M as Main\n    participant SE as SearchEngine\n    participant I as Index\n    participant R as Ranking\n    participant S as Summary\n    participant KB as KnowledgeBase\n    M->>SE: search(query)\n    SE->>I: query_index(query)\n    I->>KB: fetch_data(query)\n    KB-->>I: return data\n    I-->>SE: return results\n    SE->>R: rank_results(results)\n    R-->>SE: return ranked_results\n    SE->>S: summarize_results(ranked_results)\n    S-->>SE: return summary\n    SE-->>M: return summary\n",
    "Anything UNCLEAR": "Clarification needed on third-party API integration, ..."
}
[/CONTENT]

## nodes: "<node>: <type>  # <instruction>"
- Implementation approach: <class 'str'>  # Analyze the difficult points of the requirements, select the appropriate open-source framework
- File list: typing.List[str]  # Only need relative paths. ALWAYS write a main.py or app.py here
- Data structures and interfaces: <class 'str'>  # Use mermaid classDiagram code syntax, including classes, method(__init__ etc.) and functions with type annotations, CLEARLY MARK the RELATIONSHIPS between classes, and comply with PEP8 standards. The data structures SHOULD BE VERY DETAILED and the API should be comprehensive with a complete design.
- Program call flow: <class 'str'>  # Use sequenceDiagram code syntax, COMPLETE and VERY DETAILED, using CLASSES AND API DEFINED ABOVE accurately, covering the CRUD AND INIT of each object, SYNTAX MUST BE CORRECT.
- Anything UNCLEAR: <class 'str'>  # Mention unclear project aspects, then try to clarify it.


## constraint
Language: Please use the same language as Human INPUT.
Format: output wrapped inside [CONTENT][/CONTENT] like format example, nothing else.

## action
Follow instructions of nodes, generate output and make sure it follows the format example.


{
    "Implementation approach": We will use Python as our programming language and Pygame for game development. This choice allows us to create a visually appealing and engaging user experience while meeting the project's requirements.

    "File list": [
        "main.py",
        "game.py"
    ],
    "Data structures and interfaces":
    ```mermaid
classDiagram
    class Main {
        - search_engine: SearchEngine
        + main() str
    }
    class SearchEngine {
        - index: Index
        - ranking: Ranking
        - summary: Summary
        + search(query: str) str
    }
    class Index {
        - knowledge_base: KnowledgeBase
        + create_index(data: dict)
        + query_index(query: str) list
    }
    class Ranking {
        + rank_results(results: list) list
    }
    class Summary {
        + summarize_results(results: list) str
    }
    class KnowledgeBase {
        + update(data: dict)
        + fetch_data(query: str) dict
    }
    Main --> SearchEngine
    SearchEngine --> Index
    SearchEngine --> Ranking
    SearchEngine --> Summary
    Index --> KnowledgeBase
```
    "Program call flow":
    ```mermaid
sequenceDiagram
    participant M as Main
    participant SE as SearchEngine
    participant I as Index
    participant R as Ranking
    participant S as Summary
    participant KB as KnowledgeBase
    M->>SE: search(query)
    SE->>I: query_index(query)
    I->>KB: fetch_data(query)
    KB-->>I: return data
    I-->>SE: return results
    SE->>R: rank_results(results)
    R-->>SE: return ranked_results
    SE->>S: summarize_results(ranked_results)
    S-->>SE: return summary
    SE-->>M: return summary
```
    "Anything UNCLEAR": Clarification needed on third-party API integration, ...
}


## context
{"Language":"en_us","Programming Language":"Python","Original Requirements":"Create a snake game in Python","Project Name":"snake_game","Product Goals":["Create an engaging user experience","Improve accessibility, be responsive","More beautiful UI"],"User Stories":["As a player, I want to be able to choose difficulty levels","As a player, I want to see my score after each game","As a player, I want to get restart button when I lose","As a player, I want to see beautiful UI that make me feel good","As a player, I want to play game via mobile phone"],"Competitive Analysis":["Snake Game A: Simple interface, lacks responsive features","playSnake.co: Beautiful and responsive UI with my best score shown","snakeGame.com: Responsive UI with my best score shown, but many ads"],"Competitive Quadrant Chart":"quadrantChart\n    title \"Reach and engagement of campaigns\"\n    x-axis \"Low Reach\" --> \"High Reach\"\n    y-axis \"Low Engagement\" --> \"High Engagement\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Campaign A\": [0.3, 0.6]\n    \"Campaign B\": [0.45, 0.23]\n    \"Campaign C\": [0.57, 0.69]\n    \"Campaign D\": [0.78, 0.34]\n    \"Campaign E\": [0.40, 0.34]\n    \"Campaign F\": [0.35, 0.78]\n    \"Our Target Product\": [0.5, 0.6]","Requirement Analysis":"","Requirement Pool":[["P0","The main code ..."],["P0","The game algorithm ..."]],"UI Design draft":"Basic function description with a simple style and layout.","Anything UNCLEAR":""}

-----

## format example
[CONTENT]
{
    "Implementation approach": "We will ...",
    "File list": [
        "main.py",
        "game.py"
    ],
    "Data structures and interfaces": "\nclassDiagram\n    class Main {\n        -SearchEngine search_engine\n        +main() str\n    }\n    class SearchEngine {\n        -Index index\n        -Ranking ranking\n        -Summary summary\n        +search(query: str) str\n    }\n    class Index {\n        -KnowledgeBase knowledge_base\n        +create_index(data: dict)\n        +query_index(query: str) list\n    }\n    class Ranking {\n        +rank_results(results: list) list\n    }\n    class Summary {\n        +summarize_results(results: list) str\n    }\n    class KnowledgeBase {\n        +update(data: dict)\n        +fetch_data(query: str) dict\n    }\n    Main --> SearchEngine\n    SearchEngine --> Index\n    SearchEngine --> Ranking\n    SearchEngine --> Summary\n    Index --> KnowledgeBase\n",
    "Program call flow": "\nsequenceDiagram\n    participant M as Main\n    participant SE as SearchEngine\n    participant I as Index\n    participant R as Ranking\n    participant S as Summary\n    participant KB as KnowledgeBase\n    M->>SE: search(query)\n    SE->>I: query_index(query)\n    I->>KB: fetch_data(query)\n    KB-->>I: return data\n    I-->>SE: return results\n    SE->>R: rank_results(results)\n    R-->>SE: return ranked_results\n    SE->>S: summarize_results(ranked_results)\n    S-->>SE: return summary\n    SE-->>M: return summary\n",
    "Anything UNCLEAR": "Clarification needed on third-party API integration, ..."
}
[/CONTENT]

## nodes: "<node>: <type>  # <instruction>"
- Implementation approach: <class 'str'>  # Analyze the difficult points of the requirements, select the appropriate open-source framework
- File list: typing.List[str]  # Only need relative paths. ALWAYS write a main.py or app.py here
- Data structures and interfaces: <class 'str'>  # Use mermaid classDiagram code syntax, including classes, method(__init__ etc.) and functions with type annotations, CLEARLY MARK the RELATIONSHIPS between classes, and comply with PEP8 standards. The data structures SHOULD BE VERY DETAILED and the API should be comprehensive with a complete design.
- Program call flow: <class 'str'>  # Use sequenceDiagram code syntax, COMPLETE and VERY DETAILED, using CLASSES AND API DEFINED ABOVE accurately, covering the CRUD AND INIT of each object, SYNTAX MUST BE CORRECT.
- Anything UNCLEAR: <class 'str'>  # Mention unclear project aspects, then try to clarify it.


## constraint
Language: Please use the same language as Human INPUT.
Format: output wrapped inside [CONTENT][/CONTENT] like format example, nothing else.

## action
Follow instructions of nodes, generate output and make sure it follows the format example.


2025-12-03 10:04:36.628 | INFO     | metagpt.utils.repair_llm_raw_output:repair_invalid_json:237 - repair_invalid_json, raw error: Expecting value: line 2 column 28 (char 29)
2025-12-03 10:04:36.628 | ERROR    | metagpt.utils.common:log_it:554 - Finished call to 'metagpt.actions.action_node.ActionNode._aask_v1' after 22.001(s), this was the 4th time calling it. exp: RetryError[<Future at 0x779d7579c5e0 state=finished raised JSONDecodeError>]


## context
{"Language":"en_us","Programming Language":"Python","Original Requirements":"Create a snake game in Python","Project Name":"snake_game","Product Goals":["Create an engaging user experience","Improve accessibility, be responsive","More beautiful UI"],"User Stories":["As a player, I want to be able to choose difficulty levels","As a player, I want to see my score after each game","As a player, I want to get restart button when I lose","As a player, I want to see beautiful UI that make me feel good","As a player, I want to play game via mobile phone"],"Competitive Analysis":["Snake Game A: Simple interface, lacks responsive features","playSnake.co: Beautiful and responsive UI with my best score shown","snakeGame.com: Responsive UI with my best score shown, but many ads"],"Competitive Quadrant Chart":"quadrantChart\n    title \"Reach and engagement of campaigns\"\n    x-axis \"Low Reach\" --> \"High Reach\"\n    y-axis \"Low Engagement\" --> \"High Engagement\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Campaign A\": [0.3, 0.6]\n    \"Campaign B\": [0.45, 0.23]\n    \"Campaign C\": [0.57, 0.69]\n    \"Campaign D\": [0.78, 0.34]\n    \"Campaign E\": [0.40, 0.34]\n    \"Campaign F\": [0.35, 0.78]\n    \"Our Target Product\": [0.5, 0.6]","Requirement Analysis":"","Requirement Pool":[["P0","The main code ..."],["P0","The game algorithm ..."]],"UI Design draft":"Basic function description with a simple style and layout.","Anything UNCLEAR":""}

-----

## format example
[CONTENT]
{
    "Implementation approach": "We will ...",
    "File list": [
        "main.py",
        "game.py"
    ],
    "Data structures and interfaces": "\nclassDiagram\n    class Main {\n        -SearchEngine search_engine\n        +main() str\n    }\n    class SearchEngine {\n        -Index index\n        -Ranking ranking\n        -Summary summary\n        +search(query: str) str\n    }\n    class Index {\n        -KnowledgeBase knowledge_base\n        +create_index(data: dict)\n        +query_index(query: str) list\n    }\n    class Ranking {\n        +rank_results(results: list) list\n    }\n    class Summary {\n        +summarize_results(results: list) str\n    }\n    class KnowledgeBase {\n        +update(data: dict)\n        +fetch_data(query: str) dict\n    }\n    Main --> SearchEngine\n    SearchEngine --> Index\n    SearchEngine --> Ranking\n    SearchEngine --> Summary\n    Index --> KnowledgeBase\n",
    "Program call flow": "\nsequenceDiagram\n    participant M as Main\n    participant SE as SearchEngine\n    participant I as Index\n    participant R as Ranking\n    participant S as Summary\n    participant KB as KnowledgeBase\n    M->>SE: search(query)\n    SE->>I: query_index(query)\n    I->>KB: fetch_data(query)\n    KB-->>I: return data\n    I-->>SE: return results\n    SE->>R: rank_results(results)\n    R-->>SE: return ranked_results\n    SE->>S: summarize_results(ranked_results)\n    S-->>SE: return summary\n    SE-->>M: return summary\n",
    "Anything UNCLEAR": "Clarification needed on third-party API integration, ..."
}
[/CONTENT]

## nodes: "<node>: <type>  # <instruction>"
- Implementation approach: <class 'str'>  # Analyze the difficult points of the requirements, select the appropriate open-source framework
- File list: typing.List[str]  # Only need relative paths. ALWAYS write a main.py or app.py here
- Data structures and interfaces: <class 'str'>  # Use mermaid classDiagram code syntax, including classes, method(__init__ etc.) and functions with type annotations, CLEARLY MARK the RELATIONSHIPS between classes, and comply with PEP8 standards. The data structures SHOULD BE VERY DETAILED and the API should be comprehensive with a complete design.
- Program call flow: <class 'str'>  # Use sequenceDiagram code syntax, COMPLETE and VERY DETAILED, using CLASSES AND API DEFINED ABOVE accurately, covering the CRUD AND INIT of each object, SYNTAX MUST BE CORRECT.
- Anything UNCLEAR: <class 'str'>  # Mention unclear project aspects, then try to clarify it.


## constraint
Language: Please use the same language as Human INPUT.
Format: output wrapped inside [CONTENT][/CONTENT] like format example, nothing else.

## action
Follow instructions of nodes, generate output and make sure it follows the format example.


{
    "Implementation approach": We will use Python as our programming language to create a snake game. We will utilize the Pygame library for creating games in Python. The main code will be organized into different modules to keep it maintainable and scalable.

    "File list": [
        "main.py",
        "game.py"
    ],

    "Data structures and interfaces":
    ```mermaid
classDiagram
    class Main {
        - SearchEngine search_engine
        + main() str
    }
    class SearchEngine {
        - Index index
        - Ranking ranking
        - Summary summary
        + search(query: str) str
    }
    class Index {
        - KnowledgeBase knowledge_base
        + create_index(data: dict)
        + query_index(query: str) list
    }
    class Ranking {
        + rank_results(results: list) list
    }
    class Summary {
        + summarize_results(results: list) str
    }
    class KnowledgeBase {
        + update(data: dict)
        + fetch_data(query: str) dict
    }
    Main --> SearchEngine
    SearchEngine --> Index
    SearchEngine --> Ranking
    SearchEngine --> Summary
    Index --> KnowledgeBase
```

    "Program call flow":
    ```mermaid
sequenceDiagram
    participant M as Main
    participant SE as SearchEngine
    participant I as Index
    participant R as Ranking
    participant S as Summary
    participant KB as KnowledgeBase
    M->>SE: search(query)
    SE->>I: query_index(query)
    I->>KB: fetch_data(query)
    KB-->>I: return data
    I-->>SE: return results
    SE->>R: rank_results(results)
    R-->>SE: return ranked_results
    SE->>S: summarize_results(ranked_results)
    S-->>SE: return summary
    SE-->>M: return summary
```

    "Anything UNCLEAR": Clarification needed on third-party API integration, ...
}


## context
{"Language":"en_us","Programming Language":"Python","Original Requirements":"Create a snake game in Python","Project Name":"snake_game","Product Goals":["Create an engaging user experience","Improve accessibility, be responsive","More beautiful UI"],"User Stories":["As a player, I want to be able to choose difficulty levels","As a player, I want to see my score after each game","As a player, I want to get restart button when I lose","As a player, I want to see beautiful UI that make me feel good","As a player, I want to play game via mobile phone"],"Competitive Analysis":["Snake Game A: Simple interface, lacks responsive features","playSnake.co: Beautiful and responsive UI with my best score shown","snakeGame.com: Responsive UI with my best score shown, but many ads"],"Competitive Quadrant Chart":"quadrantChart\n    title \"Reach and engagement of campaigns\"\n    x-axis \"Low Reach\" --> \"High Reach\"\n    y-axis \"Low Engagement\" --> \"High Engagement\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Campaign A\": [0.3, 0.6]\n    \"Campaign B\": [0.45, 0.23]\n    \"Campaign C\": [0.57, 0.69]\n    \"Campaign D\": [0.78, 0.34]\n    \"Campaign E\": [0.40, 0.34]\n    \"Campaign F\": [0.35, 0.78]\n    \"Our Target Product\": [0.5, 0.6]","Requirement Analysis":"","Requirement Pool":[["P0","The main code ..."],["P0","The game algorithm ..."]],"UI Design draft":"Basic function description with a simple style and layout.","Anything UNCLEAR":""}

-----

## format example
[CONTENT]
{
    "Implementation approach": "We will ...",
    "File list": [
        "main.py",
        "game.py"
    ],
    "Data structures and interfaces": "\nclassDiagram\n    class Main {\n        -SearchEngine search_engine\n        +main() str\n    }\n    class SearchEngine {\n        -Index index\n        -Ranking ranking\n        -Summary summary\n        +search(query: str) str\n    }\n    class Index {\n        -KnowledgeBase knowledge_base\n        +create_index(data: dict)\n        +query_index(query: str) list\n    }\n    class Ranking {\n        +rank_results(results: list) list\n    }\n    class Summary {\n        +summarize_results(results: list) str\n    }\n    class KnowledgeBase {\n        +update(data: dict)\n        +fetch_data(query: str) dict\n    }\n    Main --> SearchEngine\n    SearchEngine --> Index\n    SearchEngine --> Ranking\n    SearchEngine --> Summary\n    Index --> KnowledgeBase\n",
    "Program call flow": "\nsequenceDiagram\n    participant M as Main\n    participant SE as SearchEngine\n    participant I as Index\n    participant R as Ranking\n    participant S as Summary\n    participant KB as KnowledgeBase\n    M->>SE: search(query)\n    SE->>I: query_index(query)\n    I->>KB: fetch_data(query)\n    KB-->>I: return data\n    I-->>SE: return results\n    SE->>R: rank_results(results)\n    R-->>SE: return ranked_results\n    SE->>S: summarize_results(ranked_results)\n    S-->>SE: return summary\n    SE-->>M: return summary\n",
    "Anything UNCLEAR": "Clarification needed on third-party API integration, ..."
}
[/CONTENT]

## nodes: "<node>: <type>  # <instruction>"
- Implementation approach: <class 'str'>  # Analyze the difficult points of the requirements, select the appropriate open-source framework
- File list: typing.List[str]  # Only need relative paths. ALWAYS write a main.py or app.py here
- Data structures and interfaces: <class 'str'>  # Use mermaid classDiagram code syntax, including classes, method(__init__ etc.) and functions with type annotations, CLEARLY MARK the RELATIONSHIPS between classes, and comply with PEP8 standards. The data structures SHOULD BE VERY DETAILED and the API should be comprehensive with a complete design.
- Program call flow: <class 'str'>  # Use sequenceDiagram code syntax, COMPLETE and VERY DETAILED, using CLASSES AND API DEFINED ABOVE accurately, covering the CRUD AND INIT of each object, SYNTAX MUST BE CORRECT.
- Anything UNCLEAR: <class 'str'>  # Mention unclear project aspects, then try to clarify it.


## constraint
Language: Please use the same language as Human INPUT.
Format: output wrapped inside [CONTENT][/CONTENT] like format example, nothing else.

## action
Follow instructions of nodes, generate output and make sure it follows the format example.


{
    "Implementation approach": We will use Python as our programming language to create a snake game. We will utilize the Pygame library for its simplicity and ease of use in creating games.

    "File list": [
        "main.py",
        "game.py"
    ],
    "Data structures and interfaces":
    ```mermaid
classDiagram
    class Main {
        - search_engine
        + main() str
    }
    class SearchEngine {
        - index
        - ranking
        - summary
        + search(query: str) str
    }
    class Index {
        - knowledge_base
        + create_index(data: dict)
        + query_index(query: str) list
    }
    class Ranking {
        + rank_results(results: list) list
    }
    class Summary {
        + summarize_results(results: list) str
    }
    class KnowledgeBase {
        + update(data: dict)
        + fetch_data(query: str) dict
    }
    Main --> SearchEngine
    SearchEngine --> Index
    SearchEngine --> Ranking
    SearchEngine --> Summary
    Index --> KnowledgeBase
```
    "Program call flow":
    ```sequenceDiagram
participant M as Main
participant SE as SearchEngine
participant I as Index
participant R as Ranking
participant S as Summary
participant KB as KnowledgeBase

M->>SE: search(query)
SE->>I: query_index(query)
I->>KB: fetch_data(query)
KB-->>I: return data
I-->>SE: return results
SE->>R: rank_results(results)
R-->>SE: return ranked_results
SE->>S: summarize_results(ranked_results)
S-->>SE: return summary
SE-->>M: return summary
```
    "Anything UNCLEAR": Clarification needed on third-party API integration, ...
}

