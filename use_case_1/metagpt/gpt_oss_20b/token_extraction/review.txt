
# System
Role: You are a professional software engineer, and your main task is to review and revise the code. You need to ensure that the code conforms to the google-style standards, is elegantly designed and modularized, easy to read and maintain.
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## System Design
{"Implementation approach":"We will build the game as a small, selfâcontained console application using the standard `curses` library for realâtime keyboard input and screen drawing. The core logic will be split into a handful of focused classes:\n\n* **Game** â owns the main loop, coordinates input, update and rendering, and manages the overall state (running, paused, gameâover).\n* **Snake** â stores the ordered list of grid coordinates that make up the snake, handles movement, growth and collision checks.\n* **Food** â keeps the current food position and can generate a new one that never overlaps the snake.\n* **Grid** â represents the 10Ã10 board, provides bounds checking and a helper to convert coordinates to screen positions.\n* **Renderer** â draws the grid, snake, food and UI elements (score, gameâover message) onto the curses window.\n* **InputHandler** â translates arrowâkey events into direction changes while preventing 180Â° reversals.\n\nThe game loop will run at a fixed tick rate (e.g. 10 frames per second). Each tick we:\n1. Poll for a key press.\n2. Update the snakeâs direction.\n3. Move the snake forward.\n4. Check for collisions (wall, self, food).\n5. Grow the snake and update the score if food is eaten.\n6. Render the updated state.\n\nThis separation keeps the code testable, readable and easily extensible (e.g. adding levels or AI). All state is kept in plain Python data structures (lists, tuples, ints) so no external dependencies are required beyond the standard library.\n\n","File list":["main.py","game.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -grid: Grid\n        -snake: Snake\n        -food: Food\n        -renderer: Renderer\n        -input_handler: InputHandler\n        -score: int\n        -running: bool\n        +__init__(window: curses.window)\n        +start() void\n        +handle_input() void\n        +update() void\n        +render() void\n        +game_over() void\n    }\n    class Snake {\n        -body: List[Tuple[int,int]]\n        -direction: Tuple[int,int]\n        +__init__(start_pos: Tuple[int,int], start_dir: Tuple[int,int])\n        +move() void\n        +grow() void\n        +set_direction(new_dir: Tuple[int,int]) void\n        +collides_with_self() bool\n        +collides_with_wall(grid: Grid) bool\n        +head() Tuple[int,int]\n    }\n    class Food {\n        -position: Tuple[int,int]\n        +__init__(grid: Grid, snake: Snake)\n        +generate_new(grid: Grid, snake: Snake) void\n        +position() Tuple[int,int]\n    }\n    class Grid {\n        -width: int\n        -height: int\n        +__init__(width: int, height: int)\n        +in_bounds(pos: Tuple[int,int]) bool\n        +to_screen_coords(pos: Tuple[int,int]) Tuple[int,int]\n    }\n    class Renderer {\n        -window: curses.window\n        +__init__(window: curses.window)\n        +draw(grid: Grid, snake: Snake, food: Food, score: int, game_over: bool) void\n        +clear() void\n    }\n    class InputHandler {\n        -last_direction: Tuple[int,int]\n        +__init__()\n        +get_direction(key: int) Tuple[int,int]\n    }\n    Game --> Snake\n    Game --> Food\n    Game --> Grid\n    Game --> Renderer\n    Game --> InputHandler\n    Snake --> Grid\n    Food --> Grid\n    Renderer --> Grid\n    Renderer --> Snake\n    Renderer --> Food\n","Program call flow":"\nsequenceDiagram\n    participant M as main\n    participant G as Game\n    participant I as InputHandler\n    participant S as Snake\n    participant F as Food\n    participant R as Renderer\n    participant Gd as Grid\n\n    M->>G: __init__(curses_window)\n    G->>Gd: __init__(10,10)\n    G->>S: __init__(center, RIGHT)\n    G->>F: __init__(Gd, S)\n    G->>R: __init__(curses_window)\n    G->>I: __init__()\n    G->>G: start()\n\n    loop every tick\n        G->>I: get_direction(key)\n        I->>G: set_direction\n        G->>S: move()\n        G->>S: collides_with_self() -> bool\n        alt collision\n            G->>G: game_over()\n            G->>R: draw(..., game_over=true)\n            G->>G: break loop\n        else\n            G->>F: position()\n            alt ate food\n                G->>S: grow()\n                G->>S: score++\n                G->>F: generate_new(Gd, S)\n            end\n            G->>R: draw(..., game_over=false)\n        end\n    end\n","Anything UNCLEAR":"The specification mentions \"optional animations for movement and growth\" but does not detail the desired effect. In a console environment, we can simulate a simple animation by briefly flashing the new head position or adding a short delay after growth. If more elaborate animations (e.g., smooth scrolling) are required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or if a graphical window is expected."}

## Task
{"Required Python packages":["No external packages required; uses only the standard library (curses, typing, etc.)"],"Required Other language third-party packages":["No thirdâparty dependencies required"],"Logic Analysis":[["main.py","Imports Game from game.py, initializes curses, creates Game instance, calls start()"],["game.py","Defines Game class: manages main loop, holds Grid, Snake, Food, Renderer, InputHandler, score, running flag; imports all component classes"],["snake.py","Defines Snake class: body list, direction tuple, move(), grow(), set_direction(), collides_with_self(), collides_with_wall(), head()"],["food.py","Defines Food class: position tuple, generate_new() that picks a random free cell, position() accessor"],["grid.py","Defines Grid class: width, height, in_bounds(), to_screen_coords()"],["renderer.py","Defines Renderer class: draws grid, snake, food, score, gameâover message; uses curses window"],["input_handler.py","Defines InputHandler class: get_direction() translates key codes to direction tuples, prevents 180Â° reversal"]],"Task list":["main.py","game.py","snake.py","food.py","grid.py","renderer.py","input_handler.py"],"Full API spec":"","Shared Knowledge":"All state is stored in plain Python data structures (lists, tuples, ints). The game is a console application using the curses library; no external GUI frameworks are required. Each component is isolated to aid testing and future extension (e.g., adding levels or AI).","Anything UNCLEAR":"The specification mentions optional animations for movement and growth but does not detail the desired effect. In a console environment, a simple flash or brief delay can simulate animation. If a richer graphical animation is required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or a graphical window is expected."}

## Code Files



## Code to be Reviewed: main.py
```Code
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple, Optional

# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game state."""
        self.clear()

        # Draw border
        for x in range(grid.width + 2):
            self.window.addch(0, x, '#')
            self.window.addch(grid.height + 1, x, '#')
        for y in range(1, grid.height + 1):
            self.window.addch(y, 0, '#')
            self.window.addch(y, grid.width + 1, '#')

        # Draw food
        fx, fy = food.position
        sy, sx = grid.to_screen_coords((fx, fy))
        self.window.addch(sy + 1, sx + 1, '*')

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            cy, cx = grid.to_screen_coords((sx, sy))
            char = '@' if idx == 0 else 'O'
            self.window.addch(cy + 1, cx + 1, char)

        # Draw score
        score_text = f"Score: {score}"
        self.window.addstr(grid.height + 3, 0, score_text)

        # Draw game over message
        if game_over:
            msg = "GAME OVER! Press any key to exit."
            self.window.addstr(grid.height // 2, (grid.width - len(msg)) // 2, msg)

        self.window.refresh()


class InputHandler:
    """Translates key presses into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return a new direction based on the key, or keep current."""
        mapping = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        if new_dir != (-self.last_direction[0], -self.last_direction[1]):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per tick (10 FPS)

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (self.grid.width // 2, self.grid.height // 2)
        start_dir: Tuple[int, int] = (1, 0)  # Right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            start_time = time.time()

            # Handle input
            key = self.window.getch()
            if key != -1:
                new_dir = self.input_handler.get_direction(key)
                self.snake.set_direction(new_dir)

            # Update game state
            self.snake.move()

            # Collision checks
            if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
                self.game_over()
            else:
                # Check food consumption
                if self.snake.head() == self.food.position:
                    self.snake.grow()
                    self.score += 1
                    self.food.generate_new(self.grid, self.snake)

            # Render
            self.renderer.draw(
                self.grid,
                self.snake,
                self.food,
                self.score,
                self.game_over_flag,
            )

            # If game over, wait for key press to exit
            if self.game_over_flag:
                self.window.nodelay(False)
                self.window.getch()
                break

            # Maintain tick rate
            elapsed = time.time() - start_time
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Initialize and start the game."""
    game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)

```



# Format example 1
## Code Review: main.py
1. No, we should fix the logic of class A due to ...
2. ...
3. ...
4. No, function B is not implemented, ...
5. ...
6. ...

## Actions
1. Fix the `handle_events` method to update the game state only if a move is successful.
   ```python
   def handle_events(self):
       for event in pygame.event.get():
           if event.type == pygame.QUIT:
               return False
           if event.type == pygame.KEYDOWN:
               moved = False
               if event.key == pygame.K_UP:
                   moved = self.game.move('UP')
               elif event.key == pygame.K_DOWN:
                   moved = self.game.move('DOWN')
               elif event.key == pygame.K_LEFT:
                   moved = self.game.move('LEFT')
               elif event.key == pygame.K_RIGHT:
                   moved = self.game.move('RIGHT')
               if moved:
                   # Update the game state only if a move was successful
                   self.render()
       return True
   ```
2. Implement function B

## Code Review Result
LBTM

# Format example 2
## Code Review: main.py
1. Yes.
2. Yes.
3. Yes.
4. Yes.
5. Yes.
6. Yes.

## Actions
pass

## Code Review Result
LGTM



# Instruction: Based on the actual code situation, follow one of the "Format example". Return only 1 file under review.

## Code Review: Ordered List. Based on the "Code to be Reviewed", provide key, clear, concise, and specific answer. If any answer is no, explain how to fix it step by step.
1. Is the code implemented as per the requirements? If not, how to achieve it? Analyse it step by step.
2. Is the code logic completely correct? If there are errors, please indicate how to correct them.
3. Does the existing code follow the "Data structures and interfaces"?
4. Are all functions implemented? If there is no implementation, please indicate how to achieve it step by step.
5. Have all necessary pre-dependencies been imported? If not, indicate which ones need to be imported
6. Are methods from other files being reused correctly?

## Actions: Ordered List. Things that should be done after CR, such as implementing class A and function B

## Code Review Result: str. If the code doesn't have bugs, we don't need to rewrite it, so answer LGTM and stop. ONLY ANSWER LGTM/LBTM.
LGTM/LBTM






NOTICE
Role: You are a professional engineer; the main goal is to write google-style, elegant, modular, easy to read and maintain code
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## Design
{"Implementation approach":"We will build the game as a small, selfâcontained console application using the standard `curses` library for realâtime keyboard input and screen drawing. The core logic will be split into a handful of focused classes:\n\n* **Game** â owns the main loop, coordinates input, update and rendering, and manages the overall state (running, paused, gameâover).\n* **Snake** â stores the ordered list of grid coordinates that make up the snake, handles movement, growth and collision checks.\n* **Food** â keeps the current food position and can generate a new one that never overlaps the snake.\n* **Grid** â represents the 10Ã10 board, provides bounds checking and a helper to convert coordinates to screen positions.\n* **Renderer** â draws the grid, snake, food and UI elements (score, gameâover message) onto the curses window.\n* **InputHandler** â translates arrowâkey events into direction changes while preventing 180Â° reversals.\n\nThe game loop will run at a fixed tick rate (e.g. 10 frames per second). Each tick we:\n1. Poll for a key press.\n2. Update the snakeâs direction.\n3. Move the snake forward.\n4. Check for collisions (wall, self, food).\n5. Grow the snake and update the score if food is eaten.\n6. Render the updated state.\n\nThis separation keeps the code testable, readable and easily extensible (e.g. adding levels or AI). All state is kept in plain Python data structures (lists, tuples, ints) so no external dependencies are required beyond the standard library.\n\n","File list":["main.py","game.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -grid: Grid\n        -snake: Snake\n        -food: Food\n        -renderer: Renderer\n        -input_handler: InputHandler\n        -score: int\n        -running: bool\n        +__init__(window: curses.window)\n        +start() void\n        +handle_input() void\n        +update() void\n        +render() void\n        +game_over() void\n    }\n    class Snake {\n        -body: List[Tuple[int,int]]\n        -direction: Tuple[int,int]\n        +__init__(start_pos: Tuple[int,int], start_dir: Tuple[int,int])\n        +move() void\n        +grow() void\n        +set_direction(new_dir: Tuple[int,int]) void\n        +collides_with_self() bool\n        +collides_with_wall(grid: Grid) bool\n        +head() Tuple[int,int]\n    }\n    class Food {\n        -position: Tuple[int,int]\n        +__init__(grid: Grid, snake: Snake)\n        +generate_new(grid: Grid, snake: Snake) void\n        +position() Tuple[int,int]\n    }\n    class Grid {\n        -width: int\n        -height: int\n        +__init__(width: int, height: int)\n        +in_bounds(pos: Tuple[int,int]) bool\n        +to_screen_coords(pos: Tuple[int,int]) Tuple[int,int]\n    }\n    class Renderer {\n        -window: curses.window\n        +__init__(window: curses.window)\n        +draw(grid: Grid, snake: Snake, food: Food, score: int, game_over: bool) void\n        +clear() void\n    }\n    class InputHandler {\n        -last_direction: Tuple[int,int]\n        +__init__()\n        +get_direction(key: int) Tuple[int,int]\n    }\n    Game --> Snake\n    Game --> Food\n    Game --> Grid\n    Game --> Renderer\n    Game --> InputHandler\n    Snake --> Grid\n    Food --> Grid\n    Renderer --> Grid\n    Renderer --> Snake\n    Renderer --> Food\n","Program call flow":"\nsequenceDiagram\n    participant M as main\n    participant G as Game\n    participant I as InputHandler\n    participant S as Snake\n    participant F as Food\n    participant R as Renderer\n    participant Gd as Grid\n\n    M->>G: __init__(curses_window)\n    G->>Gd: __init__(10,10)\n    G->>S: __init__(center, RIGHT)\n    G->>F: __init__(Gd, S)\n    G->>R: __init__(curses_window)\n    G->>I: __init__()\n    G->>G: start()\n\n    loop every tick\n        G->>I: get_direction(key)\n        I->>G: set_direction\n        G->>S: move()\n        G->>S: collides_with_self() -> bool\n        alt collision\n            G->>G: game_over()\n            G->>R: draw(..., game_over=true)\n            G->>G: break loop\n        else\n            G->>F: position()\n            alt ate food\n                G->>S: grow()\n                G->>S: score++\n                G->>F: generate_new(Gd, S)\n            end\n            G->>R: draw(..., game_over=false)\n        end\n    end\n","Anything UNCLEAR":"The specification mentions \"optional animations for movement and growth\" but does not detail the desired effect. In a console environment, we can simulate a simple animation by briefly flashing the new head position or adding a short delay after growth. If more elaborate animations (e.g., smooth scrolling) are required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or if a graphical window is expected."}

## Task
{"Required Python packages":["No external packages required; uses only the standard library (curses, typing, etc.)"],"Required Other language third-party packages":["No thirdâparty dependencies required"],"Logic Analysis":[["main.py","Imports Game from game.py, initializes curses, creates Game instance, calls start()"],["game.py","Defines Game class: manages main loop, holds Grid, Snake, Food, Renderer, InputHandler, score, running flag; imports all component classes"],["snake.py","Defines Snake class: body list, direction tuple, move(), grow(), set_direction(), collides_with_self(), collides_with_wall(), head()"],["food.py","Defines Food class: position tuple, generate_new() that picks a random free cell, position() accessor"],["grid.py","Defines Grid class: width, height, in_bounds(), to_screen_coords()"],["renderer.py","Defines Renderer class: draws grid, snake, food, score, gameâover message; uses curses window"],["input_handler.py","Defines InputHandler class: get_direction() translates key codes to direction tuples, prevents 180Â° reversal"]],"Task list":["main.py","game.py","snake.py","food.py","grid.py","renderer.py","input_handler.py"],"Full API spec":"","Shared Knowledge":"All state is stored in plain Python data structures (lists, tuples, ints). The game is a console application using the curses library; no external GUI frameworks are required. Each component is isolated to aid testing and future extension (e.g., adding levels or AI).","Anything UNCLEAR":"The specification mentions optional animations for movement and growth but does not detail the desired effect. In a console environment, a simple flash or brief delay can simulate animation. If a richer graphical animation is required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or a graphical window is expected."}

## Legacy Code
```Code
----- main.py
```#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple, Optional

# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game state."""
        self.clear()

        # Draw border
        for x in range(grid.width + 2):
            self.window.addch(0, x, '#')
            self.window.addch(grid.height + 1, x, '#')
        for y in range(1, grid.height + 1):
            self.window.addch(y, 0, '#')
            self.window.addch(y, grid.width + 1, '#')

        # Draw food
        fx, fy = food.position
        sy, sx = grid.to_screen_coords((fx, fy))
        self.window.addch(sy + 1, sx + 1, '*')

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            cy, cx = grid.to_screen_coords((sx, sy))
            char = '@' if idx == 0 else 'O'
            self.window.addch(cy + 1, cx + 1, char)

        # Draw score
        score_text = f"Score: {score}"
        self.window.addstr(grid.height + 3, 0, score_text)

        # Draw game over message
        if game_over:
            msg = "GAME OVER! Press any key to exit."
            self.window.addstr(grid.height // 2, (grid.width - len(msg)) // 2, msg)

        self.window.refresh()


class InputHandler:
    """Translates key presses into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return a new direction based on the key, or keep current."""
        mapping = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        if new_dir != (-self.last_direction[0], -self.last_direction[1]):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per tick (10 FPS)

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (self.grid.width // 2, self.grid.height // 2)
        start_dir: Tuple[int, int] = (1, 0)  # Right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            start_time = time.time()

            # Handle input
            key = self.window.getch()
            if key != -1:
                new_dir = self.input_handler.get_direction(key)
                self.snake.set_direction(new_dir)

            # Update game state
            self.snake.move()

            # Collision checks
            if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
                self.game_over()
            else:
                # Check food consumption
                if self.snake.head() == self.food.position:
                    self.snake.grow()
                    self.score += 1
                    self.food.generate_new(self.grid, self.snake)

            # Render
            self.renderer.draw(
                self.grid,
                self.snake,
                self.food,
                self.score,
                self.game_over_flag,
            )

            # If game over, wait for key press to exit
            if self.game_over_flag:
                self.window.nodelay(False)
                self.window.getch()
                break

            # Maintain tick rate
            elapsed = time.time() - start_time
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Initialize and start the game."""
    game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)
```
```

## Debug logs
```text



```

## Bug Feedback logs
```text

```

# Format example
## Code: game.py
```python
## game.py
...
```

# Instruction: Based on the context, follow "Format example", write code.

## Code: game.py. Write code with triple quoto, based on the following attentions and context.
1. Only One file: do your best to implement THIS ONLY ONE FILE.
2. COMPLETE CODE: Your code will be part of the entire project, so please implement complete, reliable, reusable code snippets.
3. Set default value: If there is any setting, ALWAYS SET A DEFAULT VALUE, ALWAYS USE STRONG TYPE AND EXPLICIT VARIABLE. AVOID circular import.
4. Follow design: YOU MUST FOLLOW "Data structures and interfaces". DONT CHANGE ANY DESIGN. Do not use public member functions that do not exist in your design.
5. CAREFULLY CHECK THAT YOU DONT MISS ANY NECESSARY CLASS/FUNCTION IN THIS FILE.
6. Before using a external variable/module, make sure you import it first.
7. Write out EVERY CODE DETAIL, DON'T LEAVE TODO.






# System
Role: You are a professional software engineer, and your main task is to review and revise the code. You need to ensure that the code conforms to the google-style standards, is elegantly designed and modularized, easy to read and maintain.
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## System Design
{"Implementation approach":"We will build the game as a small, selfâcontained console application using the standard `curses` library for realâtime keyboard input and screen drawing. The core logic will be split into a handful of focused classes:\n\n* **Game** â owns the main loop, coordinates input, update and rendering, and manages the overall state (running, paused, gameâover).\n* **Snake** â stores the ordered list of grid coordinates that make up the snake, handles movement, growth and collision checks.\n* **Food** â keeps the current food position and can generate a new one that never overlaps the snake.\n* **Grid** â represents the 10Ã10 board, provides bounds checking and a helper to convert coordinates to screen positions.\n* **Renderer** â draws the grid, snake, food and UI elements (score, gameâover message) onto the curses window.\n* **InputHandler** â translates arrowâkey events into direction changes while preventing 180Â° reversals.\n\nThe game loop will run at a fixed tick rate (e.g. 10 frames per second). Each tick we:\n1. Poll for a key press.\n2. Update the snakeâs direction.\n3. Move the snake forward.\n4. Check for collisions (wall, self, food).\n5. Grow the snake and update the score if food is eaten.\n6. Render the updated state.\n\nThis separation keeps the code testable, readable and easily extensible (e.g. adding levels or AI). All state is kept in plain Python data structures (lists, tuples, ints) so no external dependencies are required beyond the standard library.\n\n","File list":["main.py","game.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -grid: Grid\n        -snake: Snake\n        -food: Food\n        -renderer: Renderer\n        -input_handler: InputHandler\n        -score: int\n        -running: bool\n        +__init__(window: curses.window)\n        +start() void\n        +handle_input() void\n        +update() void\n        +render() void\n        +game_over() void\n    }\n    class Snake {\n        -body: List[Tuple[int,int]]\n        -direction: Tuple[int,int]\n        +__init__(start_pos: Tuple[int,int], start_dir: Tuple[int,int])\n        +move() void\n        +grow() void\n        +set_direction(new_dir: Tuple[int,int]) void\n        +collides_with_self() bool\n        +collides_with_wall(grid: Grid) bool\n        +head() Tuple[int,int]\n    }\n    class Food {\n        -position: Tuple[int,int]\n        +__init__(grid: Grid, snake: Snake)\n        +generate_new(grid: Grid, snake: Snake) void\n        +position() Tuple[int,int]\n    }\n    class Grid {\n        -width: int\n        -height: int\n        +__init__(width: int, height: int)\n        +in_bounds(pos: Tuple[int,int]) bool\n        +to_screen_coords(pos: Tuple[int,int]) Tuple[int,int]\n    }\n    class Renderer {\n        -window: curses.window\n        +__init__(window: curses.window)\n        +draw(grid: Grid, snake: Snake, food: Food, score: int, game_over: bool) void\n        +clear() void\n    }\n    class InputHandler {\n        -last_direction: Tuple[int,int]\n        +__init__()\n        +get_direction(key: int) Tuple[int,int]\n    }\n    Game --> Snake\n    Game --> Food\n    Game --> Grid\n    Game --> Renderer\n    Game --> InputHandler\n    Snake --> Grid\n    Food --> Grid\n    Renderer --> Grid\n    Renderer --> Snake\n    Renderer --> Food\n","Program call flow":"\nsequenceDiagram\n    participant M as main\n    participant G as Game\n    participant I as InputHandler\n    participant S as Snake\n    participant F as Food\n    participant R as Renderer\n    participant Gd as Grid\n\n    M->>G: __init__(curses_window)\n    G->>Gd: __init__(10,10)\n    G->>S: __init__(center, RIGHT)\n    G->>F: __init__(Gd, S)\n    G->>R: __init__(curses_window)\n    G->>I: __init__()\n    G->>G: start()\n\n    loop every tick\n        G->>I: get_direction(key)\n        I->>G: set_direction\n        G->>S: move()\n        G->>S: collides_with_self() -> bool\n        alt collision\n            G->>G: game_over()\n            G->>R: draw(..., game_over=true)\n            G->>G: break loop\n        else\n            G->>F: position()\n            alt ate food\n                G->>S: grow()\n                G->>S: score++\n                G->>F: generate_new(Gd, S)\n            end\n            G->>R: draw(..., game_over=false)\n        end\n    end\n","Anything UNCLEAR":"The specification mentions \"optional animations for movement and growth\" but does not detail the desired effect. In a console environment, we can simulate a simple animation by briefly flashing the new head position or adding a short delay after growth. If more elaborate animations (e.g., smooth scrolling) are required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or if a graphical window is expected."}

## Task
{"Required Python packages":["No external packages required; uses only the standard library (curses, typing, etc.)"],"Required Other language third-party packages":["No thirdâparty dependencies required"],"Logic Analysis":[["main.py","Imports Game from game.py, initializes curses, creates Game instance, calls start()"],["game.py","Defines Game class: manages main loop, holds Grid, Snake, Food, Renderer, InputHandler, score, running flag; imports all component classes"],["snake.py","Defines Snake class: body list, direction tuple, move(), grow(), set_direction(), collides_with_self(), collides_with_wall(), head()"],["food.py","Defines Food class: position tuple, generate_new() that picks a random free cell, position() accessor"],["grid.py","Defines Grid class: width, height, in_bounds(), to_screen_coords()"],["renderer.py","Defines Renderer class: draws grid, snake, food, score, gameâover message; uses curses window"],["input_handler.py","Defines InputHandler class: get_direction() translates key codes to direction tuples, prevents 180Â° reversal"]],"Task list":["main.py","game.py","snake.py","food.py","grid.py","renderer.py","input_handler.py"],"Full API spec":"","Shared Knowledge":"All state is stored in plain Python data structures (lists, tuples, ints). The game is a console application using the curses library; no external GUI frameworks are required. Each component is isolated to aid testing and future extension (e.g., adding levels or AI).","Anything UNCLEAR":"The specification mentions optional animations for movement and growth but does not detail the desired effect. In a console environment, a simple flash or brief delay can simulate animation. If a richer graphical animation is required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or a graphical window is expected."}

## Code Files
----- main.py
```#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple, Optional

# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game state."""
        self.clear()

        # Draw border
        for x in range(grid.width + 2):
            self.window.addch(0, x, '#')
            self.window.addch(grid.height + 1, x, '#')
        for y in range(1, grid.height + 1):
            self.window.addch(y, 0, '#')
            self.window.addch(y, grid.width + 1, '#')

        # Draw food
        fx, fy = food.position
        sy, sx = grid.to_screen_coords((fx, fy))
        self.window.addch(sy + 1, sx + 1, '*')

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            cy, cx = grid.to_screen_coords((sx, sy))
            char = '@' if idx == 0 else 'O'
            self.window.addch(cy + 1, cx + 1, char)

        # Draw score
        score_text = f"Score: {score}"
        self.window.addstr(grid.height + 3, 0, score_text)

        # Draw game over message
        if game_over:
            msg = "GAME OVER! Press any key to exit."
            self.window.addstr(grid.height // 2, (grid.width - len(msg)) // 2, msg)

        self.window.refresh()


class InputHandler:
    """Translates key presses into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return a new direction based on the key, or keep current."""
        mapping = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        if new_dir != (-self.last_direction[0], -self.last_direction[1]):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per tick (10 FPS)

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (self.grid.width // 2, self.grid.height // 2)
        start_dir: Tuple[int, int] = (1, 0)  # Right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            start_time = time.time()

            # Handle input
            key = self.window.getch()
            if key != -1:
                new_dir = self.input_handler.get_direction(key)
                self.snake.set_direction(new_dir)

            # Update game state
            self.snake.move()

            # Collision checks
            if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
                self.game_over()
            else:
                # Check food consumption
                if self.snake.head() == self.food.position:
                    self.snake.grow()
                    self.score += 1
                    self.food.generate_new(self.grid, self.snake)

            # Render
            self.renderer.draw(
                self.grid,
                self.snake,
                self.food,
                self.score,
                self.game_over_flag,
            )

            # If game over, wait for key press to exit
            if self.game_over_flag:
                self.window.nodelay(False)
                self.window.getch()
                break

            # Maintain tick rate
            elapsed = time.time() - start_time
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Initialize and start the game."""
    game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)
```


## Code to be Reviewed: game.py
```Code
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple


# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game screen."""
        self.clear()

        # Draw border
        for x in range(grid.width):
            self.window.addch(0, x, curses.ACS_HLINE)
            self.window.addch(grid.height + 1, x, curses.ACS_HLINE)
        for y in range(grid.height + 2):
            self.window.addch(y, 0, curses.ACS_VLINE)
            self.window.addch(y, grid.width + 1, curses.ACS_VLINE)
        self.window.addch(0, 0, curses.ACS_ULCORNER)
        self.window.addch(0, grid.width + 1, curses.ACS_URCORNER)
        self.window.addch(grid.height + 1, 0, curses.ACS_LLCORNER)
        self.window.addch(grid.height + 1, grid.width + 1, curses.ACS_LRCORNER)

        # Draw food
        fx, fy = food.position
        fy_screen, fx_screen = grid.to_screen_coords((fx, fy))
        self.window.addch(fy_screen + 1, fx_screen + 1, curses.ACS_PI)

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            sy_screen, sx_screen = grid.to_screen_coords((sx, sy))
            sy_screen += 1
            sx_screen += 1
            char: str = "@" if idx == 0 else "O"
            self.window.addch(sy_screen, sx_screen, char)

        # Draw score
        score_y: int = grid.height + 3
        score_x: int = 0
        score_text: str = f"Score: {score}"
        self.window.addstr(score_y, score_x, score_text)

        # Draw game over message if needed
        if game_over:
            msg: str = "GAME OVER! Press any key to exit."
            msg_y: int = grid.height // 2 + 1
            msg_x: int = (grid.width - len(msg)) // 2 + 1
            self.window.addstr(msg_y, msg_x, msg)

        self.window.refresh()


class InputHandler:
    """Processes user input and translates it into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default to moving right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return the new direction based on the pressed key."""
        mapping: dict[int, Tuple[int, int]] = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir: Tuple[int, int] = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        cur_dx, cur_dy = self.last_direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per frame

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window

        # Initialize components
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (
            self.grid.width // 2,
            self.grid.height // 2,
        )
        start_dir: Tuple[int, int] = (1, 0)  # Moving right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()

        # Game state
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    # ------------------------------------------------------------------
    # Game loop helpers
    # ------------------------------------------------------------------

    def handle_input(self) -> None:
        """Read user input and update snake direction."""
        key: int = self.window.getch()
        if key != -1:
            new_dir: Tuple[int, int] = self.input_handler.get_direction(key)
            self.snake.set_direction(new_dir)

    def update(self) -> None:
        """Advance game state: move snake, check collisions, handle food."""
        self.snake.move()

        # Collision detection
        if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
            self.game_over()
            return

        # Food consumption
        if self.snake.head() == self.food.position:
            self.snake.grow()
            self.score += 1
            self.food.generate_new(self.grid, self.snake)

    def render(self) -> None:
        """Render the current game state."""
        self.renderer.draw(
            self.grid,
            self.snake,
            self.food,
            self.score,
            self.game_over_flag,
        )

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True

    # ------------------------------------------------------------------
    # Main loop
    # ------------------------------------------------------------------

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            frame_start: float = time.time()

            self.handle_input()
            self.update()
            self.render()

            if self.game_over_flag:
                # Wait for a key press before exiting
                self.window.nodelay(False)
                self.window.getch()
                break

            elapsed: float = time.time() - frame_start
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Curses wrapper entry point."""
    game: Game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)

```



# Format example 1
## Code Review: game.py
1. No, we should fix the logic of class A due to ...
2. ...
3. ...
4. No, function B is not implemented, ...
5. ...
6. ...

## Actions
1. Fix the `handle_events` method to update the game state only if a move is successful.
   ```python
   def handle_events(self):
       for event in pygame.event.get():
           if event.type == pygame.QUIT:
               return False
           if event.type == pygame.KEYDOWN:
               moved = False
               if event.key == pygame.K_UP:
                   moved = self.game.move('UP')
               elif event.key == pygame.K_DOWN:
                   moved = self.game.move('DOWN')
               elif event.key == pygame.K_LEFT:
                   moved = self.game.move('LEFT')
               elif event.key == pygame.K_RIGHT:
                   moved = self.game.move('RIGHT')
               if moved:
                   # Update the game state only if a move was successful
                   self.render()
       return True
   ```
2. Implement function B

## Code Review Result
LBTM

# Format example 2
## Code Review: game.py
1. Yes.
2. Yes.
3. Yes.
4. Yes.
5. Yes.
6. Yes.

## Actions
pass

## Code Review Result
LGTM



# Instruction: Based on the actual code situation, follow one of the "Format example". Return only 1 file under review.

## Code Review: Ordered List. Based on the "Code to be Reviewed", provide key, clear, concise, and specific answer. If any answer is no, explain how to fix it step by step.
1. Is the code implemented as per the requirements? If not, how to achieve it? Analyse it step by step.
2. Is the code logic completely correct? If there are errors, please indicate how to correct them.
3. Does the existing code follow the "Data structures and interfaces"?
4. Are all functions implemented? If there is no implementation, please indicate how to achieve it step by step.
5. Have all necessary pre-dependencies been imported? If not, indicate which ones need to be imported
6. Are methods from other files being reused correctly?

## Actions: Ordered List. Things that should be done after CR, such as implementing class A and function B

## Code Review Result: str. If the code doesn't have bugs, we don't need to rewrite it, so answer LGTM and stop. ONLY ANSWER LGTM/LBTM.
LGTM/LBTM






# System
Role: You are a professional software engineer, and your main task is to review and revise the code. You need to ensure that the code conforms to the google-style standards, is elegantly designed and modularized, easy to read and maintain.
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## System Design
{"Implementation approach":"We will build the game as a small, selfâcontained console application using the standard `curses` library for realâtime keyboard input and screen drawing. The core logic will be split into a handful of focused classes:\n\n* **Game** â owns the main loop, coordinates input, update and rendering, and manages the overall state (running, paused, gameâover).\n* **Snake** â stores the ordered list of grid coordinates that make up the snake, handles movement, growth and collision checks.\n* **Food** â keeps the current food position and can generate a new one that never overlaps the snake.\n* **Grid** â represents the 10Ã10 board, provides bounds checking and a helper to convert coordinates to screen positions.\n* **Renderer** â draws the grid, snake, food and UI elements (score, gameâover message) onto the curses window.\n* **InputHandler** â translates arrowâkey events into direction changes while preventing 180Â° reversals.\n\nThe game loop will run at a fixed tick rate (e.g. 10 frames per second). Each tick we:\n1. Poll for a key press.\n2. Update the snakeâs direction.\n3. Move the snake forward.\n4. Check for collisions (wall, self, food).\n5. Grow the snake and update the score if food is eaten.\n6. Render the updated state.\n\nThis separation keeps the code testable, readable and easily extensible (e.g. adding levels or AI). All state is kept in plain Python data structures (lists, tuples, ints) so no external dependencies are required beyond the standard library.\n\n","File list":["main.py","game.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -grid: Grid\n        -snake: Snake\n        -food: Food\n        -renderer: Renderer\n        -input_handler: InputHandler\n        -score: int\n        -running: bool\n        +__init__(window: curses.window)\n        +start() void\n        +handle_input() void\n        +update() void\n        +render() void\n        +game_over() void\n    }\n    class Snake {\n        -body: List[Tuple[int,int]]\n        -direction: Tuple[int,int]\n        +__init__(start_pos: Tuple[int,int], start_dir: Tuple[int,int])\n        +move() void\n        +grow() void\n        +set_direction(new_dir: Tuple[int,int]) void\n        +collides_with_self() bool\n        +collides_with_wall(grid: Grid) bool\n        +head() Tuple[int,int]\n    }\n    class Food {\n        -position: Tuple[int,int]\n        +__init__(grid: Grid, snake: Snake)\n        +generate_new(grid: Grid, snake: Snake) void\n        +position() Tuple[int,int]\n    }\n    class Grid {\n        -width: int\n        -height: int\n        +__init__(width: int, height: int)\n        +in_bounds(pos: Tuple[int,int]) bool\n        +to_screen_coords(pos: Tuple[int,int]) Tuple[int,int]\n    }\n    class Renderer {\n        -window: curses.window\n        +__init__(window: curses.window)\n        +draw(grid: Grid, snake: Snake, food: Food, score: int, game_over: bool) void\n        +clear() void\n    }\n    class InputHandler {\n        -last_direction: Tuple[int,int]\n        +__init__()\n        +get_direction(key: int) Tuple[int,int]\n    }\n    Game --> Snake\n    Game --> Food\n    Game --> Grid\n    Game --> Renderer\n    Game --> InputHandler\n    Snake --> Grid\n    Food --> Grid\n    Renderer --> Grid\n    Renderer --> Snake\n    Renderer --> Food\n","Program call flow":"\nsequenceDiagram\n    participant M as main\n    participant G as Game\n    participant I as InputHandler\n    participant S as Snake\n    participant F as Food\n    participant R as Renderer\n    participant Gd as Grid\n\n    M->>G: __init__(curses_window)\n    G->>Gd: __init__(10,10)\n    G->>S: __init__(center, RIGHT)\n    G->>F: __init__(Gd, S)\n    G->>R: __init__(curses_window)\n    G->>I: __init__()\n    G->>G: start()\n\n    loop every tick\n        G->>I: get_direction(key)\n        I->>G: set_direction\n        G->>S: move()\n        G->>S: collides_with_self() -> bool\n        alt collision\n            G->>G: game_over()\n            G->>R: draw(..., game_over=true)\n            G->>G: break loop\n        else\n            G->>F: position()\n            alt ate food\n                G->>S: grow()\n                G->>S: score++\n                G->>F: generate_new(Gd, S)\n            end\n            G->>R: draw(..., game_over=false)\n        end\n    end\n","Anything UNCLEAR":"The specification mentions \"optional animations for movement and growth\" but does not detail the desired effect. In a console environment, we can simulate a simple animation by briefly flashing the new head position or adding a short delay after growth. If more elaborate animations (e.g., smooth scrolling) are required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or if a graphical window is expected."}

## Task
{"Required Python packages":["No external packages required; uses only the standard library (curses, typing, etc.)"],"Required Other language third-party packages":["No thirdâparty dependencies required"],"Logic Analysis":[["main.py","Imports Game from game.py, initializes curses, creates Game instance, calls start()"],["game.py","Defines Game class: manages main loop, holds Grid, Snake, Food, Renderer, InputHandler, score, running flag; imports all component classes"],["snake.py","Defines Snake class: body list, direction tuple, move(), grow(), set_direction(), collides_with_self(), collides_with_wall(), head()"],["food.py","Defines Food class: position tuple, generate_new() that picks a random free cell, position() accessor"],["grid.py","Defines Grid class: width, height, in_bounds(), to_screen_coords()"],["renderer.py","Defines Renderer class: draws grid, snake, food, score, gameâover message; uses curses window"],["input_handler.py","Defines InputHandler class: get_direction() translates key codes to direction tuples, prevents 180Â° reversal"]],"Task list":["main.py","game.py","snake.py","food.py","grid.py","renderer.py","input_handler.py"],"Full API spec":"","Shared Knowledge":"All state is stored in plain Python data structures (lists, tuples, ints). The game is a console application using the curses library; no external GUI frameworks are required. Each component is isolated to aid testing and future extension (e.g., adding levels or AI).","Anything UNCLEAR":"The specification mentions optional animations for movement and growth but does not detail the desired effect. In a console environment, a simple flash or brief delay can simulate animation. If a richer graphical animation is required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or a graphical window is expected."}

## Code Files
----- main.py
```#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple, Optional

# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game state."""
        self.clear()

        # Draw border
        for x in range(grid.width + 2):
            self.window.addch(0, x, '#')
            self.window.addch(grid.height + 1, x, '#')
        for y in range(1, grid.height + 1):
            self.window.addch(y, 0, '#')
            self.window.addch(y, grid.width + 1, '#')

        # Draw food
        fx, fy = food.position
        sy, sx = grid.to_screen_coords((fx, fy))
        self.window.addch(sy + 1, sx + 1, '*')

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            cy, cx = grid.to_screen_coords((sx, sy))
            char = '@' if idx == 0 else 'O'
            self.window.addch(cy + 1, cx + 1, char)

        # Draw score
        score_text = f"Score: {score}"
        self.window.addstr(grid.height + 3, 0, score_text)

        # Draw game over message
        if game_over:
            msg = "GAME OVER! Press any key to exit."
            self.window.addstr(grid.height // 2, (grid.width - len(msg)) // 2, msg)

        self.window.refresh()


class InputHandler:
    """Translates key presses into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return a new direction based on the key, or keep current."""
        mapping = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        if new_dir != (-self.last_direction[0], -self.last_direction[1]):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per tick (10 FPS)

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (self.grid.width // 2, self.grid.height // 2)
        start_dir: Tuple[int, int] = (1, 0)  # Right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            start_time = time.time()

            # Handle input
            key = self.window.getch()
            if key != -1:
                new_dir = self.input_handler.get_direction(key)
                self.snake.set_direction(new_dir)

            # Update game state
            self.snake.move()

            # Collision checks
            if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
                self.game_over()
            else:
                # Check food consumption
                if self.snake.head() == self.food.position:
                    self.snake.grow()
                    self.score += 1
                    self.food.generate_new(self.grid, self.snake)

            # Render
            self.renderer.draw(
                self.grid,
                self.snake,
                self.food,
                self.score,
                self.game_over_flag,
            )

            # If game over, wait for key press to exit
            if self.game_over_flag:
                self.window.nodelay(False)
                self.window.getch()
                break

            # Maintain tick rate
            elapsed = time.time() - start_time
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Initialize and start the game."""
    game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)
```


## Code to be Reviewed: game.py
```Code
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple


# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game screen."""
        self.clear()

        # Draw border
        for x in range(grid.width):
            self.window.addch(0, x, curses.ACS_HLINE)
            self.window.addch(grid.height + 1, x, curses.ACS_HLINE)
        for y in range(grid.height + 2):
            self.window.addch(y, 0, curses.ACS_VLINE)
            self.window.addch(y, grid.width + 1, curses.ACS_VLINE)
        self.window.addch(0, 0, curses.ACS_ULCORNER)
        self.window.addch(0, grid.width + 1, curses.ACS_URCORNER)
        self.window.addch(grid.height + 1, 0, curses.ACS_LLCORNER)
        self.window.addch(grid.height + 1, grid.width + 1, curses.ACS_LRCORNER)

        # Draw food
        fx, fy = food.position
        fy_screen, fx_screen = grid.to_screen_coords((fx, fy))
        self.window.addch(fy_screen + 1, fx_screen + 1, curses.ACS_PI)

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            sy_screen, sx_screen = grid.to_screen_coords((sx, sy))
            sy_screen += 1
            sx_screen += 1
            char: str = "@" if idx == 0 else "O"
            self.window.addch(sy_screen, sx_screen, char)

        # Draw score
        score_y: int = grid.height + 3
        score_x: int = 0
        score_text: str = f"Score: {score}"
        self.window.addstr(score_y, score_x, score_text)

        # Draw game over message if needed
        if game_over:
            msg: str = "GAME OVER! Press any key to exit."
            msg_y: int = grid.height // 2 + 1
            msg_x: int = (grid.width - len(msg)) // 2 + 1
            self.window.addstr(msg_y, msg_x, msg)

        self.window.refresh()


class InputHandler:
    """Processes user input and translates it into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default to moving right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return the new direction based on the pressed key."""
        mapping: dict[int, Tuple[int, int]] = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir: Tuple[int, int] = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        cur_dx, cur_dy = self.last_direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per frame

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window

        # Initialize components
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (
            self.grid.width // 2,
            self.grid.height // 2,
        )
        start_dir: Tuple[int, int] = (1, 0)  # Moving right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()

        # Game state
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    # ------------------------------------------------------------------
    # Game loop helpers
    # ------------------------------------------------------------------

    def handle_input(self) -> None:
        """Read user input and update snake direction."""
        key: int = self.window.getch()
        if key != -1:
            new_dir: Tuple[int, int] = self.input_handler.get_direction(key)
            self.snake.set_direction(new_dir)

    def update(self) -> None:
        """Advance game state: move snake, check collisions, handle food."""
        self.snake.move()

        # Collision detection
        if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
            self.game_over()
            return

        # Food consumption
        if self.snake.head() == self.food.position:
            self.snake.grow()
            self.score += 1
            self.food.generate_new(self.grid, self.snake)

    def render(self) -> None:
        """Render the current game state."""
        self.renderer.draw(
            self.grid,
            self.snake,
            self.food,
            self.score,
            self.game_over_flag,
        )

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True

    # ------------------------------------------------------------------
    # Main loop
    # ------------------------------------------------------------------

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            frame_start: float = time.time()

            self.handle_input()
            self.update()
            self.render()

            if self.game_over_flag:
                # Wait for a key press before exiting
                self.window.nodelay(False)
                self.window.getch()
                break

            elapsed: float = time.time() - frame_start
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Curses wrapper entry point."""
    game: Game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)

```

**Answer: The code does not pass the tests.**

# Instruction: rewrite code based on the Code Review and Actions
## Rewrite Code: CodeBlock. If it still has some bugs, rewrite game.py with triple quotes. Do your utmost to optimize THIS SINGLE FILE. Return all completed codes and prohibit the return of unfinished codes.
```Code
## game.py
...
```





# System
Role: You are a professional software engineer, and your main task is to review and revise the code. You need to ensure that the code conforms to the google-style standards, is elegantly designed and modularized, easy to read and maintain.
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## System Design
{"Implementation approach":"We will build the game as a small, selfâcontained console application using the standard `curses` library for realâtime keyboard input and screen drawing. The core logic will be split into a handful of focused classes:\n\n* **Game** â owns the main loop, coordinates input, update and rendering, and manages the overall state (running, paused, gameâover).\n* **Snake** â stores the ordered list of grid coordinates that make up the snake, handles movement, growth and collision checks.\n* **Food** â keeps the current food position and can generate a new one that never overlaps the snake.\n* **Grid** â represents the 10Ã10 board, provides bounds checking and a helper to convert coordinates to screen positions.\n* **Renderer** â draws the grid, snake, food and UI elements (score, gameâover message) onto the curses window.\n* **InputHandler** â translates arrowâkey events into direction changes while preventing 180Â° reversals.\n\nThe game loop will run at a fixed tick rate (e.g. 10 frames per second). Each tick we:\n1. Poll for a key press.\n2. Update the snakeâs direction.\n3. Move the snake forward.\n4. Check for collisions (wall, self, food).\n5. Grow the snake and update the score if food is eaten.\n6. Render the updated state.\n\nThis separation keeps the code testable, readable and easily extensible (e.g. adding levels or AI). All state is kept in plain Python data structures (lists, tuples, ints) so no external dependencies are required beyond the standard library.\n\n","File list":["main.py","game.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -grid: Grid\n        -snake: Snake\n        -food: Food\n        -renderer: Renderer\n        -input_handler: InputHandler\n        -score: int\n        -running: bool\n        +__init__(window: curses.window)\n        +start() void\n        +handle_input() void\n        +update() void\n        +render() void\n        +game_over() void\n    }\n    class Snake {\n        -body: List[Tuple[int,int]]\n        -direction: Tuple[int,int]\n        +__init__(start_pos: Tuple[int,int], start_dir: Tuple[int,int])\n        +move() void\n        +grow() void\n        +set_direction(new_dir: Tuple[int,int]) void\n        +collides_with_self() bool\n        +collides_with_wall(grid: Grid) bool\n        +head() Tuple[int,int]\n    }\n    class Food {\n        -position: Tuple[int,int]\n        +__init__(grid: Grid, snake: Snake)\n        +generate_new(grid: Grid, snake: Snake) void\n        +position() Tuple[int,int]\n    }\n    class Grid {\n        -width: int\n        -height: int\n        +__init__(width: int, height: int)\n        +in_bounds(pos: Tuple[int,int]) bool\n        +to_screen_coords(pos: Tuple[int,int]) Tuple[int,int]\n    }\n    class Renderer {\n        -window: curses.window\n        +__init__(window: curses.window)\n        +draw(grid: Grid, snake: Snake, food: Food, score: int, game_over: bool) void\n        +clear() void\n    }\n    class InputHandler {\n        -last_direction: Tuple[int,int]\n        +__init__()\n        +get_direction(key: int) Tuple[int,int]\n    }\n    Game --> Snake\n    Game --> Food\n    Game --> Grid\n    Game --> Renderer\n    Game --> InputHandler\n    Snake --> Grid\n    Food --> Grid\n    Renderer --> Grid\n    Renderer --> Snake\n    Renderer --> Food\n","Program call flow":"\nsequenceDiagram\n    participant M as main\n    participant G as Game\n    participant I as InputHandler\n    participant S as Snake\n    participant F as Food\n    participant R as Renderer\n    participant Gd as Grid\n\n    M->>G: __init__(curses_window)\n    G->>Gd: __init__(10,10)\n    G->>S: __init__(center, RIGHT)\n    G->>F: __init__(Gd, S)\n    G->>R: __init__(curses_window)\n    G->>I: __init__()\n    G->>G: start()\n\n    loop every tick\n        G->>I: get_direction(key)\n        I->>G: set_direction\n        G->>S: move()\n        G->>S: collides_with_self() -> bool\n        alt collision\n            G->>G: game_over()\n            G->>R: draw(..., game_over=true)\n            G->>G: break loop\n        else\n            G->>F: position()\n            alt ate food\n                G->>S: grow()\n                G->>S: score++\n                G->>F: generate_new(Gd, S)\n            end\n            G->>R: draw(..., game_over=false)\n        end\n    end\n","Anything UNCLEAR":"The specification mentions \"optional animations for movement and growth\" but does not detail the desired effect. In a console environment, we can simulate a simple animation by briefly flashing the new head position or adding a short delay after growth. If more elaborate animations (e.g., smooth scrolling) are required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or if a graphical window is expected."}

## Task
{"Required Python packages":["No external packages required; uses only the standard library (curses, typing, etc.)"],"Required Other language third-party packages":["No thirdâparty dependencies required"],"Logic Analysis":[["main.py","Imports Game from game.py, initializes curses, creates Game instance, calls start()"],["game.py","Defines Game class: manages main loop, holds Grid, Snake, Food, Renderer, InputHandler, score, running flag; imports all component classes"],["snake.py","Defines Snake class: body list, direction tuple, move(), grow(), set_direction(), collides_with_self(), collides_with_wall(), head()"],["food.py","Defines Food class: position tuple, generate_new() that picks a random free cell, position() accessor"],["grid.py","Defines Grid class: width, height, in_bounds(), to_screen_coords()"],["renderer.py","Defines Renderer class: draws grid, snake, food, score, gameâover message; uses curses window"],["input_handler.py","Defines InputHandler class: get_direction() translates key codes to direction tuples, prevents 180Â° reversal"]],"Task list":["main.py","game.py","snake.py","food.py","grid.py","renderer.py","input_handler.py"],"Full API spec":"","Shared Knowledge":"All state is stored in plain Python data structures (lists, tuples, ints). The game is a console application using the curses library; no external GUI frameworks are required. Each component is isolated to aid testing and future extension (e.g., adding levels or AI).","Anything UNCLEAR":"The specification mentions optional animations for movement and growth but does not detail the desired effect. In a console environment, a simple flash or brief delay can simulate animation. If a richer graphical animation is required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or a graphical window is expected."}

## Code Files
----- main.py
```#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple, Optional

# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game state."""
        self.clear()

        # Draw border
        for x in range(grid.width + 2):
            self.window.addch(0, x, '#')
            self.window.addch(grid.height + 1, x, '#')
        for y in range(1, grid.height + 1):
            self.window.addch(y, 0, '#')
            self.window.addch(y, grid.width + 1, '#')

        # Draw food
        fx, fy = food.position
        sy, sx = grid.to_screen_coords((fx, fy))
        self.window.addch(sy + 1, sx + 1, '*')

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            cy, cx = grid.to_screen_coords((sx, sy))
            char = '@' if idx == 0 else 'O'
            self.window.addch(cy + 1, cx + 1, char)

        # Draw score
        score_text = f"Score: {score}"
        self.window.addstr(grid.height + 3, 0, score_text)

        # Draw game over message
        if game_over:
            msg = "GAME OVER! Press any key to exit."
            self.window.addstr(grid.height // 2, (grid.width - len(msg)) // 2, msg)

        self.window.refresh()


class InputHandler:
    """Translates key presses into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return a new direction based on the key, or keep current."""
        mapping = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        if new_dir != (-self.last_direction[0], -self.last_direction[1]):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per tick (10 FPS)

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (self.grid.width // 2, self.grid.height // 2)
        start_dir: Tuple[int, int] = (1, 0)  # Right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            start_time = time.time()

            # Handle input
            key = self.window.getch()
            if key != -1:
                new_dir = self.input_handler.get_direction(key)
                self.snake.set_direction(new_dir)

            # Update game state
            self.snake.move()

            # Collision checks
            if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
                self.game_over()
            else:
                # Check food consumption
                if self.snake.head() == self.food.position:
                    self.snake.grow()
                    self.score += 1
                    self.food.generate_new(self.grid, self.snake)

            # Render
            self.renderer.draw(
                self.grid,
                self.snake,
                self.food,
                self.score,
                self.game_over_flag,
            )

            # If game over, wait for key press to exit
            if self.game_over_flag:
                self.window.nodelay(False)
                self.window.getch()
                break

            # Maintain tick rate
            elapsed = time.time() - start_time
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Initialize and start the game."""
    game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)
```


## Code to be Reviewed: game.py
```Code
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple


# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game screen."""
        self.clear()

        # Draw border
        for x in range(grid.width):
            self.window.addch(0, x, curses.ACS_HLINE)
            self.window.addch(grid.height + 1, x, curses.ACS_HLINE)
        for y in range(grid.height + 2):
            self.window.addch(y, 0, curses.ACS_VLINE)
            self.window.addch(y, grid.width + 1, curses.ACS_VLINE)
        self.window.addch(0, 0, curses.ACS_ULCORNER)
        self.window.addch(0, grid.width + 1, curses.ACS_URCORNER)
        self.window.addch(grid.height + 1, 0, curses.ACS_LLCORNER)
        self.window.addch(grid.height + 1, grid.width + 1, curses.ACS_LRCORNER)

        # Draw food
        fx, fy = food.position
        fy_screen, fx_screen = grid.to_screen_coords((fx, fy))
        self.window.addch(fy_screen + 1, fx_screen + 1, curses.ACS_PI)

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            sy_screen, sx_screen = grid.to_screen_coords((sx, sy))
            sy_screen += 1
            sx_screen += 1
            char: str = "@" if idx == 0 else "O"
            self.window.addch(sy_screen, sx_screen, char)

        # Draw score
        score_y: int = grid.height + 3
        score_x: int = 0
        score_text: str = f"Score: {score}"
        self.window.addstr(score_y, score_x, score_text)

        # Draw game over message if needed
        if game_over:
            msg: str = "GAME OVER! Press any key to exit."
            msg_y: int = grid.height // 2 + 1
            msg_x: int = (grid.width - len(msg)) // 2 + 1
            self.window.addstr(msg_y, msg_x, msg)

        self.window.refresh()


class InputHandler:
    """Processes user input and translates it into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default to moving right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return the new direction based on the pressed key."""
        mapping: dict[int, Tuple[int, int]] = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir: Tuple[int, int] = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        cur_dx, cur_dy = self.last_direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per frame

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window

        # Initialize components
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (
            self.grid.width // 2,
            self.grid.height // 2,
        )
        start_dir: Tuple[int, int] = (1, 0)  # Moving right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()

        # Game state
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    # ------------------------------------------------------------------
    # Game loop helpers
    # ------------------------------------------------------------------

    def handle_input(self) -> None:
        """Read user input and update snake direction."""
        key: int = self.window.getch()
        if key != -1:
            new_dir: Tuple[int, int] = self.input_handler.get_direction(key)
            self.snake.set_direction(new_dir)

    def update(self) -> None:
        """Advance game state: move snake, check collisions, handle food."""
        self.snake.move()

        # Collision detection
        if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
            self.game_over()
            return

        # Food consumption
        if self.snake.head() == self.food.position:
            self.snake.grow()
            self.score += 1
            self.food.generate_new(self.grid, self.snake)

    def render(self) -> None:
        """Render the current game state."""
        self.renderer.draw(
            self.grid,
            self.snake,
            self.food,
            self.score,
            self.game_over_flag,
        )

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True

    # ------------------------------------------------------------------
    # Main loop
    # ------------------------------------------------------------------

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            frame_start: float = time.time()

            self.handle_input()
            self.update()
            self.render()

            if self.game_over_flag:
                # Wait for a key press before exiting
                self.window.nodelay(False)
                self.window.getch()
                break

            elapsed: float = time.time() - frame_start
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Curses wrapper entry point."""
    game: Game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)

```



# Format example 1
## Code Review: game.py
1. No, we should fix the logic of class A due to ...
2. ...
3. ...
4. No, function B is not implemented, ...
5. ...
6. ...

## Actions
1. Fix the `handle_events` method to update the game state only if a move is successful.
   ```python
   def handle_events(self):
       for event in pygame.event.get():
           if event.type == pygame.QUIT:
               return False
           if event.type == pygame.KEYDOWN:
               moved = False
               if event.key == pygame.K_UP:
                   moved = self.game.move('UP')
               elif event.key == pygame.K_DOWN:
                   moved = self.game.move('DOWN')
               elif event.key == pygame.K_LEFT:
                   moved = self.game.move('LEFT')
               elif event.key == pygame.K_RIGHT:
                   moved = self.game.move('RIGHT')
               if moved:
                   # Update the game state only if a move was successful
                   self.render()
       return True
   ```
2. Implement function B

## Code Review Result
LBTM

# Format example 2
## Code Review: game.py
1. Yes.
2. Yes.
3. Yes.
4. Yes.
5. Yes.
6. Yes.

## Actions
pass

## Code Review Result
LGTM



# Instruction: Based on the actual code situation, follow one of the "Format example". Return only 1 file under review.

## Code Review: Ordered List. Based on the "Code to be Reviewed", provide key, clear, concise, and specific answer. If any answer is no, explain how to fix it step by step.
1. Is the code implemented as per the requirements? If not, how to achieve it? Analyse it step by step.
2. Is the code logic completely correct? If there are errors, please indicate how to correct them.
3. Does the existing code follow the "Data structures and interfaces"?
4. Are all functions implemented? If there is no implementation, please indicate how to achieve it step by step.
5. Have all necessary pre-dependencies been imported? If not, indicate which ones need to be imported
6. Are methods from other files being reused correctly?

## Actions: Ordered List. Things that should be done after CR, such as implementing class A and function B

## Code Review Result: str. If the code doesn't have bugs, we don't need to rewrite it, so answer LGTM and stop. ONLY ANSWER LGTM/LBTM.
LGTM/LBTM






# System
Role: You are a professional software engineer, and your main task is to review and revise the code. You need to ensure that the code conforms to the google-style standards, is elegantly designed and modularized, easy to read and maintain.
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## System Design
{"Implementation approach":"We will build the game as a small, selfâcontained console application using the standard `curses` library for realâtime keyboard input and screen drawing. The core logic will be split into a handful of focused classes:\n\n* **Game** â owns the main loop, coordinates input, update and rendering, and manages the overall state (running, paused, gameâover).\n* **Snake** â stores the ordered list of grid coordinates that make up the snake, handles movement, growth and collision checks.\n* **Food** â keeps the current food position and can generate a new one that never overlaps the snake.\n* **Grid** â represents the 10Ã10 board, provides bounds checking and a helper to convert coordinates to screen positions.\n* **Renderer** â draws the grid, snake, food and UI elements (score, gameâover message) onto the curses window.\n* **InputHandler** â translates arrowâkey events into direction changes while preventing 180Â° reversals.\n\nThe game loop will run at a fixed tick rate (e.g. 10 frames per second). Each tick we:\n1. Poll for a key press.\n2. Update the snakeâs direction.\n3. Move the snake forward.\n4. Check for collisions (wall, self, food).\n5. Grow the snake and update the score if food is eaten.\n6. Render the updated state.\n\nThis separation keeps the code testable, readable and easily extensible (e.g. adding levels or AI). All state is kept in plain Python data structures (lists, tuples, ints) so no external dependencies are required beyond the standard library.\n\n","File list":["main.py","game.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -grid: Grid\n        -snake: Snake\n        -food: Food\n        -renderer: Renderer\n        -input_handler: InputHandler\n        -score: int\n        -running: bool\n        +__init__(window: curses.window)\n        +start() void\n        +handle_input() void\n        +update() void\n        +render() void\n        +game_over() void\n    }\n    class Snake {\n        -body: List[Tuple[int,int]]\n        -direction: Tuple[int,int]\n        +__init__(start_pos: Tuple[int,int], start_dir: Tuple[int,int])\n        +move() void\n        +grow() void\n        +set_direction(new_dir: Tuple[int,int]) void\n        +collides_with_self() bool\n        +collides_with_wall(grid: Grid) bool\n        +head() Tuple[int,int]\n    }\n    class Food {\n        -position: Tuple[int,int]\n        +__init__(grid: Grid, snake: Snake)\n        +generate_new(grid: Grid, snake: Snake) void\n        +position() Tuple[int,int]\n    }\n    class Grid {\n        -width: int\n        -height: int\n        +__init__(width: int, height: int)\n        +in_bounds(pos: Tuple[int,int]) bool\n        +to_screen_coords(pos: Tuple[int,int]) Tuple[int,int]\n    }\n    class Renderer {\n        -window: curses.window\n        +__init__(window: curses.window)\n        +draw(grid: Grid, snake: Snake, food: Food, score: int, game_over: bool) void\n        +clear() void\n    }\n    class InputHandler {\n        -last_direction: Tuple[int,int]\n        +__init__()\n        +get_direction(key: int) Tuple[int,int]\n    }\n    Game --> Snake\n    Game --> Food\n    Game --> Grid\n    Game --> Renderer\n    Game --> InputHandler\n    Snake --> Grid\n    Food --> Grid\n    Renderer --> Grid\n    Renderer --> Snake\n    Renderer --> Food\n","Program call flow":"\nsequenceDiagram\n    participant M as main\n    participant G as Game\n    participant I as InputHandler\n    participant S as Snake\n    participant F as Food\n    participant R as Renderer\n    participant Gd as Grid\n\n    M->>G: __init__(curses_window)\n    G->>Gd: __init__(10,10)\n    G->>S: __init__(center, RIGHT)\n    G->>F: __init__(Gd, S)\n    G->>R: __init__(curses_window)\n    G->>I: __init__()\n    G->>G: start()\n\n    loop every tick\n        G->>I: get_direction(key)\n        I->>G: set_direction\n        G->>S: move()\n        G->>S: collides_with_self() -> bool\n        alt collision\n            G->>G: game_over()\n            G->>R: draw(..., game_over=true)\n            G->>G: break loop\n        else\n            G->>F: position()\n            alt ate food\n                G->>S: grow()\n                G->>S: score++\n                G->>F: generate_new(Gd, S)\n            end\n            G->>R: draw(..., game_over=false)\n        end\n    end\n","Anything UNCLEAR":"The specification mentions \"optional animations for movement and growth\" but does not detail the desired effect. In a console environment, we can simulate a simple animation by briefly flashing the new head position or adding a short delay after growth. If more elaborate animations (e.g., smooth scrolling) are required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or if a graphical window is expected."}

## Task
{"Required Python packages":["No external packages required; uses only the standard library (curses, typing, etc.)"],"Required Other language third-party packages":["No thirdâparty dependencies required"],"Logic Analysis":[["main.py","Imports Game from game.py, initializes curses, creates Game instance, calls start()"],["game.py","Defines Game class: manages main loop, holds Grid, Snake, Food, Renderer, InputHandler, score, running flag; imports all component classes"],["snake.py","Defines Snake class: body list, direction tuple, move(), grow(), set_direction(), collides_with_self(), collides_with_wall(), head()"],["food.py","Defines Food class: position tuple, generate_new() that picks a random free cell, position() accessor"],["grid.py","Defines Grid class: width, height, in_bounds(), to_screen_coords()"],["renderer.py","Defines Renderer class: draws grid, snake, food, score, gameâover message; uses curses window"],["input_handler.py","Defines InputHandler class: get_direction() translates key codes to direction tuples, prevents 180Â° reversal"]],"Task list":["main.py","game.py","snake.py","food.py","grid.py","renderer.py","input_handler.py"],"Full API spec":"","Shared Knowledge":"All state is stored in plain Python data structures (lists, tuples, ints). The game is a console application using the curses library; no external GUI frameworks are required. Each component is isolated to aid testing and future extension (e.g., adding levels or AI).","Anything UNCLEAR":"The specification mentions optional animations for movement and growth but does not detail the desired effect. In a console environment, a simple flash or brief delay can simulate animation. If a richer graphical animation is required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or a graphical window is expected."}

## Code Files
----- main.py
```#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple, Optional

# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game state."""
        self.clear()

        # Draw border
        for x in range(grid.width + 2):
            self.window.addch(0, x, '#')
            self.window.addch(grid.height + 1, x, '#')
        for y in range(1, grid.height + 1):
            self.window.addch(y, 0, '#')
            self.window.addch(y, grid.width + 1, '#')

        # Draw food
        fx, fy = food.position
        sy, sx = grid.to_screen_coords((fx, fy))
        self.window.addch(sy + 1, sx + 1, '*')

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            cy, cx = grid.to_screen_coords((sx, sy))
            char = '@' if idx == 0 else 'O'
            self.window.addch(cy + 1, cx + 1, char)

        # Draw score
        score_text = f"Score: {score}"
        self.window.addstr(grid.height + 3, 0, score_text)

        # Draw game over message
        if game_over:
            msg = "GAME OVER! Press any key to exit."
            self.window.addstr(grid.height // 2, (grid.width - len(msg)) // 2, msg)

        self.window.refresh()


class InputHandler:
    """Translates key presses into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return a new direction based on the key, or keep current."""
        mapping = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        if new_dir != (-self.last_direction[0], -self.last_direction[1]):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per tick (10 FPS)

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (self.grid.width // 2, self.grid.height // 2)
        start_dir: Tuple[int, int] = (1, 0)  # Right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            start_time = time.time()

            # Handle input
            key = self.window.getch()
            if key != -1:
                new_dir = self.input_handler.get_direction(key)
                self.snake.set_direction(new_dir)

            # Update game state
            self.snake.move()

            # Collision checks
            if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
                self.game_over()
            else:
                # Check food consumption
                if self.snake.head() == self.food.position:
                    self.snake.grow()
                    self.score += 1
                    self.food.generate_new(self.grid, self.snake)

            # Render
            self.renderer.draw(
                self.grid,
                self.snake,
                self.food,
                self.score,
                self.game_over_flag,
            )

            # If game over, wait for key press to exit
            if self.game_over_flag:
                self.window.nodelay(False)
                self.window.getch()
                break

            # Maintain tick rate
            elapsed = time.time() - start_time
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Initialize and start the game."""
    game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)
```


## Code to be Reviewed: game.py
```Code
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple


# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game screen."""
        self.clear()

        # Draw border
        for x in range(grid.width):
            self.window.addch(0, x, curses.ACS_HLINE)
            self.window.addch(grid.height + 1, x, curses.ACS_HLINE)
        for y in range(grid.height + 2):
            self.window.addch(y, 0, curses.ACS_VLINE)
            self.window.addch(y, grid.width + 1, curses.ACS_VLINE)
        self.window.addch(0, 0, curses.ACS_ULCORNER)
        self.window.addch(0, grid.width + 1, curses.ACS_URCORNER)
        self.window.addch(grid.height + 1, 0, curses.ACS_LLCORNER)
        self.window.addch(grid.height + 1, grid.width + 1, curses.ACS_LRCORNER)

        # Draw food
        fx, fy = food.position
        fy_screen, fx_screen = grid.to_screen_coords((fx, fy))
        self.window.addch(fy_screen + 1, fx_screen + 1, curses.ACS_PI)

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            sy_screen, sx_screen = grid.to_screen_coords((sx, sy))
            sy_screen += 1
            sx_screen += 1
            char: str = "@" if idx == 0 else "O"
            self.window.addch(sy_screen, sx_screen, char)

        # Draw score
        score_y: int = grid.height + 3
        score_x: int = 0
        score_text: str = f"Score: {score}"
        self.window.addstr(score_y, score_x, score_text)

        # Draw game over message if needed
        if game_over:
            msg: str = "GAME OVER! Press any key to exit."
            msg_y: int = grid.height // 2 + 1
            msg_x: int = (grid.width - len(msg)) // 2 + 1
            self.window.addstr(msg_y, msg_x, msg)

        self.window.refresh()


class InputHandler:
    """Processes user input and translates it into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default to moving right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return the new direction based on the pressed key."""
        mapping: dict[int, Tuple[int, int]] = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir: Tuple[int, int] = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        cur_dx, cur_dy = self.last_direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per frame

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window

        # Initialize components
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (
            self.grid.width // 2,
            self.grid.height // 2,
        )
        start_dir: Tuple[int, int] = (1, 0)  # Moving right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()

        # Game state
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    # ------------------------------------------------------------------
    # Game loop helpers
    # ------------------------------------------------------------------

    def handle_input(self) -> None:
        """Read user input and update snake direction."""
        key: int = self.window.getch()
        if key != -1:
            new_dir: Tuple[int, int] = self.input_handler.get_direction(key)
            self.snake.set_direction(new_dir)

    def update(self) -> None:
        """Advance game state: move snake, check collisions, handle food."""
        self.snake.move()

        # Collision detection
        if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
            self.game_over()
            return

        # Food consumption
        if self.snake.head() == self.food.position:
            self.snake.grow()
            self.score += 1
            self.food.generate_new(self.grid, self.snake)

    def render(self) -> None:
        """Render the current game state."""
        self.renderer.draw(
            self.grid,
            self.snake,
            self.food,
            self.score,
            self.game_over_flag,
        )

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True

    # ------------------------------------------------------------------
    # Main loop
    # ------------------------------------------------------------------

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            frame_start: float = time.time()

            self.handle_input()
            self.update()
            self.render()

            if self.game_over_flag:
                # Wait for a key press before exiting
                self.window.nodelay(False)
                self.window.getch()
                break

            elapsed: float = time.time() - frame_start
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Curses wrapper entry point."""
    game: Game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)

```



# Instruction: rewrite code based on the Code Review and Actions
## Rewrite Code: CodeBlock. If it still has some bugs, rewrite game.py with triple quotes. Do your utmost to optimize THIS SINGLE FILE. Return all completed codes and prohibit the return of unfinished codes.
```Code
## game.py
...
```





NOTICE
Role: You are a professional engineer; the main goal is to write google-style, elegant, modular, easy to read and maintain code
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## Design
{"Implementation approach":"We will build the game as a small, selfâcontained console application using the standard `curses` library for realâtime keyboard input and screen drawing. The core logic will be split into a handful of focused classes:\n\n* **Game** â owns the main loop, coordinates input, update and rendering, and manages the overall state (running, paused, gameâover).\n* **Snake** â stores the ordered list of grid coordinates that make up the snake, handles movement, growth and collision checks.\n* **Food** â keeps the current food position and can generate a new one that never overlaps the snake.\n* **Grid** â represents the 10Ã10 board, provides bounds checking and a helper to convert coordinates to screen positions.\n* **Renderer** â draws the grid, snake, food and UI elements (score, gameâover message) onto the curses window.\n* **InputHandler** â translates arrowâkey events into direction changes while preventing 180Â° reversals.\n\nThe game loop will run at a fixed tick rate (e.g. 10 frames per second). Each tick we:\n1. Poll for a key press.\n2. Update the snakeâs direction.\n3. Move the snake forward.\n4. Check for collisions (wall, self, food).\n5. Grow the snake and update the score if food is eaten.\n6. Render the updated state.\n\nThis separation keeps the code testable, readable and easily extensible (e.g. adding levels or AI). All state is kept in plain Python data structures (lists, tuples, ints) so no external dependencies are required beyond the standard library.\n\n","File list":["main.py","game.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -grid: Grid\n        -snake: Snake\n        -food: Food\n        -renderer: Renderer\n        -input_handler: InputHandler\n        -score: int\n        -running: bool\n        +__init__(window: curses.window)\n        +start() void\n        +handle_input() void\n        +update() void\n        +render() void\n        +game_over() void\n    }\n    class Snake {\n        -body: List[Tuple[int,int]]\n        -direction: Tuple[int,int]\n        +__init__(start_pos: Tuple[int,int], start_dir: Tuple[int,int])\n        +move() void\n        +grow() void\n        +set_direction(new_dir: Tuple[int,int]) void\n        +collides_with_self() bool\n        +collides_with_wall(grid: Grid) bool\n        +head() Tuple[int,int]\n    }\n    class Food {\n        -position: Tuple[int,int]\n        +__init__(grid: Grid, snake: Snake)\n        +generate_new(grid: Grid, snake: Snake) void\n        +position() Tuple[int,int]\n    }\n    class Grid {\n        -width: int\n        -height: int\n        +__init__(width: int, height: int)\n        +in_bounds(pos: Tuple[int,int]) bool\n        +to_screen_coords(pos: Tuple[int,int]) Tuple[int,int]\n    }\n    class Renderer {\n        -window: curses.window\n        +__init__(window: curses.window)\n        +draw(grid: Grid, snake: Snake, food: Food, score: int, game_over: bool) void\n        +clear() void\n    }\n    class InputHandler {\n        -last_direction: Tuple[int,int]\n        +__init__()\n        +get_direction(key: int) Tuple[int,int]\n    }\n    Game --> Snake\n    Game --> Food\n    Game --> Grid\n    Game --> Renderer\n    Game --> InputHandler\n    Snake --> Grid\n    Food --> Grid\n    Renderer --> Grid\n    Renderer --> Snake\n    Renderer --> Food\n","Program call flow":"\nsequenceDiagram\n    participant M as main\n    participant G as Game\n    participant I as InputHandler\n    participant S as Snake\n    participant F as Food\n    participant R as Renderer\n    participant Gd as Grid\n\n    M->>G: __init__(curses_window)\n    G->>Gd: __init__(10,10)\n    G->>S: __init__(center, RIGHT)\n    G->>F: __init__(Gd, S)\n    G->>R: __init__(curses_window)\n    G->>I: __init__()\n    G->>G: start()\n\n    loop every tick\n        G->>I: get_direction(key)\n        I->>G: set_direction\n        G->>S: move()\n        G->>S: collides_with_self() -> bool\n        alt collision\n            G->>G: game_over()\n            G->>R: draw(..., game_over=true)\n            G->>G: break loop\n        else\n            G->>F: position()\n            alt ate food\n                G->>S: grow()\n                G->>S: score++\n                G->>F: generate_new(Gd, S)\n            end\n            G->>R: draw(..., game_over=false)\n        end\n    end\n","Anything UNCLEAR":"The specification mentions \"optional animations for movement and growth\" but does not detail the desired effect. In a console environment, we can simulate a simple animation by briefly flashing the new head position or adding a short delay after growth. If more elaborate animations (e.g., smooth scrolling) are required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or if a graphical window is expected."}

## Task
{"Required Python packages":["No external packages required; uses only the standard library (curses, typing, etc.)"],"Required Other language third-party packages":["No thirdâparty dependencies required"],"Logic Analysis":[["main.py","Imports Game from game.py, initializes curses, creates Game instance, calls start()"],["game.py","Defines Game class: manages main loop, holds Grid, Snake, Food, Renderer, InputHandler, score, running flag; imports all component classes"],["snake.py","Defines Snake class: body list, direction tuple, move(), grow(), set_direction(), collides_with_self(), collides_with_wall(), head()"],["food.py","Defines Food class: position tuple, generate_new() that picks a random free cell, position() accessor"],["grid.py","Defines Grid class: width, height, in_bounds(), to_screen_coords()"],["renderer.py","Defines Renderer class: draws grid, snake, food, score, gameâover message; uses curses window"],["input_handler.py","Defines InputHandler class: get_direction() translates key codes to direction tuples, prevents 180Â° reversal"]],"Task list":["main.py","game.py","snake.py","food.py","grid.py","renderer.py","input_handler.py"],"Full API spec":"","Shared Knowledge":"All state is stored in plain Python data structures (lists, tuples, ints). The game is a console application using the curses library; no external GUI frameworks are required. Each component is isolated to aid testing and future extension (e.g., adding levels or AI).","Anything UNCLEAR":"The specification mentions optional animations for movement and growth but does not detail the desired effect. In a console environment, a simple flash or brief delay can simulate animation. If a richer graphical animation is required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or a graphical window is expected."}

## Legacy Code
```Code
----- main.py
```#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple, Optional

# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game state."""
        self.clear()

        # Draw border
        for x in range(grid.width + 2):
            self.window.addch(0, x, '#')
            self.window.addch(grid.height + 1, x, '#')
        for y in range(1, grid.height + 1):
            self.window.addch(y, 0, '#')
            self.window.addch(y, grid.width + 1, '#')

        # Draw food
        fx, fy = food.position
        sy, sx = grid.to_screen_coords((fx, fy))
        self.window.addch(sy + 1, sx + 1, '*')

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            cy, cx = grid.to_screen_coords((sx, sy))
            char = '@' if idx == 0 else 'O'
            self.window.addch(cy + 1, cx + 1, char)

        # Draw score
        score_text = f"Score: {score}"
        self.window.addstr(grid.height + 3, 0, score_text)

        # Draw game over message
        if game_over:
            msg = "GAME OVER! Press any key to exit."
            self.window.addstr(grid.height // 2, (grid.width - len(msg)) // 2, msg)

        self.window.refresh()


class InputHandler:
    """Translates key presses into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return a new direction based on the key, or keep current."""
        mapping = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        if new_dir != (-self.last_direction[0], -self.last_direction[1]):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per tick (10 FPS)

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (self.grid.width // 2, self.grid.height // 2)
        start_dir: Tuple[int, int] = (1, 0)  # Right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            start_time = time.time()

            # Handle input
            key = self.window.getch()
            if key != -1:
                new_dir = self.input_handler.get_direction(key)
                self.snake.set_direction(new_dir)

            # Update game state
            self.snake.move()

            # Collision checks
            if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
                self.game_over()
            else:
                # Check food consumption
                if self.snake.head() == self.food.position:
                    self.snake.grow()
                    self.score += 1
                    self.food.generate_new(self.grid, self.snake)

            # Render
            self.renderer.draw(
                self.grid,
                self.snake,
                self.food,
                self.score,
                self.game_over_flag,
            )

            # If game over, wait for key press to exit
            if self.game_over_flag:
                self.window.nodelay(False)
                self.window.getch()
                break

            # Maintain tick rate
            elapsed = time.time() - start_time
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Initialize and start the game."""
    game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)
```
----- game.py
```#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple


# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game screen."""
        self.clear()

        # Draw border
        for x in range(grid.width):
            self.window.addch(0, x, curses.ACS_HLINE)
            self.window.addch(grid.height + 1, x, curses.ACS_HLINE)
        for y in range(grid.height + 2):
            self.window.addch(y, 0, curses.ACS_VLINE)
            self.window.addch(y, grid.width + 1, curses.ACS_VLINE)
        self.window.addch(0, 0, curses.ACS_ULCORNER)
        self.window.addch(0, grid.width + 1, curses.ACS_URCORNER)
        self.window.addch(grid.height + 1, 0, curses.ACS_LLCORNER)
        self.window.addch(grid.height + 1, grid.width + 1, curses.ACS_LRCORNER)

        # Draw food
        fx, fy = food.position
        fy_screen, fx_screen = grid.to_screen_coords((fx, fy))
        self.window.addch(fy_screen + 1, fx_screen + 1, curses.ACS_PI)

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            sy_screen, sx_screen = grid.to_screen_coords((sx, sy))
            sy_screen += 1
            sx_screen += 1
            char: str = "@" if idx == 0 else "O"
            self.window.addch(sy_screen, sx_screen, char)

        # Draw score
        score_y: int = grid.height + 3
        score_x: int = 0
        score_text: str = f"Score: {score}"
        self.window.addstr(score_y, score_x, score_text)

        # Draw game over message if needed
        if game_over:
            msg: str = "GAME OVER! Press any key to exit."
            msg_y: int = grid.height // 2 + 1
            msg_x: int = (grid.width - len(msg)) // 2 + 1
            self.window.addstr(msg_y, msg_x, msg)

        self.window.refresh()


class InputHandler:
    """Processes user input and translates it into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default to moving right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return the new direction based on the pressed key."""
        mapping: dict[int, Tuple[int, int]] = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir: Tuple[int, int] = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        cur_dx, cur_dy = self.last_direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per frame

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window

        # Initialize components
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (
            self.grid.width // 2,
            self.grid.height // 2,
        )
        start_dir: Tuple[int, int] = (1, 0)  # Moving right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()

        # Game state
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    # ------------------------------------------------------------------
    # Game loop helpers
    # ------------------------------------------------------------------

    def handle_input(self) -> None:
        """Read user input and update snake direction."""
        key: int = self.window.getch()
        if key != -1:
            new_dir: Tuple[int, int] = self.input_handler.get_direction(key)
            self.snake.set_direction(new_dir)

    def update(self) -> None:
        """Advance game state: move snake, check collisions, handle food."""
        self.snake.move()

        # Collision detection
        if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
            self.game_over()
            return

        # Food consumption
        if self.snake.head() == self.food.position:
            self.snake.grow()
            self.score += 1
            self.food.generate_new(self.grid, self.snake)

    def render(self) -> None:
        """Render the current game state."""
        self.renderer.draw(
            self.grid,
            self.snake,
            self.food,
            self.score,
            self.game_over_flag,
        )

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True

    # ------------------------------------------------------------------
    # Main loop
    # ------------------------------------------------------------------

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            frame_start: float = time.time()

            self.handle_input()
            self.update()
            self.render()

            if self.game_over_flag:
                # Wait for a key press before exiting
                self.window.nodelay(False)
                self.window.getch()
                break

            elapsed: float = time.time() - frame_start
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Curses wrapper entry point."""
    game: Game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)
```
```

## Debug logs
```text



```

## Bug Feedback logs
```text

```

# Format example
## Code: snake.py
```python
## snake.py
...
```

# Instruction: Based on the context, follow "Format example", write code.

## Code: snake.py. Write code with triple quoto, based on the following attentions and context.
1. Only One file: do your best to implement THIS ONLY ONE FILE.
2. COMPLETE CODE: Your code will be part of the entire project, so please implement complete, reliable, reusable code snippets.
3. Set default value: If there is any setting, ALWAYS SET A DEFAULT VALUE, ALWAYS USE STRONG TYPE AND EXPLICIT VARIABLE. AVOID circular import.
4. Follow design: YOU MUST FOLLOW "Data structures and interfaces". DONT CHANGE ANY DESIGN. Do not use public member functions that do not exist in your design.
5. CAREFULLY CHECK THAT YOU DONT MISS ANY NECESSARY CLASS/FUNCTION IN THIS FILE.
6. Before using a external variable/module, make sure you import it first.
7. Write out EVERY CODE DETAIL, DON'T LEAVE TODO.






# System
Role: You are a professional software engineer, and your main task is to review and revise the code. You need to ensure that the code conforms to the google-style standards, is elegantly designed and modularized, easy to read and maintain.
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## System Design
{"Implementation approach":"We will build the game as a small, selfâcontained console application using the standard `curses` library for realâtime keyboard input and screen drawing. The core logic will be split into a handful of focused classes:\n\n* **Game** â owns the main loop, coordinates input, update and rendering, and manages the overall state (running, paused, gameâover).\n* **Snake** â stores the ordered list of grid coordinates that make up the snake, handles movement, growth and collision checks.\n* **Food** â keeps the current food position and can generate a new one that never overlaps the snake.\n* **Grid** â represents the 10Ã10 board, provides bounds checking and a helper to convert coordinates to screen positions.\n* **Renderer** â draws the grid, snake, food and UI elements (score, gameâover message) onto the curses window.\n* **InputHandler** â translates arrowâkey events into direction changes while preventing 180Â° reversals.\n\nThe game loop will run at a fixed tick rate (e.g. 10 frames per second). Each tick we:\n1. Poll for a key press.\n2. Update the snakeâs direction.\n3. Move the snake forward.\n4. Check for collisions (wall, self, food).\n5. Grow the snake and update the score if food is eaten.\n6. Render the updated state.\n\nThis separation keeps the code testable, readable and easily extensible (e.g. adding levels or AI). All state is kept in plain Python data structures (lists, tuples, ints) so no external dependencies are required beyond the standard library.\n\n","File list":["main.py","game.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -grid: Grid\n        -snake: Snake\n        -food: Food\n        -renderer: Renderer\n        -input_handler: InputHandler\n        -score: int\n        -running: bool\n        +__init__(window: curses.window)\n        +start() void\n        +handle_input() void\n        +update() void\n        +render() void\n        +game_over() void\n    }\n    class Snake {\n        -body: List[Tuple[int,int]]\n        -direction: Tuple[int,int]\n        +__init__(start_pos: Tuple[int,int], start_dir: Tuple[int,int])\n        +move() void\n        +grow() void\n        +set_direction(new_dir: Tuple[int,int]) void\n        +collides_with_self() bool\n        +collides_with_wall(grid: Grid) bool\n        +head() Tuple[int,int]\n    }\n    class Food {\n        -position: Tuple[int,int]\n        +__init__(grid: Grid, snake: Snake)\n        +generate_new(grid: Grid, snake: Snake) void\n        +position() Tuple[int,int]\n    }\n    class Grid {\n        -width: int\n        -height: int\n        +__init__(width: int, height: int)\n        +in_bounds(pos: Tuple[int,int]) bool\n        +to_screen_coords(pos: Tuple[int,int]) Tuple[int,int]\n    }\n    class Renderer {\n        -window: curses.window\n        +__init__(window: curses.window)\n        +draw(grid: Grid, snake: Snake, food: Food, score: int, game_over: bool) void\n        +clear() void\n    }\n    class InputHandler {\n        -last_direction: Tuple[int,int]\n        +__init__()\n        +get_direction(key: int) Tuple[int,int]\n    }\n    Game --> Snake\n    Game --> Food\n    Game --> Grid\n    Game --> Renderer\n    Game --> InputHandler\n    Snake --> Grid\n    Food --> Grid\n    Renderer --> Grid\n    Renderer --> Snake\n    Renderer --> Food\n","Program call flow":"\nsequenceDiagram\n    participant M as main\n    participant G as Game\n    participant I as InputHandler\n    participant S as Snake\n    participant F as Food\n    participant R as Renderer\n    participant Gd as Grid\n\n    M->>G: __init__(curses_window)\n    G->>Gd: __init__(10,10)\n    G->>S: __init__(center, RIGHT)\n    G->>F: __init__(Gd, S)\n    G->>R: __init__(curses_window)\n    G->>I: __init__()\n    G->>G: start()\n\n    loop every tick\n        G->>I: get_direction(key)\n        I->>G: set_direction\n        G->>S: move()\n        G->>S: collides_with_self() -> bool\n        alt collision\n            G->>G: game_over()\n            G->>R: draw(..., game_over=true)\n            G->>G: break loop\n        else\n            G->>F: position()\n            alt ate food\n                G->>S: grow()\n                G->>S: score++\n                G->>F: generate_new(Gd, S)\n            end\n            G->>R: draw(..., game_over=false)\n        end\n    end\n","Anything UNCLEAR":"The specification mentions \"optional animations for movement and growth\" but does not detail the desired effect. In a console environment, we can simulate a simple animation by briefly flashing the new head position or adding a short delay after growth. If more elaborate animations (e.g., smooth scrolling) are required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or if a graphical window is expected."}

## Task
{"Required Python packages":["No external packages required; uses only the standard library (curses, typing, etc.)"],"Required Other language third-party packages":["No thirdâparty dependencies required"],"Logic Analysis":[["main.py","Imports Game from game.py, initializes curses, creates Game instance, calls start()"],["game.py","Defines Game class: manages main loop, holds Grid, Snake, Food, Renderer, InputHandler, score, running flag; imports all component classes"],["snake.py","Defines Snake class: body list, direction tuple, move(), grow(), set_direction(), collides_with_self(), collides_with_wall(), head()"],["food.py","Defines Food class: position tuple, generate_new() that picks a random free cell, position() accessor"],["grid.py","Defines Grid class: width, height, in_bounds(), to_screen_coords()"],["renderer.py","Defines Renderer class: draws grid, snake, food, score, gameâover message; uses curses window"],["input_handler.py","Defines InputHandler class: get_direction() translates key codes to direction tuples, prevents 180Â° reversal"]],"Task list":["main.py","game.py","snake.py","food.py","grid.py","renderer.py","input_handler.py"],"Full API spec":"","Shared Knowledge":"All state is stored in plain Python data structures (lists, tuples, ints). The game is a console application using the curses library; no external GUI frameworks are required. Each component is isolated to aid testing and future extension (e.g., adding levels or AI).","Anything UNCLEAR":"The specification mentions optional animations for movement and growth but does not detail the desired effect. In a console environment, a simple flash or brief delay can simulate animation. If a richer graphical animation is required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or a graphical window is expected."}

## Code Files
----- main.py
```#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple, Optional

# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game state."""
        self.clear()

        # Draw border
        for x in range(grid.width + 2):
            self.window.addch(0, x, '#')
            self.window.addch(grid.height + 1, x, '#')
        for y in range(1, grid.height + 1):
            self.window.addch(y, 0, '#')
            self.window.addch(y, grid.width + 1, '#')

        # Draw food
        fx, fy = food.position
        sy, sx = grid.to_screen_coords((fx, fy))
        self.window.addch(sy + 1, sx + 1, '*')

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            cy, cx = grid.to_screen_coords((sx, sy))
            char = '@' if idx == 0 else 'O'
            self.window.addch(cy + 1, cx + 1, char)

        # Draw score
        score_text = f"Score: {score}"
        self.window.addstr(grid.height + 3, 0, score_text)

        # Draw game over message
        if game_over:
            msg = "GAME OVER! Press any key to exit."
            self.window.addstr(grid.height // 2, (grid.width - len(msg)) // 2, msg)

        self.window.refresh()


class InputHandler:
    """Translates key presses into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return a new direction based on the key, or keep current."""
        mapping = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        if new_dir != (-self.last_direction[0], -self.last_direction[1]):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per tick (10 FPS)

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (self.grid.width // 2, self.grid.height // 2)
        start_dir: Tuple[int, int] = (1, 0)  # Right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            start_time = time.time()

            # Handle input
            key = self.window.getch()
            if key != -1:
                new_dir = self.input_handler.get_direction(key)
                self.snake.set_direction(new_dir)

            # Update game state
            self.snake.move()

            # Collision checks
            if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
                self.game_over()
            else:
                # Check food consumption
                if self.snake.head() == self.food.position:
                    self.snake.grow()
                    self.score += 1
                    self.food.generate_new(self.grid, self.snake)

            # Render
            self.renderer.draw(
                self.grid,
                self.snake,
                self.food,
                self.score,
                self.game_over_flag,
            )

            # If game over, wait for key press to exit
            if self.game_over_flag:
                self.window.nodelay(False)
                self.window.getch()
                break

            # Maintain tick rate
            elapsed = time.time() - start_time
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Initialize and start the game."""
    game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)
```
----- game.py
```#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple


# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game screen."""
        self.clear()

        # Draw border
        for x in range(grid.width):
            self.window.addch(0, x, curses.ACS_HLINE)
            self.window.addch(grid.height + 1, x, curses.ACS_HLINE)
        for y in range(grid.height + 2):
            self.window.addch(y, 0, curses.ACS_VLINE)
            self.window.addch(y, grid.width + 1, curses.ACS_VLINE)
        self.window.addch(0, 0, curses.ACS_ULCORNER)
        self.window.addch(0, grid.width + 1, curses.ACS_URCORNER)
        self.window.addch(grid.height + 1, 0, curses.ACS_LLCORNER)
        self.window.addch(grid.height + 1, grid.width + 1, curses.ACS_LRCORNER)

        # Draw food
        fx, fy = food.position
        fy_screen, fx_screen = grid.to_screen_coords((fx, fy))
        self.window.addch(fy_screen + 1, fx_screen + 1, curses.ACS_PI)

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            sy_screen, sx_screen = grid.to_screen_coords((sx, sy))
            sy_screen += 1
            sx_screen += 1
            char: str = "@" if idx == 0 else "O"
            self.window.addch(sy_screen, sx_screen, char)

        # Draw score
        score_y: int = grid.height + 3
        score_x: int = 0
        score_text: str = f"Score: {score}"
        self.window.addstr(score_y, score_x, score_text)

        # Draw game over message if needed
        if game_over:
            msg: str = "GAME OVER! Press any key to exit."
            msg_y: int = grid.height // 2 + 1
            msg_x: int = (grid.width - len(msg)) // 2 + 1
            self.window.addstr(msg_y, msg_x, msg)

        self.window.refresh()


class InputHandler:
    """Processes user input and translates it into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default to moving right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return the new direction based on the pressed key."""
        mapping: dict[int, Tuple[int, int]] = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir: Tuple[int, int] = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        cur_dx, cur_dy = self.last_direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per frame

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window

        # Initialize components
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (
            self.grid.width // 2,
            self.grid.height // 2,
        )
        start_dir: Tuple[int, int] = (1, 0)  # Moving right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()

        # Game state
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    # ------------------------------------------------------------------
    # Game loop helpers
    # ------------------------------------------------------------------

    def handle_input(self) -> None:
        """Read user input and update snake direction."""
        key: int = self.window.getch()
        if key != -1:
            new_dir: Tuple[int, int] = self.input_handler.get_direction(key)
            self.snake.set_direction(new_dir)

    def update(self) -> None:
        """Advance game state: move snake, check collisions, handle food."""
        self.snake.move()

        # Collision detection
        if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
            self.game_over()
            return

        # Food consumption
        if self.snake.head() == self.food.position:
            self.snake.grow()
            self.score += 1
            self.food.generate_new(self.grid, self.snake)

    def render(self) -> None:
        """Render the current game state."""
        self.renderer.draw(
            self.grid,
            self.snake,
            self.food,
            self.score,
            self.game_over_flag,
        )

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True

    # ------------------------------------------------------------------
    # Main loop
    # ------------------------------------------------------------------

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            frame_start: float = time.time()

            self.handle_input()
            self.update()
            self.render()

            if self.game_over_flag:
                # Wait for a key press before exiting
                self.window.nodelay(False)
                self.window.getch()
                break

            elapsed: float = time.time() - frame_start
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Curses wrapper entry point."""
    game: Game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)
```


## Code to be Reviewed: snake.py
```Code
## snake.py
"""
Snake component for the console Snake game.

This module implements the :class:`Snake` class as specified in the
design documentation.  The implementation is fully typed, avoids
circular imports, and follows the public interface exactly.
"""

from __future__ import annotations

from typing import List, Tuple

# Import Grid only for type checking; no runtime dependency on grid.py
# to avoid circular imports.
from grid import Grid


class Snake:
    """
    Represents the snake in the game.

    Attributes
    ----------
    body : List[Tuple[int, int]]
        Ordered list of grid coordinates from head to tail.
    direction : Tuple[int, int]
        Current movement direction as a (dx, dy) pair.
    _grow_pending : bool
        Flag indicating whether the snake should grow on the next move.
    """

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        """
        Initialise a new snake.

        Parameters
        ----------
        start_pos : Tuple[int, int]
            Initial head position on the grid.
        start_dir : Tuple[int, int]
            Initial movement direction.
        """
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """
        Move the snake forward by one cell.

        The new head position is calculated from the current head and
        direction.  The new head is inserted at the front of the body
        list.  If a growth is pending, the tail is left intact; otherwise
        the last segment is removed to keep the length constant.
        """
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)

        if self._grow_pending:
            # Consume the growth flag; the snake has grown by one segment.
            self._grow_pending = False
        else:
            # Normal movement: remove the tail segment.
            self.body.pop()

    def grow(self) -> None:
        """
        Schedule the snake to grow on its next move.

        After calling this method, the snake will retain its tail segment
        during the next :meth:`move` call, effectively increasing its
        length by one.
        """
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """
        Change the snake's direction if it is not a 180Â° reversal.

        Parameters
        ----------
        new_dir : Tuple[int, int]
            Desired new direction as a (dx, dy) pair.
        """
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        # Prevent the snake from reversing onto itself.
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """
        Check whether the snake's head collides with its body.

        Returns
        -------
        bool
            ``True`` if the head occupies the same cell as any other
            segment of the body.
        """
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """
        Check whether the snake's head has moved outside the grid.

        Parameters
        ----------
        grid : Grid
            The game grid used for boundary checks.

        Returns
        -------
        bool
            ``True`` if the head position is not within the grid bounds.
        """
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """
        Retrieve the current head position.

        Returns
        -------
        Tuple[int, int]
            The (x, y) coordinates of the snake's head.
        """
        return self.body[0]

```



# Format example 1
## Code Review: snake.py
1. No, we should fix the logic of class A due to ...
2. ...
3. ...
4. No, function B is not implemented, ...
5. ...
6. ...

## Actions
1. Fix the `handle_events` method to update the game state only if a move is successful.
   ```python
   def handle_events(self):
       for event in pygame.event.get():
           if event.type == pygame.QUIT:
               return False
           if event.type == pygame.KEYDOWN:
               moved = False
               if event.key == pygame.K_UP:
                   moved = self.game.move('UP')
               elif event.key == pygame.K_DOWN:
                   moved = self.game.move('DOWN')
               elif event.key == pygame.K_LEFT:
                   moved = self.game.move('LEFT')
               elif event.key == pygame.K_RIGHT:
                   moved = self.game.move('RIGHT')
               if moved:
                   # Update the game state only if a move was successful
                   self.render()
       return True
   ```
2. Implement function B

## Code Review Result
LBTM

# Format example 2
## Code Review: snake.py
1. Yes.
2. Yes.
3. Yes.
4. Yes.
5. Yes.
6. Yes.

## Actions
pass

## Code Review Result
LGTM



# Instruction: Based on the actual code situation, follow one of the "Format example". Return only 1 file under review.

## Code Review: Ordered List. Based on the "Code to be Reviewed", provide key, clear, concise, and specific answer. If any answer is no, explain how to fix it step by step.
1. Is the code implemented as per the requirements? If not, how to achieve it? Analyse it step by step.
2. Is the code logic completely correct? If there are errors, please indicate how to correct them.
3. Does the existing code follow the "Data structures and interfaces"?
4. Are all functions implemented? If there is no implementation, please indicate how to achieve it step by step.
5. Have all necessary pre-dependencies been imported? If not, indicate which ones need to be imported
6. Are methods from other files being reused correctly?

## Actions: Ordered List. Things that should be done after CR, such as implementing class A and function B

## Code Review Result: str. If the code doesn't have bugs, we don't need to rewrite it, so answer LGTM and stop. ONLY ANSWER LGTM/LBTM.
LGTM/LBTM






NOTICE
Role: You are a professional engineer; the main goal is to write google-style, elegant, modular, easy to read and maintain code
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## Design
{"Implementation approach":"We will build the game as a small, selfâcontained console application using the standard `curses` library for realâtime keyboard input and screen drawing. The core logic will be split into a handful of focused classes:\n\n* **Game** â owns the main loop, coordinates input, update and rendering, and manages the overall state (running, paused, gameâover).\n* **Snake** â stores the ordered list of grid coordinates that make up the snake, handles movement, growth and collision checks.\n* **Food** â keeps the current food position and can generate a new one that never overlaps the snake.\n* **Grid** â represents the 10Ã10 board, provides bounds checking and a helper to convert coordinates to screen positions.\n* **Renderer** â draws the grid, snake, food and UI elements (score, gameâover message) onto the curses window.\n* **InputHandler** â translates arrowâkey events into direction changes while preventing 180Â° reversals.\n\nThe game loop will run at a fixed tick rate (e.g. 10 frames per second). Each tick we:\n1. Poll for a key press.\n2. Update the snakeâs direction.\n3. Move the snake forward.\n4. Check for collisions (wall, self, food).\n5. Grow the snake and update the score if food is eaten.\n6. Render the updated state.\n\nThis separation keeps the code testable, readable and easily extensible (e.g. adding levels or AI). All state is kept in plain Python data structures (lists, tuples, ints) so no external dependencies are required beyond the standard library.\n\n","File list":["main.py","game.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -grid: Grid\n        -snake: Snake\n        -food: Food\n        -renderer: Renderer\n        -input_handler: InputHandler\n        -score: int\n        -running: bool\n        +__init__(window: curses.window)\n        +start() void\n        +handle_input() void\n        +update() void\n        +render() void\n        +game_over() void\n    }\n    class Snake {\n        -body: List[Tuple[int,int]]\n        -direction: Tuple[int,int]\n        +__init__(start_pos: Tuple[int,int], start_dir: Tuple[int,int])\n        +move() void\n        +grow() void\n        +set_direction(new_dir: Tuple[int,int]) void\n        +collides_with_self() bool\n        +collides_with_wall(grid: Grid) bool\n        +head() Tuple[int,int]\n    }\n    class Food {\n        -position: Tuple[int,int]\n        +__init__(grid: Grid, snake: Snake)\n        +generate_new(grid: Grid, snake: Snake) void\n        +position() Tuple[int,int]\n    }\n    class Grid {\n        -width: int\n        -height: int\n        +__init__(width: int, height: int)\n        +in_bounds(pos: Tuple[int,int]) bool\n        +to_screen_coords(pos: Tuple[int,int]) Tuple[int,int]\n    }\n    class Renderer {\n        -window: curses.window\n        +__init__(window: curses.window)\n        +draw(grid: Grid, snake: Snake, food: Food, score: int, game_over: bool) void\n        +clear() void\n    }\n    class InputHandler {\n        -last_direction: Tuple[int,int]\n        +__init__()\n        +get_direction(key: int) Tuple[int,int]\n    }\n    Game --> Snake\n    Game --> Food\n    Game --> Grid\n    Game --> Renderer\n    Game --> InputHandler\n    Snake --> Grid\n    Food --> Grid\n    Renderer --> Grid\n    Renderer --> Snake\n    Renderer --> Food\n","Program call flow":"\nsequenceDiagram\n    participant M as main\n    participant G as Game\n    participant I as InputHandler\n    participant S as Snake\n    participant F as Food\n    participant R as Renderer\n    participant Gd as Grid\n\n    M->>G: __init__(curses_window)\n    G->>Gd: __init__(10,10)\n    G->>S: __init__(center, RIGHT)\n    G->>F: __init__(Gd, S)\n    G->>R: __init__(curses_window)\n    G->>I: __init__()\n    G->>G: start()\n\n    loop every tick\n        G->>I: get_direction(key)\n        I->>G: set_direction\n        G->>S: move()\n        G->>S: collides_with_self() -> bool\n        alt collision\n            G->>G: game_over()\n            G->>R: draw(..., game_over=true)\n            G->>G: break loop\n        else\n            G->>F: position()\n            alt ate food\n                G->>S: grow()\n                G->>S: score++\n                G->>F: generate_new(Gd, S)\n            end\n            G->>R: draw(..., game_over=false)\n        end\n    end\n","Anything UNCLEAR":"The specification mentions \"optional animations for movement and growth\" but does not detail the desired effect. In a console environment, we can simulate a simple animation by briefly flashing the new head position or adding a short delay after growth. If more elaborate animations (e.g., smooth scrolling) are required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or if a graphical window is expected."}

## Task
{"Required Python packages":["No external packages required; uses only the standard library (curses, typing, etc.)"],"Required Other language third-party packages":["No thirdâparty dependencies required"],"Logic Analysis":[["main.py","Imports Game from game.py, initializes curses, creates Game instance, calls start()"],["game.py","Defines Game class: manages main loop, holds Grid, Snake, Food, Renderer, InputHandler, score, running flag; imports all component classes"],["snake.py","Defines Snake class: body list, direction tuple, move(), grow(), set_direction(), collides_with_self(), collides_with_wall(), head()"],["food.py","Defines Food class: position tuple, generate_new() that picks a random free cell, position() accessor"],["grid.py","Defines Grid class: width, height, in_bounds(), to_screen_coords()"],["renderer.py","Defines Renderer class: draws grid, snake, food, score, gameâover message; uses curses window"],["input_handler.py","Defines InputHandler class: get_direction() translates key codes to direction tuples, prevents 180Â° reversal"]],"Task list":["main.py","game.py","snake.py","food.py","grid.py","renderer.py","input_handler.py"],"Full API spec":"","Shared Knowledge":"All state is stored in plain Python data structures (lists, tuples, ints). The game is a console application using the curses library; no external GUI frameworks are required. Each component is isolated to aid testing and future extension (e.g., adding levels or AI).","Anything UNCLEAR":"The specification mentions optional animations for movement and growth but does not detail the desired effect. In a console environment, a simple flash or brief delay can simulate animation. If a richer graphical animation is required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or a graphical window is expected."}

## Legacy Code
```Code
----- main.py
```#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple, Optional

# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game state."""
        self.clear()

        # Draw border
        for x in range(grid.width + 2):
            self.window.addch(0, x, '#')
            self.window.addch(grid.height + 1, x, '#')
        for y in range(1, grid.height + 1):
            self.window.addch(y, 0, '#')
            self.window.addch(y, grid.width + 1, '#')

        # Draw food
        fx, fy = food.position
        sy, sx = grid.to_screen_coords((fx, fy))
        self.window.addch(sy + 1, sx + 1, '*')

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            cy, cx = grid.to_screen_coords((sx, sy))
            char = '@' if idx == 0 else 'O'
            self.window.addch(cy + 1, cx + 1, char)

        # Draw score
        score_text = f"Score: {score}"
        self.window.addstr(grid.height + 3, 0, score_text)

        # Draw game over message
        if game_over:
            msg = "GAME OVER! Press any key to exit."
            self.window.addstr(grid.height // 2, (grid.width - len(msg)) // 2, msg)

        self.window.refresh()


class InputHandler:
    """Translates key presses into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return a new direction based on the key, or keep current."""
        mapping = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        if new_dir != (-self.last_direction[0], -self.last_direction[1]):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per tick (10 FPS)

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (self.grid.width // 2, self.grid.height // 2)
        start_dir: Tuple[int, int] = (1, 0)  # Right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            start_time = time.time()

            # Handle input
            key = self.window.getch()
            if key != -1:
                new_dir = self.input_handler.get_direction(key)
                self.snake.set_direction(new_dir)

            # Update game state
            self.snake.move()

            # Collision checks
            if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
                self.game_over()
            else:
                # Check food consumption
                if self.snake.head() == self.food.position:
                    self.snake.grow()
                    self.score += 1
                    self.food.generate_new(self.grid, self.snake)

            # Render
            self.renderer.draw(
                self.grid,
                self.snake,
                self.food,
                self.score,
                self.game_over_flag,
            )

            # If game over, wait for key press to exit
            if self.game_over_flag:
                self.window.nodelay(False)
                self.window.getch()
                break

            # Maintain tick rate
            elapsed = time.time() - start_time
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Initialize and start the game."""
    game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)
```
----- game.py
```#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple


# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game screen."""
        self.clear()

        # Draw border
        for x in range(grid.width):
            self.window.addch(0, x, curses.ACS_HLINE)
            self.window.addch(grid.height + 1, x, curses.ACS_HLINE)
        for y in range(grid.height + 2):
            self.window.addch(y, 0, curses.ACS_VLINE)
            self.window.addch(y, grid.width + 1, curses.ACS_VLINE)
        self.window.addch(0, 0, curses.ACS_ULCORNER)
        self.window.addch(0, grid.width + 1, curses.ACS_URCORNER)
        self.window.addch(grid.height + 1, 0, curses.ACS_LLCORNER)
        self.window.addch(grid.height + 1, grid.width + 1, curses.ACS_LRCORNER)

        # Draw food
        fx, fy = food.position
        fy_screen, fx_screen = grid.to_screen_coords((fx, fy))
        self.window.addch(fy_screen + 1, fx_screen + 1, curses.ACS_PI)

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            sy_screen, sx_screen = grid.to_screen_coords((sx, sy))
            sy_screen += 1
            sx_screen += 1
            char: str = "@" if idx == 0 else "O"
            self.window.addch(sy_screen, sx_screen, char)

        # Draw score
        score_y: int = grid.height + 3
        score_x: int = 0
        score_text: str = f"Score: {score}"
        self.window.addstr(score_y, score_x, score_text)

        # Draw game over message if needed
        if game_over:
            msg: str = "GAME OVER! Press any key to exit."
            msg_y: int = grid.height // 2 + 1
            msg_x: int = (grid.width - len(msg)) // 2 + 1
            self.window.addstr(msg_y, msg_x, msg)

        self.window.refresh()


class InputHandler:
    """Processes user input and translates it into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default to moving right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return the new direction based on the pressed key."""
        mapping: dict[int, Tuple[int, int]] = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir: Tuple[int, int] = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        cur_dx, cur_dy = self.last_direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per frame

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window

        # Initialize components
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (
            self.grid.width // 2,
            self.grid.height // 2,
        )
        start_dir: Tuple[int, int] = (1, 0)  # Moving right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()

        # Game state
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    # ------------------------------------------------------------------
    # Game loop helpers
    # ------------------------------------------------------------------

    def handle_input(self) -> None:
        """Read user input and update snake direction."""
        key: int = self.window.getch()
        if key != -1:
            new_dir: Tuple[int, int] = self.input_handler.get_direction(key)
            self.snake.set_direction(new_dir)

    def update(self) -> None:
        """Advance game state: move snake, check collisions, handle food."""
        self.snake.move()

        # Collision detection
        if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
            self.game_over()
            return

        # Food consumption
        if self.snake.head() == self.food.position:
            self.snake.grow()
            self.score += 1
            self.food.generate_new(self.grid, self.snake)

    def render(self) -> None:
        """Render the current game state."""
        self.renderer.draw(
            self.grid,
            self.snake,
            self.food,
            self.score,
            self.game_over_flag,
        )

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True

    # ------------------------------------------------------------------
    # Main loop
    # ------------------------------------------------------------------

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            frame_start: float = time.time()

            self.handle_input()
            self.update()
            self.render()

            if self.game_over_flag:
                # Wait for a key press before exiting
                self.window.nodelay(False)
                self.window.getch()
                break

            elapsed: float = time.time() - frame_start
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Curses wrapper entry point."""
    game: Game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)
```
----- snake.py
```## snake.py
"""
Snake component for the console Snake game.

This module implements the :class:`Snake` class as specified in the
design documentation.  The implementation is fully typed, avoids
circular imports, and follows the public interface exactly.
"""

from __future__ import annotations

from typing import List, Tuple

# Import Grid only for type checking; no runtime dependency on grid.py
# to avoid circular imports.
from grid import Grid


class Snake:
    """
    Represents the snake in the game.

    Attributes
    ----------
    body : List[Tuple[int, int]]
        Ordered list of grid coordinates from head to tail.
    direction : Tuple[int, int]
        Current movement direction as a (dx, dy) pair.
    _grow_pending : bool
        Flag indicating whether the snake should grow on the next move.
    """

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        """
        Initialise a new snake.

        Parameters
        ----------
        start_pos : Tuple[int, int]
            Initial head position on the grid.
        start_dir : Tuple[int, int]
            Initial movement direction.
        """
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """
        Move the snake forward by one cell.

        The new head position is calculated from the current head and
        direction.  The new head is inserted at the front of the body
        list.  If a growth is pending, the tail is left intact; otherwise
        the last segment is removed to keep the length constant.
        """
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)

        if self._grow_pending:
            # Consume the growth flag; the snake has grown by one segment.
            self._grow_pending = False
        else:
            # Normal movement: remove the tail segment.
            self.body.pop()

    def grow(self) -> None:
        """
        Schedule the snake to grow on its next move.

        After calling this method, the snake will retain its tail segment
        during the next :meth:`move` call, effectively increasing its
        length by one.
        """
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """
        Change the snake's direction if it is not a 180Â° reversal.

        Parameters
        ----------
        new_dir : Tuple[int, int]
            Desired new direction as a (dx, dy) pair.
        """
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        # Prevent the snake from reversing onto itself.
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """
        Check whether the snake's head collides with its body.

        Returns
        -------
        bool
            ``True`` if the head occupies the same cell as any other
            segment of the body.
        """
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """
        Check whether the snake's head has moved outside the grid.

        Parameters
        ----------
        grid : Grid
            The game grid used for boundary checks.

        Returns
        -------
        bool
            ``True`` if the head position is not within the grid bounds.
        """
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """
        Retrieve the current head position.

        Returns
        -------
        Tuple[int, int]
            The (x, y) coordinates of the snake's head.
        """
        return self.body[0]
```
```

## Debug logs
```text



```

## Bug Feedback logs
```text

```

# Format example
## Code: food.py
```python
## food.py
...
```

# Instruction: Based on the context, follow "Format example", write code.

## Code: food.py. Write code with triple quoto, based on the following attentions and context.
1. Only One file: do your best to implement THIS ONLY ONE FILE.
2. COMPLETE CODE: Your code will be part of the entire project, so please implement complete, reliable, reusable code snippets.
3. Set default value: If there is any setting, ALWAYS SET A DEFAULT VALUE, ALWAYS USE STRONG TYPE AND EXPLICIT VARIABLE. AVOID circular import.
4. Follow design: YOU MUST FOLLOW "Data structures and interfaces". DONT CHANGE ANY DESIGN. Do not use public member functions that do not exist in your design.
5. CAREFULLY CHECK THAT YOU DONT MISS ANY NECESSARY CLASS/FUNCTION IN THIS FILE.
6. Before using a external variable/module, make sure you import it first.
7. Write out EVERY CODE DETAIL, DON'T LEAVE TODO.






# System
Role: You are a professional software engineer, and your main task is to review and revise the code. You need to ensure that the code conforms to the google-style standards, is elegantly designed and modularized, easy to read and maintain.
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## System Design
{"Implementation approach":"We will build the game as a small, selfâcontained console application using the standard `curses` library for realâtime keyboard input and screen drawing. The core logic will be split into a handful of focused classes:\n\n* **Game** â owns the main loop, coordinates input, update and rendering, and manages the overall state (running, paused, gameâover).\n* **Snake** â stores the ordered list of grid coordinates that make up the snake, handles movement, growth and collision checks.\n* **Food** â keeps the current food position and can generate a new one that never overlaps the snake.\n* **Grid** â represents the 10Ã10 board, provides bounds checking and a helper to convert coordinates to screen positions.\n* **Renderer** â draws the grid, snake, food and UI elements (score, gameâover message) onto the curses window.\n* **InputHandler** â translates arrowâkey events into direction changes while preventing 180Â° reversals.\n\nThe game loop will run at a fixed tick rate (e.g. 10 frames per second). Each tick we:\n1. Poll for a key press.\n2. Update the snakeâs direction.\n3. Move the snake forward.\n4. Check for collisions (wall, self, food).\n5. Grow the snake and update the score if food is eaten.\n6. Render the updated state.\n\nThis separation keeps the code testable, readable and easily extensible (e.g. adding levels or AI). All state is kept in plain Python data structures (lists, tuples, ints) so no external dependencies are required beyond the standard library.\n\n","File list":["main.py","game.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -grid: Grid\n        -snake: Snake\n        -food: Food\n        -renderer: Renderer\n        -input_handler: InputHandler\n        -score: int\n        -running: bool\n        +__init__(window: curses.window)\n        +start() void\n        +handle_input() void\n        +update() void\n        +render() void\n        +game_over() void\n    }\n    class Snake {\n        -body: List[Tuple[int,int]]\n        -direction: Tuple[int,int]\n        +__init__(start_pos: Tuple[int,int], start_dir: Tuple[int,int])\n        +move() void\n        +grow() void\n        +set_direction(new_dir: Tuple[int,int]) void\n        +collides_with_self() bool\n        +collides_with_wall(grid: Grid) bool\n        +head() Tuple[int,int]\n    }\n    class Food {\n        -position: Tuple[int,int]\n        +__init__(grid: Grid, snake: Snake)\n        +generate_new(grid: Grid, snake: Snake) void\n        +position() Tuple[int,int]\n    }\n    class Grid {\n        -width: int\n        -height: int\n        +__init__(width: int, height: int)\n        +in_bounds(pos: Tuple[int,int]) bool\n        +to_screen_coords(pos: Tuple[int,int]) Tuple[int,int]\n    }\n    class Renderer {\n        -window: curses.window\n        +__init__(window: curses.window)\n        +draw(grid: Grid, snake: Snake, food: Food, score: int, game_over: bool) void\n        +clear() void\n    }\n    class InputHandler {\n        -last_direction: Tuple[int,int]\n        +__init__()\n        +get_direction(key: int) Tuple[int,int]\n    }\n    Game --> Snake\n    Game --> Food\n    Game --> Grid\n    Game --> Renderer\n    Game --> InputHandler\n    Snake --> Grid\n    Food --> Grid\n    Renderer --> Grid\n    Renderer --> Snake\n    Renderer --> Food\n","Program call flow":"\nsequenceDiagram\n    participant M as main\n    participant G as Game\n    participant I as InputHandler\n    participant S as Snake\n    participant F as Food\n    participant R as Renderer\n    participant Gd as Grid\n\n    M->>G: __init__(curses_window)\n    G->>Gd: __init__(10,10)\n    G->>S: __init__(center, RIGHT)\n    G->>F: __init__(Gd, S)\n    G->>R: __init__(curses_window)\n    G->>I: __init__()\n    G->>G: start()\n\n    loop every tick\n        G->>I: get_direction(key)\n        I->>G: set_direction\n        G->>S: move()\n        G->>S: collides_with_self() -> bool\n        alt collision\n            G->>G: game_over()\n            G->>R: draw(..., game_over=true)\n            G->>G: break loop\n        else\n            G->>F: position()\n            alt ate food\n                G->>S: grow()\n                G->>S: score++\n                G->>F: generate_new(Gd, S)\n            end\n            G->>R: draw(..., game_over=false)\n        end\n    end\n","Anything UNCLEAR":"The specification mentions \"optional animations for movement and growth\" but does not detail the desired effect. In a console environment, we can simulate a simple animation by briefly flashing the new head position or adding a short delay after growth. If more elaborate animations (e.g., smooth scrolling) are required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or if a graphical window is expected."}

## Task
{"Required Python packages":["No external packages required; uses only the standard library (curses, typing, etc.)"],"Required Other language third-party packages":["No thirdâparty dependencies required"],"Logic Analysis":[["main.py","Imports Game from game.py, initializes curses, creates Game instance, calls start()"],["game.py","Defines Game class: manages main loop, holds Grid, Snake, Food, Renderer, InputHandler, score, running flag; imports all component classes"],["snake.py","Defines Snake class: body list, direction tuple, move(), grow(), set_direction(), collides_with_self(), collides_with_wall(), head()"],["food.py","Defines Food class: position tuple, generate_new() that picks a random free cell, position() accessor"],["grid.py","Defines Grid class: width, height, in_bounds(), to_screen_coords()"],["renderer.py","Defines Renderer class: draws grid, snake, food, score, gameâover message; uses curses window"],["input_handler.py","Defines InputHandler class: get_direction() translates key codes to direction tuples, prevents 180Â° reversal"]],"Task list":["main.py","game.py","snake.py","food.py","grid.py","renderer.py","input_handler.py"],"Full API spec":"","Shared Knowledge":"All state is stored in plain Python data structures (lists, tuples, ints). The game is a console application using the curses library; no external GUI frameworks are required. Each component is isolated to aid testing and future extension (e.g., adding levels or AI).","Anything UNCLEAR":"The specification mentions optional animations for movement and growth but does not detail the desired effect. In a console environment, a simple flash or brief delay can simulate animation. If a richer graphical animation is required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or a graphical window is expected."}

## Code Files
----- main.py
```#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple, Optional

# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game state."""
        self.clear()

        # Draw border
        for x in range(grid.width + 2):
            self.window.addch(0, x, '#')
            self.window.addch(grid.height + 1, x, '#')
        for y in range(1, grid.height + 1):
            self.window.addch(y, 0, '#')
            self.window.addch(y, grid.width + 1, '#')

        # Draw food
        fx, fy = food.position
        sy, sx = grid.to_screen_coords((fx, fy))
        self.window.addch(sy + 1, sx + 1, '*')

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            cy, cx = grid.to_screen_coords((sx, sy))
            char = '@' if idx == 0 else 'O'
            self.window.addch(cy + 1, cx + 1, char)

        # Draw score
        score_text = f"Score: {score}"
        self.window.addstr(grid.height + 3, 0, score_text)

        # Draw game over message
        if game_over:
            msg = "GAME OVER! Press any key to exit."
            self.window.addstr(grid.height // 2, (grid.width - len(msg)) // 2, msg)

        self.window.refresh()


class InputHandler:
    """Translates key presses into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return a new direction based on the key, or keep current."""
        mapping = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        if new_dir != (-self.last_direction[0], -self.last_direction[1]):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per tick (10 FPS)

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (self.grid.width // 2, self.grid.height // 2)
        start_dir: Tuple[int, int] = (1, 0)  # Right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            start_time = time.time()

            # Handle input
            key = self.window.getch()
            if key != -1:
                new_dir = self.input_handler.get_direction(key)
                self.snake.set_direction(new_dir)

            # Update game state
            self.snake.move()

            # Collision checks
            if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
                self.game_over()
            else:
                # Check food consumption
                if self.snake.head() == self.food.position:
                    self.snake.grow()
                    self.score += 1
                    self.food.generate_new(self.grid, self.snake)

            # Render
            self.renderer.draw(
                self.grid,
                self.snake,
                self.food,
                self.score,
                self.game_over_flag,
            )

            # If game over, wait for key press to exit
            if self.game_over_flag:
                self.window.nodelay(False)
                self.window.getch()
                break

            # Maintain tick rate
            elapsed = time.time() - start_time
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Initialize and start the game."""
    game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)
```
----- game.py
```#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple


# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game screen."""
        self.clear()

        # Draw border
        for x in range(grid.width):
            self.window.addch(0, x, curses.ACS_HLINE)
            self.window.addch(grid.height + 1, x, curses.ACS_HLINE)
        for y in range(grid.height + 2):
            self.window.addch(y, 0, curses.ACS_VLINE)
            self.window.addch(y, grid.width + 1, curses.ACS_VLINE)
        self.window.addch(0, 0, curses.ACS_ULCORNER)
        self.window.addch(0, grid.width + 1, curses.ACS_URCORNER)
        self.window.addch(grid.height + 1, 0, curses.ACS_LLCORNER)
        self.window.addch(grid.height + 1, grid.width + 1, curses.ACS_LRCORNER)

        # Draw food
        fx, fy = food.position
        fy_screen, fx_screen = grid.to_screen_coords((fx, fy))
        self.window.addch(fy_screen + 1, fx_screen + 1, curses.ACS_PI)

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            sy_screen, sx_screen = grid.to_screen_coords((sx, sy))
            sy_screen += 1
            sx_screen += 1
            char: str = "@" if idx == 0 else "O"
            self.window.addch(sy_screen, sx_screen, char)

        # Draw score
        score_y: int = grid.height + 3
        score_x: int = 0
        score_text: str = f"Score: {score}"
        self.window.addstr(score_y, score_x, score_text)

        # Draw game over message if needed
        if game_over:
            msg: str = "GAME OVER! Press any key to exit."
            msg_y: int = grid.height // 2 + 1
            msg_x: int = (grid.width - len(msg)) // 2 + 1
            self.window.addstr(msg_y, msg_x, msg)

        self.window.refresh()


class InputHandler:
    """Processes user input and translates it into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default to moving right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return the new direction based on the pressed key."""
        mapping: dict[int, Tuple[int, int]] = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir: Tuple[int, int] = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        cur_dx, cur_dy = self.last_direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per frame

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window

        # Initialize components
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (
            self.grid.width // 2,
            self.grid.height // 2,
        )
        start_dir: Tuple[int, int] = (1, 0)  # Moving right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()

        # Game state
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    # ------------------------------------------------------------------
    # Game loop helpers
    # ------------------------------------------------------------------

    def handle_input(self) -> None:
        """Read user input and update snake direction."""
        key: int = self.window.getch()
        if key != -1:
            new_dir: Tuple[int, int] = self.input_handler.get_direction(key)
            self.snake.set_direction(new_dir)

    def update(self) -> None:
        """Advance game state: move snake, check collisions, handle food."""
        self.snake.move()

        # Collision detection
        if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
            self.game_over()
            return

        # Food consumption
        if self.snake.head() == self.food.position:
            self.snake.grow()
            self.score += 1
            self.food.generate_new(self.grid, self.snake)

    def render(self) -> None:
        """Render the current game state."""
        self.renderer.draw(
            self.grid,
            self.snake,
            self.food,
            self.score,
            self.game_over_flag,
        )

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True

    # ------------------------------------------------------------------
    # Main loop
    # ------------------------------------------------------------------

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            frame_start: float = time.time()

            self.handle_input()
            self.update()
            self.render()

            if self.game_over_flag:
                # Wait for a key press before exiting
                self.window.nodelay(False)
                self.window.getch()
                break

            elapsed: float = time.time() - frame_start
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Curses wrapper entry point."""
    game: Game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)
```
----- snake.py
```## snake.py
"""
Snake component for the console Snake game.

This module implements the :class:`Snake` class as specified in the
design documentation.  The implementation is fully typed, avoids
circular imports, and follows the public interface exactly.
"""

from __future__ import annotations

from typing import List, Tuple

# Import Grid only for type checking; no runtime dependency on grid.py
# to avoid circular imports.
from grid import Grid


class Snake:
    """
    Represents the snake in the game.

    Attributes
    ----------
    body : List[Tuple[int, int]]
        Ordered list of grid coordinates from head to tail.
    direction : Tuple[int, int]
        Current movement direction as a (dx, dy) pair.
    _grow_pending : bool
        Flag indicating whether the snake should grow on the next move.
    """

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        """
        Initialise a new snake.

        Parameters
        ----------
        start_pos : Tuple[int, int]
            Initial head position on the grid.
        start_dir : Tuple[int, int]
            Initial movement direction.
        """
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """
        Move the snake forward by one cell.

        The new head position is calculated from the current head and
        direction.  The new head is inserted at the front of the body
        list.  If a growth is pending, the tail is left intact; otherwise
        the last segment is removed to keep the length constant.
        """
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)

        if self._grow_pending:
            # Consume the growth flag; the snake has grown by one segment.
            self._grow_pending = False
        else:
            # Normal movement: remove the tail segment.
            self.body.pop()

    def grow(self) -> None:
        """
        Schedule the snake to grow on its next move.

        After calling this method, the snake will retain its tail segment
        during the next :meth:`move` call, effectively increasing its
        length by one.
        """
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """
        Change the snake's direction if it is not a 180Â° reversal.

        Parameters
        ----------
        new_dir : Tuple[int, int]
            Desired new direction as a (dx, dy) pair.
        """
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        # Prevent the snake from reversing onto itself.
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """
        Check whether the snake's head collides with its body.

        Returns
        -------
        bool
            ``True`` if the head occupies the same cell as any other
            segment of the body.
        """
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """
        Check whether the snake's head has moved outside the grid.

        Parameters
        ----------
        grid : Grid
            The game grid used for boundary checks.

        Returns
        -------
        bool
            ``True`` if the head position is not within the grid bounds.
        """
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """
        Retrieve the current head position.

        Returns
        -------
        Tuple[int, int]
            The (x, y) coordinates of the snake's head.
        """
        return self.body[0]
```


## Code to be Reviewed: food.py
```Code
## food.py
"""
Food component for the console Snake game.

This module implements the :class:`Food` class as specified in the
design documentation.  The implementation is fully typed, avoids
circular imports, and follows the public interface exactly.
"""

from __future__ import annotations

import random
from typing import Tuple, List

# Import Grid and Snake only for type checking; no runtime dependency on
# food.py to avoid circular imports.
from grid import Grid
from snake import Snake


class Food:
    """
    Represents the food item in the game.

    Attributes
    ----------
    position : Tuple[int, int]
        Current grid coordinates of the food.
    """

    def __init__(self, grid: Grid, snake: Snake) -> None:
        """
        Initialise a new food instance.

        Parameters
        ----------
        grid : Grid
            The game grid used for boundary checks.
        snake : Snake
            The snake instance; used to avoid placing food on the snake.
        """
        # Default position; will be overwritten by generate_new.
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """
        Place food on a random free cell.

        The method scans all cells in the grid, filters out those
        occupied by the snake, and selects one at random.  If the
        snake occupies the entire grid, the current position is
        retained.

        Parameters
        ----------
        grid : Grid
            The game grid used for boundary checks.
        snake : Snake
            The snake instance; used to avoid placing food on the snake.
        """
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]

        if not free_cells:
            # No free space left; keep current position
            return

        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """
        Return the current food position.

        Returns
        -------
        Tuple[int, int]
            The (x, y) coordinates of the food.
        """
        return self.position

```



# Format example 1
## Code Review: food.py
1. No, we should fix the logic of class A due to ...
2. ...
3. ...
4. No, function B is not implemented, ...
5. ...
6. ...

## Actions
1. Fix the `handle_events` method to update the game state only if a move is successful.
   ```python
   def handle_events(self):
       for event in pygame.event.get():
           if event.type == pygame.QUIT:
               return False
           if event.type == pygame.KEYDOWN:
               moved = False
               if event.key == pygame.K_UP:
                   moved = self.game.move('UP')
               elif event.key == pygame.K_DOWN:
                   moved = self.game.move('DOWN')
               elif event.key == pygame.K_LEFT:
                   moved = self.game.move('LEFT')
               elif event.key == pygame.K_RIGHT:
                   moved = self.game.move('RIGHT')
               if moved:
                   # Update the game state only if a move was successful
                   self.render()
       return True
   ```
2. Implement function B

## Code Review Result
LBTM

# Format example 2
## Code Review: food.py
1. Yes.
2. Yes.
3. Yes.
4. Yes.
5. Yes.
6. Yes.

## Actions
pass

## Code Review Result
LGTM



# Instruction: Based on the actual code situation, follow one of the "Format example". Return only 1 file under review.

## Code Review: Ordered List. Based on the "Code to be Reviewed", provide key, clear, concise, and specific answer. If any answer is no, explain how to fix it step by step.
1. Is the code implemented as per the requirements? If not, how to achieve it? Analyse it step by step.
2. Is the code logic completely correct? If there are errors, please indicate how to correct them.
3. Does the existing code follow the "Data structures and interfaces"?
4. Are all functions implemented? If there is no implementation, please indicate how to achieve it step by step.
5. Have all necessary pre-dependencies been imported? If not, indicate which ones need to be imported
6. Are methods from other files being reused correctly?

## Actions: Ordered List. Things that should be done after CR, such as implementing class A and function B

## Code Review Result: str. If the code doesn't have bugs, we don't need to rewrite it, so answer LGTM and stop. ONLY ANSWER LGTM/LBTM.
LGTM/LBTM






# System
Role: You are a professional software engineer, and your main task is to review and revise the code. You need to ensure that the code conforms to the google-style standards, is elegantly designed and modularized, easy to read and maintain.
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## System Design
{"Implementation approach":"We will build the game as a small, selfâcontained console application using the standard `curses` library for realâtime keyboard input and screen drawing. The core logic will be split into a handful of focused classes:\n\n* **Game** â owns the main loop, coordinates input, update and rendering, and manages the overall state (running, paused, gameâover).\n* **Snake** â stores the ordered list of grid coordinates that make up the snake, handles movement, growth and collision checks.\n* **Food** â keeps the current food position and can generate a new one that never overlaps the snake.\n* **Grid** â represents the 10Ã10 board, provides bounds checking and a helper to convert coordinates to screen positions.\n* **Renderer** â draws the grid, snake, food and UI elements (score, gameâover message) onto the curses window.\n* **InputHandler** â translates arrowâkey events into direction changes while preventing 180Â° reversals.\n\nThe game loop will run at a fixed tick rate (e.g. 10 frames per second). Each tick we:\n1. Poll for a key press.\n2. Update the snakeâs direction.\n3. Move the snake forward.\n4. Check for collisions (wall, self, food).\n5. Grow the snake and update the score if food is eaten.\n6. Render the updated state.\n\nThis separation keeps the code testable, readable and easily extensible (e.g. adding levels or AI). All state is kept in plain Python data structures (lists, tuples, ints) so no external dependencies are required beyond the standard library.\n\n","File list":["main.py","game.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -grid: Grid\n        -snake: Snake\n        -food: Food\n        -renderer: Renderer\n        -input_handler: InputHandler\n        -score: int\n        -running: bool\n        +__init__(window: curses.window)\n        +start() void\n        +handle_input() void\n        +update() void\n        +render() void\n        +game_over() void\n    }\n    class Snake {\n        -body: List[Tuple[int,int]]\n        -direction: Tuple[int,int]\n        +__init__(start_pos: Tuple[int,int], start_dir: Tuple[int,int])\n        +move() void\n        +grow() void\n        +set_direction(new_dir: Tuple[int,int]) void\n        +collides_with_self() bool\n        +collides_with_wall(grid: Grid) bool\n        +head() Tuple[int,int]\n    }\n    class Food {\n        -position: Tuple[int,int]\n        +__init__(grid: Grid, snake: Snake)\n        +generate_new(grid: Grid, snake: Snake) void\n        +position() Tuple[int,int]\n    }\n    class Grid {\n        -width: int\n        -height: int\n        +__init__(width: int, height: int)\n        +in_bounds(pos: Tuple[int,int]) bool\n        +to_screen_coords(pos: Tuple[int,int]) Tuple[int,int]\n    }\n    class Renderer {\n        -window: curses.window\n        +__init__(window: curses.window)\n        +draw(grid: Grid, snake: Snake, food: Food, score: int, game_over: bool) void\n        +clear() void\n    }\n    class InputHandler {\n        -last_direction: Tuple[int,int]\n        +__init__()\n        +get_direction(key: int) Tuple[int,int]\n    }\n    Game --> Snake\n    Game --> Food\n    Game --> Grid\n    Game --> Renderer\n    Game --> InputHandler\n    Snake --> Grid\n    Food --> Grid\n    Renderer --> Grid\n    Renderer --> Snake\n    Renderer --> Food\n","Program call flow":"\nsequenceDiagram\n    participant M as main\n    participant G as Game\n    participant I as InputHandler\n    participant S as Snake\n    participant F as Food\n    participant R as Renderer\n    participant Gd as Grid\n\n    M->>G: __init__(curses_window)\n    G->>Gd: __init__(10,10)\n    G->>S: __init__(center, RIGHT)\n    G->>F: __init__(Gd, S)\n    G->>R: __init__(curses_window)\n    G->>I: __init__()\n    G->>G: start()\n\n    loop every tick\n        G->>I: get_direction(key)\n        I->>G: set_direction\n        G->>S: move()\n        G->>S: collides_with_self() -> bool\n        alt collision\n            G->>G: game_over()\n            G->>R: draw(..., game_over=true)\n            G->>G: break loop\n        else\n            G->>F: position()\n            alt ate food\n                G->>S: grow()\n                G->>S: score++\n                G->>F: generate_new(Gd, S)\n            end\n            G->>R: draw(..., game_over=false)\n        end\n    end\n","Anything UNCLEAR":"The specification mentions \"optional animations for movement and growth\" but does not detail the desired effect. In a console environment, we can simulate a simple animation by briefly flashing the new head position or adding a short delay after growth. If more elaborate animations (e.g., smooth scrolling) are required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or if a graphical window is expected."}

## Task
{"Required Python packages":["No external packages required; uses only the standard library (curses, typing, etc.)"],"Required Other language third-party packages":["No thirdâparty dependencies required"],"Logic Analysis":[["main.py","Imports Game from game.py, initializes curses, creates Game instance, calls start()"],["game.py","Defines Game class: manages main loop, holds Grid, Snake, Food, Renderer, InputHandler, score, running flag; imports all component classes"],["snake.py","Defines Snake class: body list, direction tuple, move(), grow(), set_direction(), collides_with_self(), collides_with_wall(), head()"],["food.py","Defines Food class: position tuple, generate_new() that picks a random free cell, position() accessor"],["grid.py","Defines Grid class: width, height, in_bounds(), to_screen_coords()"],["renderer.py","Defines Renderer class: draws grid, snake, food, score, gameâover message; uses curses window"],["input_handler.py","Defines InputHandler class: get_direction() translates key codes to direction tuples, prevents 180Â° reversal"]],"Task list":["main.py","game.py","snake.py","food.py","grid.py","renderer.py","input_handler.py"],"Full API spec":"","Shared Knowledge":"All state is stored in plain Python data structures (lists, tuples, ints). The game is a console application using the curses library; no external GUI frameworks are required. Each component is isolated to aid testing and future extension (e.g., adding levels or AI).","Anything UNCLEAR":"The specification mentions optional animations for movement and growth but does not detail the desired effect. In a console environment, a simple flash or brief delay can simulate animation. If a richer graphical animation is required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or a graphical window is expected."}

## Code Files
----- main.py
```#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple, Optional

# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game state."""
        self.clear()

        # Draw border
        for x in range(grid.width + 2):
            self.window.addch(0, x, '#')
            self.window.addch(grid.height + 1, x, '#')
        for y in range(1, grid.height + 1):
            self.window.addch(y, 0, '#')
            self.window.addch(y, grid.width + 1, '#')

        # Draw food
        fx, fy = food.position
        sy, sx = grid.to_screen_coords((fx, fy))
        self.window.addch(sy + 1, sx + 1, '*')

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            cy, cx = grid.to_screen_coords((sx, sy))
            char = '@' if idx == 0 else 'O'
            self.window.addch(cy + 1, cx + 1, char)

        # Draw score
        score_text = f"Score: {score}"
        self.window.addstr(grid.height + 3, 0, score_text)

        # Draw game over message
        if game_over:
            msg = "GAME OVER! Press any key to exit."
            self.window.addstr(grid.height // 2, (grid.width - len(msg)) // 2, msg)

        self.window.refresh()


class InputHandler:
    """Translates key presses into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return a new direction based on the key, or keep current."""
        mapping = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        if new_dir != (-self.last_direction[0], -self.last_direction[1]):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per tick (10 FPS)

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (self.grid.width // 2, self.grid.height // 2)
        start_dir: Tuple[int, int] = (1, 0)  # Right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            start_time = time.time()

            # Handle input
            key = self.window.getch()
            if key != -1:
                new_dir = self.input_handler.get_direction(key)
                self.snake.set_direction(new_dir)

            # Update game state
            self.snake.move()

            # Collision checks
            if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
                self.game_over()
            else:
                # Check food consumption
                if self.snake.head() == self.food.position:
                    self.snake.grow()
                    self.score += 1
                    self.food.generate_new(self.grid, self.snake)

            # Render
            self.renderer.draw(
                self.grid,
                self.snake,
                self.food,
                self.score,
                self.game_over_flag,
            )

            # If game over, wait for key press to exit
            if self.game_over_flag:
                self.window.nodelay(False)
                self.window.getch()
                break

            # Maintain tick rate
            elapsed = time.time() - start_time
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Initialize and start the game."""
    game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)
```
----- game.py
```#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple


# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game screen."""
        self.clear()

        # Draw border
        for x in range(grid.width):
            self.window.addch(0, x, curses.ACS_HLINE)
            self.window.addch(grid.height + 1, x, curses.ACS_HLINE)
        for y in range(grid.height + 2):
            self.window.addch(y, 0, curses.ACS_VLINE)
            self.window.addch(y, grid.width + 1, curses.ACS_VLINE)
        self.window.addch(0, 0, curses.ACS_ULCORNER)
        self.window.addch(0, grid.width + 1, curses.ACS_URCORNER)
        self.window.addch(grid.height + 1, 0, curses.ACS_LLCORNER)
        self.window.addch(grid.height + 1, grid.width + 1, curses.ACS_LRCORNER)

        # Draw food
        fx, fy = food.position
        fy_screen, fx_screen = grid.to_screen_coords((fx, fy))
        self.window.addch(fy_screen + 1, fx_screen + 1, curses.ACS_PI)

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            sy_screen, sx_screen = grid.to_screen_coords((sx, sy))
            sy_screen += 1
            sx_screen += 1
            char: str = "@" if idx == 0 else "O"
            self.window.addch(sy_screen, sx_screen, char)

        # Draw score
        score_y: int = grid.height + 3
        score_x: int = 0
        score_text: str = f"Score: {score}"
        self.window.addstr(score_y, score_x, score_text)

        # Draw game over message if needed
        if game_over:
            msg: str = "GAME OVER! Press any key to exit."
            msg_y: int = grid.height // 2 + 1
            msg_x: int = (grid.width - len(msg)) // 2 + 1
            self.window.addstr(msg_y, msg_x, msg)

        self.window.refresh()


class InputHandler:
    """Processes user input and translates it into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default to moving right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return the new direction based on the pressed key."""
        mapping: dict[int, Tuple[int, int]] = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir: Tuple[int, int] = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        cur_dx, cur_dy = self.last_direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per frame

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window

        # Initialize components
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (
            self.grid.width // 2,
            self.grid.height // 2,
        )
        start_dir: Tuple[int, int] = (1, 0)  # Moving right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()

        # Game state
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    # ------------------------------------------------------------------
    # Game loop helpers
    # ------------------------------------------------------------------

    def handle_input(self) -> None:
        """Read user input and update snake direction."""
        key: int = self.window.getch()
        if key != -1:
            new_dir: Tuple[int, int] = self.input_handler.get_direction(key)
            self.snake.set_direction(new_dir)

    def update(self) -> None:
        """Advance game state: move snake, check collisions, handle food."""
        self.snake.move()

        # Collision detection
        if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
            self.game_over()
            return

        # Food consumption
        if self.snake.head() == self.food.position:
            self.snake.grow()
            self.score += 1
            self.food.generate_new(self.grid, self.snake)

    def render(self) -> None:
        """Render the current game state."""
        self.renderer.draw(
            self.grid,
            self.snake,
            self.food,
            self.score,
            self.game_over_flag,
        )

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True

    # ------------------------------------------------------------------
    # Main loop
    # ------------------------------------------------------------------

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            frame_start: float = time.time()

            self.handle_input()
            self.update()
            self.render()

            if self.game_over_flag:
                # Wait for a key press before exiting
                self.window.nodelay(False)
                self.window.getch()
                break

            elapsed: float = time.time() - frame_start
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Curses wrapper entry point."""
    game: Game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)
```
----- snake.py
```## snake.py
"""
Snake component for the console Snake game.

This module implements the :class:`Snake` class as specified in the
design documentation.  The implementation is fully typed, avoids
circular imports, and follows the public interface exactly.
"""

from __future__ import annotations

from typing import List, Tuple

# Import Grid only for type checking; no runtime dependency on grid.py
# to avoid circular imports.
from grid import Grid


class Snake:
    """
    Represents the snake in the game.

    Attributes
    ----------
    body : List[Tuple[int, int]]
        Ordered list of grid coordinates from head to tail.
    direction : Tuple[int, int]
        Current movement direction as a (dx, dy) pair.
    _grow_pending : bool
        Flag indicating whether the snake should grow on the next move.
    """

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        """
        Initialise a new snake.

        Parameters
        ----------
        start_pos : Tuple[int, int]
            Initial head position on the grid.
        start_dir : Tuple[int, int]
            Initial movement direction.
        """
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """
        Move the snake forward by one cell.

        The new head position is calculated from the current head and
        direction.  The new head is inserted at the front of the body
        list.  If a growth is pending, the tail is left intact; otherwise
        the last segment is removed to keep the length constant.
        """
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)

        if self._grow_pending:
            # Consume the growth flag; the snake has grown by one segment.
            self._grow_pending = False
        else:
            # Normal movement: remove the tail segment.
            self.body.pop()

    def grow(self) -> None:
        """
        Schedule the snake to grow on its next move.

        After calling this method, the snake will retain its tail segment
        during the next :meth:`move` call, effectively increasing its
        length by one.
        """
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """
        Change the snake's direction if it is not a 180Â° reversal.

        Parameters
        ----------
        new_dir : Tuple[int, int]
            Desired new direction as a (dx, dy) pair.
        """
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        # Prevent the snake from reversing onto itself.
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """
        Check whether the snake's head collides with its body.

        Returns
        -------
        bool
            ``True`` if the head occupies the same cell as any other
            segment of the body.
        """
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """
        Check whether the snake's head has moved outside the grid.

        Parameters
        ----------
        grid : Grid
            The game grid used for boundary checks.

        Returns
        -------
        bool
            ``True`` if the head position is not within the grid bounds.
        """
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """
        Retrieve the current head position.

        Returns
        -------
        Tuple[int, int]
            The (x, y) coordinates of the snake's head.
        """
        return self.body[0]
```


## Code to be Reviewed: food.py
```Code
## food.py
"""
Food component for the console Snake game.

This module implements the :class:`Food` class as specified in the
design documentation.  The implementation is fully typed, avoids
circular imports, and follows the public interface exactly.
"""

from __future__ import annotations

import random
from typing import Tuple, List

# Import Grid and Snake only for type checking; no runtime dependency on
# food.py to avoid circular imports.
from grid import Grid
from snake import Snake


class Food:
    """
    Represents the food item in the game.

    Attributes
    ----------
    position : Tuple[int, int]
        Current grid coordinates of the food.
    """

    def __init__(self, grid: Grid, snake: Snake) -> None:
        """
        Initialise a new food instance.

        Parameters
        ----------
        grid : Grid
            The game grid used for boundary checks.
        snake : Snake
            The snake instance; used to avoid placing food on the snake.
        """
        # Default position; will be overwritten by generate_new.
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """
        Place food on a random free cell.

        The method scans all cells in the grid, filters out those
        occupied by the snake, and selects one at random.  If the
        snake occupies the entire grid, the current position is
        retained.

        Parameters
        ----------
        grid : Grid
            The game grid used for boundary checks.
        snake : Snake
            The snake instance; used to avoid placing food on the snake.
        """
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]

        if not free_cells:
            # No free space left; keep current position
            return

        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """
        Return the current food position.

        Returns
        -------
        Tuple[int, int]
            The (x, y) coordinates of the food.
        """
        return self.position

```

## Code Review: food.py
1. **Requirement compliance**:  
   - The code largely follows the specified requirements, but the `position` method conflicts with the `position` attribute, which prevents accessing the method and violates the intended interface.  
   - **Fix**: Rename the method to `get_position` or expose it as a property.

2. **Logic correctness**:  
   - `generate_new` correctly selects a random free cell.  
   - The method `position(self)` is redundant and incorrectly named; it should be removed or renamed.

3. **Data structures and interfaces**:  
   - The class adheres to the design: it has a `position` attribute and a `generate_new` method.  
   - The interface is respected once the naming conflict is resolved.

4. **All functions implemented**:  
   - All required methods (`__init__`, `generate_new`) are implemented.  
   - The `position` method should be removed or renamed.

5. **Pre-dependencies imported**:  
   - `random`, `Tuple`, `List`, `Grid`, and `Snake` are all imported correctly.

6. **Reuse from other files**:  
   - Uses `grid.width`, `grid.height`, and `snake.body` appropriately.

## Actions
1. Rename the `position` method to `get_position` or convert it to a property:
   ```python
   @property
   def position(self) -> Tuple[int, int]:
       return self._position
   ```
   and rename the attribute to `_position`.
2. Update `__init__` and `generate_new` to use `_position` instead of `position`.

## Code Review Result
LBTM

# Instruction: rewrite code based on the Code Review and Actions
## Rewrite Code: CodeBlock. If it still has some bugs, rewrite food.py with triple quotes. Do your utmost to optimize THIS SINGLE FILE. Return all completed codes and prohibit the return of unfinished codes.
```Code
## food.py
...
```





# System
Role: You are a professional software engineer, and your main task is to review and revise the code. You need to ensure that the code conforms to the google-style standards, is elegantly designed and modularized, easy to read and maintain.
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## System Design
{"Implementation approach":"We will build the game as a small, selfâcontained console application using the standard `curses` library for realâtime keyboard input and screen drawing. The core logic will be split into a handful of focused classes:\n\n* **Game** â owns the main loop, coordinates input, update and rendering, and manages the overall state (running, paused, gameâover).\n* **Snake** â stores the ordered list of grid coordinates that make up the snake, handles movement, growth and collision checks.\n* **Food** â keeps the current food position and can generate a new one that never overlaps the snake.\n* **Grid** â represents the 10Ã10 board, provides bounds checking and a helper to convert coordinates to screen positions.\n* **Renderer** â draws the grid, snake, food and UI elements (score, gameâover message) onto the curses window.\n* **InputHandler** â translates arrowâkey events into direction changes while preventing 180Â° reversals.\n\nThe game loop will run at a fixed tick rate (e.g. 10 frames per second). Each tick we:\n1. Poll for a key press.\n2. Update the snakeâs direction.\n3. Move the snake forward.\n4. Check for collisions (wall, self, food).\n5. Grow the snake and update the score if food is eaten.\n6. Render the updated state.\n\nThis separation keeps the code testable, readable and easily extensible (e.g. adding levels or AI). All state is kept in plain Python data structures (lists, tuples, ints) so no external dependencies are required beyond the standard library.\n\n","File list":["main.py","game.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -grid: Grid\n        -snake: Snake\n        -food: Food\n        -renderer: Renderer\n        -input_handler: InputHandler\n        -score: int\n        -running: bool\n        +__init__(window: curses.window)\n        +start() void\n        +handle_input() void\n        +update() void\n        +render() void\n        +game_over() void\n    }\n    class Snake {\n        -body: List[Tuple[int,int]]\n        -direction: Tuple[int,int]\n        +__init__(start_pos: Tuple[int,int], start_dir: Tuple[int,int])\n        +move() void\n        +grow() void\n        +set_direction(new_dir: Tuple[int,int]) void\n        +collides_with_self() bool\n        +collides_with_wall(grid: Grid) bool\n        +head() Tuple[int,int]\n    }\n    class Food {\n        -position: Tuple[int,int]\n        +__init__(grid: Grid, snake: Snake)\n        +generate_new(grid: Grid, snake: Snake) void\n        +position() Tuple[int,int]\n    }\n    class Grid {\n        -width: int\n        -height: int\n        +__init__(width: int, height: int)\n        +in_bounds(pos: Tuple[int,int]) bool\n        +to_screen_coords(pos: Tuple[int,int]) Tuple[int,int]\n    }\n    class Renderer {\n        -window: curses.window\n        +__init__(window: curses.window)\n        +draw(grid: Grid, snake: Snake, food: Food, score: int, game_over: bool) void\n        +clear() void\n    }\n    class InputHandler {\n        -last_direction: Tuple[int,int]\n        +__init__()\n        +get_direction(key: int) Tuple[int,int]\n    }\n    Game --> Snake\n    Game --> Food\n    Game --> Grid\n    Game --> Renderer\n    Game --> InputHandler\n    Snake --> Grid\n    Food --> Grid\n    Renderer --> Grid\n    Renderer --> Snake\n    Renderer --> Food\n","Program call flow":"\nsequenceDiagram\n    participant M as main\n    participant G as Game\n    participant I as InputHandler\n    participant S as Snake\n    participant F as Food\n    participant R as Renderer\n    participant Gd as Grid\n\n    M->>G: __init__(curses_window)\n    G->>Gd: __init__(10,10)\n    G->>S: __init__(center, RIGHT)\n    G->>F: __init__(Gd, S)\n    G->>R: __init__(curses_window)\n    G->>I: __init__()\n    G->>G: start()\n\n    loop every tick\n        G->>I: get_direction(key)\n        I->>G: set_direction\n        G->>S: move()\n        G->>S: collides_with_self() -> bool\n        alt collision\n            G->>G: game_over()\n            G->>R: draw(..., game_over=true)\n            G->>G: break loop\n        else\n            G->>F: position()\n            alt ate food\n                G->>S: grow()\n                G->>S: score++\n                G->>F: generate_new(Gd, S)\n            end\n            G->>R: draw(..., game_over=false)\n        end\n    end\n","Anything UNCLEAR":"The specification mentions \"optional animations for movement and growth\" but does not detail the desired effect. In a console environment, we can simulate a simple animation by briefly flashing the new head position or adding a short delay after growth. If more elaborate animations (e.g., smooth scrolling) are required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or if a graphical window is expected."}

## Task
{"Required Python packages":["No external packages required; uses only the standard library (curses, typing, etc.)"],"Required Other language third-party packages":["No thirdâparty dependencies required"],"Logic Analysis":[["main.py","Imports Game from game.py, initializes curses, creates Game instance, calls start()"],["game.py","Defines Game class: manages main loop, holds Grid, Snake, Food, Renderer, InputHandler, score, running flag; imports all component classes"],["snake.py","Defines Snake class: body list, direction tuple, move(), grow(), set_direction(), collides_with_self(), collides_with_wall(), head()"],["food.py","Defines Food class: position tuple, generate_new() that picks a random free cell, position() accessor"],["grid.py","Defines Grid class: width, height, in_bounds(), to_screen_coords()"],["renderer.py","Defines Renderer class: draws grid, snake, food, score, gameâover message; uses curses window"],["input_handler.py","Defines InputHandler class: get_direction() translates key codes to direction tuples, prevents 180Â° reversal"]],"Task list":["main.py","game.py","snake.py","food.py","grid.py","renderer.py","input_handler.py"],"Full API spec":"","Shared Knowledge":"All state is stored in plain Python data structures (lists, tuples, ints). The game is a console application using the curses library; no external GUI frameworks are required. Each component is isolated to aid testing and future extension (e.g., adding levels or AI).","Anything UNCLEAR":"The specification mentions optional animations for movement and growth but does not detail the desired effect. In a console environment, a simple flash or brief delay can simulate animation. If a richer graphical animation is required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or a graphical window is expected."}

## Code Files
----- main.py
```#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple, Optional

# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game state."""
        self.clear()

        # Draw border
        for x in range(grid.width + 2):
            self.window.addch(0, x, '#')
            self.window.addch(grid.height + 1, x, '#')
        for y in range(1, grid.height + 1):
            self.window.addch(y, 0, '#')
            self.window.addch(y, grid.width + 1, '#')

        # Draw food
        fx, fy = food.position
        sy, sx = grid.to_screen_coords((fx, fy))
        self.window.addch(sy + 1, sx + 1, '*')

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            cy, cx = grid.to_screen_coords((sx, sy))
            char = '@' if idx == 0 else 'O'
            self.window.addch(cy + 1, cx + 1, char)

        # Draw score
        score_text = f"Score: {score}"
        self.window.addstr(grid.height + 3, 0, score_text)

        # Draw game over message
        if game_over:
            msg = "GAME OVER! Press any key to exit."
            self.window.addstr(grid.height // 2, (grid.width - len(msg)) // 2, msg)

        self.window.refresh()


class InputHandler:
    """Translates key presses into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return a new direction based on the key, or keep current."""
        mapping = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        if new_dir != (-self.last_direction[0], -self.last_direction[1]):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per tick (10 FPS)

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (self.grid.width // 2, self.grid.height // 2)
        start_dir: Tuple[int, int] = (1, 0)  # Right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            start_time = time.time()

            # Handle input
            key = self.window.getch()
            if key != -1:
                new_dir = self.input_handler.get_direction(key)
                self.snake.set_direction(new_dir)

            # Update game state
            self.snake.move()

            # Collision checks
            if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
                self.game_over()
            else:
                # Check food consumption
                if self.snake.head() == self.food.position:
                    self.snake.grow()
                    self.score += 1
                    self.food.generate_new(self.grid, self.snake)

            # Render
            self.renderer.draw(
                self.grid,
                self.snake,
                self.food,
                self.score,
                self.game_over_flag,
            )

            # If game over, wait for key press to exit
            if self.game_over_flag:
                self.window.nodelay(False)
                self.window.getch()
                break

            # Maintain tick rate
            elapsed = time.time() - start_time
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Initialize and start the game."""
    game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)
```
----- game.py
```#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple


# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game screen."""
        self.clear()

        # Draw border
        for x in range(grid.width):
            self.window.addch(0, x, curses.ACS_HLINE)
            self.window.addch(grid.height + 1, x, curses.ACS_HLINE)
        for y in range(grid.height + 2):
            self.window.addch(y, 0, curses.ACS_VLINE)
            self.window.addch(y, grid.width + 1, curses.ACS_VLINE)
        self.window.addch(0, 0, curses.ACS_ULCORNER)
        self.window.addch(0, grid.width + 1, curses.ACS_URCORNER)
        self.window.addch(grid.height + 1, 0, curses.ACS_LLCORNER)
        self.window.addch(grid.height + 1, grid.width + 1, curses.ACS_LRCORNER)

        # Draw food
        fx, fy = food.position
        fy_screen, fx_screen = grid.to_screen_coords((fx, fy))
        self.window.addch(fy_screen + 1, fx_screen + 1, curses.ACS_PI)

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            sy_screen, sx_screen = grid.to_screen_coords((sx, sy))
            sy_screen += 1
            sx_screen += 1
            char: str = "@" if idx == 0 else "O"
            self.window.addch(sy_screen, sx_screen, char)

        # Draw score
        score_y: int = grid.height + 3
        score_x: int = 0
        score_text: str = f"Score: {score}"
        self.window.addstr(score_y, score_x, score_text)

        # Draw game over message if needed
        if game_over:
            msg: str = "GAME OVER! Press any key to exit."
            msg_y: int = grid.height // 2 + 1
            msg_x: int = (grid.width - len(msg)) // 2 + 1
            self.window.addstr(msg_y, msg_x, msg)

        self.window.refresh()


class InputHandler:
    """Processes user input and translates it into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default to moving right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return the new direction based on the pressed key."""
        mapping: dict[int, Tuple[int, int]] = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir: Tuple[int, int] = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        cur_dx, cur_dy = self.last_direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per frame

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window

        # Initialize components
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (
            self.grid.width // 2,
            self.grid.height // 2,
        )
        start_dir: Tuple[int, int] = (1, 0)  # Moving right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()

        # Game state
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    # ------------------------------------------------------------------
    # Game loop helpers
    # ------------------------------------------------------------------

    def handle_input(self) -> None:
        """Read user input and update snake direction."""
        key: int = self.window.getch()
        if key != -1:
            new_dir: Tuple[int, int] = self.input_handler.get_direction(key)
            self.snake.set_direction(new_dir)

    def update(self) -> None:
        """Advance game state: move snake, check collisions, handle food."""
        self.snake.move()

        # Collision detection
        if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
            self.game_over()
            return

        # Food consumption
        if self.snake.head() == self.food.position:
            self.snake.grow()
            self.score += 1
            self.food.generate_new(self.grid, self.snake)

    def render(self) -> None:
        """Render the current game state."""
        self.renderer.draw(
            self.grid,
            self.snake,
            self.food,
            self.score,
            self.game_over_flag,
        )

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True

    # ------------------------------------------------------------------
    # Main loop
    # ------------------------------------------------------------------

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            frame_start: float = time.time()

            self.handle_input()
            self.update()
            self.render()

            if self.game_over_flag:
                # Wait for a key press before exiting
                self.window.nodelay(False)
                self.window.getch()
                break

            elapsed: float = time.time() - frame_start
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Curses wrapper entry point."""
    game: Game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)
```
----- snake.py
```## snake.py
"""
Snake component for the console Snake game.

This module implements the :class:`Snake` class as specified in the
design documentation.  The implementation is fully typed, avoids
circular imports, and follows the public interface exactly.
"""

from __future__ import annotations

from typing import List, Tuple

# Import Grid only for type checking; no runtime dependency on grid.py
# to avoid circular imports.
from grid import Grid


class Snake:
    """
    Represents the snake in the game.

    Attributes
    ----------
    body : List[Tuple[int, int]]
        Ordered list of grid coordinates from head to tail.
    direction : Tuple[int, int]
        Current movement direction as a (dx, dy) pair.
    _grow_pending : bool
        Flag indicating whether the snake should grow on the next move.
    """

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        """
        Initialise a new snake.

        Parameters
        ----------
        start_pos : Tuple[int, int]
            Initial head position on the grid.
        start_dir : Tuple[int, int]
            Initial movement direction.
        """
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """
        Move the snake forward by one cell.

        The new head position is calculated from the current head and
        direction.  The new head is inserted at the front of the body
        list.  If a growth is pending, the tail is left intact; otherwise
        the last segment is removed to keep the length constant.
        """
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)

        if self._grow_pending:
            # Consume the growth flag; the snake has grown by one segment.
            self._grow_pending = False
        else:
            # Normal movement: remove the tail segment.
            self.body.pop()

    def grow(self) -> None:
        """
        Schedule the snake to grow on its next move.

        After calling this method, the snake will retain its tail segment
        during the next :meth:`move` call, effectively increasing its
        length by one.
        """
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """
        Change the snake's direction if it is not a 180Â° reversal.

        Parameters
        ----------
        new_dir : Tuple[int, int]
            Desired new direction as a (dx, dy) pair.
        """
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        # Prevent the snake from reversing onto itself.
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """
        Check whether the snake's head collides with its body.

        Returns
        -------
        bool
            ``True`` if the head occupies the same cell as any other
            segment of the body.
        """
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """
        Check whether the snake's head has moved outside the grid.

        Parameters
        ----------
        grid : Grid
            The game grid used for boundary checks.

        Returns
        -------
        bool
            ``True`` if the head position is not within the grid bounds.
        """
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """
        Retrieve the current head position.

        Returns
        -------
        Tuple[int, int]
            The (x, y) coordinates of the snake's head.
        """
        return self.body[0]
```


## Code to be Reviewed: food.py
```Code
## food.py
"""
Food component for the console Snake game.

This module implements the :class:`Food` class as specified in the
design documentation.  It is fully typed, avoids circular imports,
and exposes a clean public interface.

The class maintains a private ``_position`` attribute and exposes it
via a readâonly :pyattr:`position` property.  The ``generate_new`` method
places the food on a random free cell of the grid, avoiding the snake.
"""

from __future__ import annotations

import random
from typing import Tuple, List

# Import Grid and Snake only for type checking; this avoids circular
# imports at runtime while still providing full type information.
from grid import Grid
from snake import Snake


class Food:
    """
    Represents the food item in the game.

    Parameters
    ----------
    grid : Grid
        The game grid used for boundary checks.
    snake : Snake
        The snake instance; used to avoid placing food on the snake.

    Attributes
    ----------
    position : Tuple[int, int]
        Current grid coordinates of the food.
    """

    def __init__(self, grid: Grid, snake: Snake) -> None:
        """
        Initialise a new food instance.

        The default position is overwritten by :meth:`generate_new`.
        """
        self._position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """
        Place food on a random free cell.

        The method scans all cells in the grid, filters out those
        occupied by the snake, and selects one at random.  If the
        snake occupies the entire grid, the current position is
        retained.

        Parameters
        ----------
        grid : Grid
            The game grid used for boundary checks.
        snake : Snake
            The snake instance; used to avoid placing food on the snake.
        """
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]

        if not free_cells:
            # No free space left; keep current position
            return

        self._position = random.choice(free_cells)

    @property
    def position(self) -> Tuple[int, int]:
        """
        Return the current food position.

        Returns
        -------
        Tuple[int, int]
            The (x, y) coordinates of the food.
        """
        return self._position

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(position={self._position!r})"

```



# Format example 1
## Code Review: food.py
1. No, we should fix the logic of class A due to ...
2. ...
3. ...
4. No, function B is not implemented, ...
5. ...
6. ...

## Actions
1. Fix the `handle_events` method to update the game state only if a move is successful.
   ```python
   def handle_events(self):
       for event in pygame.event.get():
           if event.type == pygame.QUIT:
               return False
           if event.type == pygame.KEYDOWN:
               moved = False
               if event.key == pygame.K_UP:
                   moved = self.game.move('UP')
               elif event.key == pygame.K_DOWN:
                   moved = self.game.move('DOWN')
               elif event.key == pygame.K_LEFT:
                   moved = self.game.move('LEFT')
               elif event.key == pygame.K_RIGHT:
                   moved = self.game.move('RIGHT')
               if moved:
                   # Update the game state only if a move was successful
                   self.render()
       return True
   ```
2. Implement function B

## Code Review Result
LBTM

# Format example 2
## Code Review: food.py
1. Yes.
2. Yes.
3. Yes.
4. Yes.
5. Yes.
6. Yes.

## Actions
pass

## Code Review Result
LGTM



# Instruction: Based on the actual code situation, follow one of the "Format example". Return only 1 file under review.

## Code Review: Ordered List. Based on the "Code to be Reviewed", provide key, clear, concise, and specific answer. If any answer is no, explain how to fix it step by step.
1. Is the code implemented as per the requirements? If not, how to achieve it? Analyse it step by step.
2. Is the code logic completely correct? If there are errors, please indicate how to correct them.
3. Does the existing code follow the "Data structures and interfaces"?
4. Are all functions implemented? If there is no implementation, please indicate how to achieve it step by step.
5. Have all necessary pre-dependencies been imported? If not, indicate which ones need to be imported
6. Are methods from other files being reused correctly?

## Actions: Ordered List. Things that should be done after CR, such as implementing class A and function B

## Code Review Result: str. If the code doesn't have bugs, we don't need to rewrite it, so answer LGTM and stop. ONLY ANSWER LGTM/LBTM.
LGTM/LBTM






NOTICE
Role: You are a professional engineer; the main goal is to write google-style, elegant, modular, easy to read and maintain code
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## Design
{"Implementation approach":"We will build the game as a small, selfâcontained console application using the standard `curses` library for realâtime keyboard input and screen drawing. The core logic will be split into a handful of focused classes:\n\n* **Game** â owns the main loop, coordinates input, update and rendering, and manages the overall state (running, paused, gameâover).\n* **Snake** â stores the ordered list of grid coordinates that make up the snake, handles movement, growth and collision checks.\n* **Food** â keeps the current food position and can generate a new one that never overlaps the snake.\n* **Grid** â represents the 10Ã10 board, provides bounds checking and a helper to convert coordinates to screen positions.\n* **Renderer** â draws the grid, snake, food and UI elements (score, gameâover message) onto the curses window.\n* **InputHandler** â translates arrowâkey events into direction changes while preventing 180Â° reversals.\n\nThe game loop will run at a fixed tick rate (e.g. 10 frames per second). Each tick we:\n1. Poll for a key press.\n2. Update the snakeâs direction.\n3. Move the snake forward.\n4. Check for collisions (wall, self, food).\n5. Grow the snake and update the score if food is eaten.\n6. Render the updated state.\n\nThis separation keeps the code testable, readable and easily extensible (e.g. adding levels or AI). All state is kept in plain Python data structures (lists, tuples, ints) so no external dependencies are required beyond the standard library.\n\n","File list":["main.py","game.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -grid: Grid\n        -snake: Snake\n        -food: Food\n        -renderer: Renderer\n        -input_handler: InputHandler\n        -score: int\n        -running: bool\n        +__init__(window: curses.window)\n        +start() void\n        +handle_input() void\n        +update() void\n        +render() void\n        +game_over() void\n    }\n    class Snake {\n        -body: List[Tuple[int,int]]\n        -direction: Tuple[int,int]\n        +__init__(start_pos: Tuple[int,int], start_dir: Tuple[int,int])\n        +move() void\n        +grow() void\n        +set_direction(new_dir: Tuple[int,int]) void\n        +collides_with_self() bool\n        +collides_with_wall(grid: Grid) bool\n        +head() Tuple[int,int]\n    }\n    class Food {\n        -position: Tuple[int,int]\n        +__init__(grid: Grid, snake: Snake)\n        +generate_new(grid: Grid, snake: Snake) void\n        +position() Tuple[int,int]\n    }\n    class Grid {\n        -width: int\n        -height: int\n        +__init__(width: int, height: int)\n        +in_bounds(pos: Tuple[int,int]) bool\n        +to_screen_coords(pos: Tuple[int,int]) Tuple[int,int]\n    }\n    class Renderer {\n        -window: curses.window\n        +__init__(window: curses.window)\n        +draw(grid: Grid, snake: Snake, food: Food, score: int, game_over: bool) void\n        +clear() void\n    }\n    class InputHandler {\n        -last_direction: Tuple[int,int]\n        +__init__()\n        +get_direction(key: int) Tuple[int,int]\n    }\n    Game --> Snake\n    Game --> Food\n    Game --> Grid\n    Game --> Renderer\n    Game --> InputHandler\n    Snake --> Grid\n    Food --> Grid\n    Renderer --> Grid\n    Renderer --> Snake\n    Renderer --> Food\n","Program call flow":"\nsequenceDiagram\n    participant M as main\n    participant G as Game\n    participant I as InputHandler\n    participant S as Snake\n    participant F as Food\n    participant R as Renderer\n    participant Gd as Grid\n\n    M->>G: __init__(curses_window)\n    G->>Gd: __init__(10,10)\n    G->>S: __init__(center, RIGHT)\n    G->>F: __init__(Gd, S)\n    G->>R: __init__(curses_window)\n    G->>I: __init__()\n    G->>G: start()\n\n    loop every tick\n        G->>I: get_direction(key)\n        I->>G: set_direction\n        G->>S: move()\n        G->>S: collides_with_self() -> bool\n        alt collision\n            G->>G: game_over()\n            G->>R: draw(..., game_over=true)\n            G->>G: break loop\n        else\n            G->>F: position()\n            alt ate food\n                G->>S: grow()\n                G->>S: score++\n                G->>F: generate_new(Gd, S)\n            end\n            G->>R: draw(..., game_over=false)\n        end\n    end\n","Anything UNCLEAR":"The specification mentions \"optional animations for movement and growth\" but does not detail the desired effect. In a console environment, we can simulate a simple animation by briefly flashing the new head position or adding a short delay after growth. If more elaborate animations (e.g., smooth scrolling) are required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or if a graphical window is expected."}

## Task
{"Required Python packages":["No external packages required; uses only the standard library (curses, typing, etc.)"],"Required Other language third-party packages":["No thirdâparty dependencies required"],"Logic Analysis":[["main.py","Imports Game from game.py, initializes curses, creates Game instance, calls start()"],["game.py","Defines Game class: manages main loop, holds Grid, Snake, Food, Renderer, InputHandler, score, running flag; imports all component classes"],["snake.py","Defines Snake class: body list, direction tuple, move(), grow(), set_direction(), collides_with_self(), collides_with_wall(), head()"],["food.py","Defines Food class: position tuple, generate_new() that picks a random free cell, position() accessor"],["grid.py","Defines Grid class: width, height, in_bounds(), to_screen_coords()"],["renderer.py","Defines Renderer class: draws grid, snake, food, score, gameâover message; uses curses window"],["input_handler.py","Defines InputHandler class: get_direction() translates key codes to direction tuples, prevents 180Â° reversal"]],"Task list":["main.py","game.py","snake.py","food.py","grid.py","renderer.py","input_handler.py"],"Full API spec":"","Shared Knowledge":"All state is stored in plain Python data structures (lists, tuples, ints). The game is a console application using the curses library; no external GUI frameworks are required. Each component is isolated to aid testing and future extension (e.g., adding levels or AI).","Anything UNCLEAR":"The specification mentions optional animations for movement and growth but does not detail the desired effect. In a console environment, a simple flash or brief delay can simulate animation. If a richer graphical animation is required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or a graphical window is expected."}

## Legacy Code
```Code
----- main.py
```#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple, Optional

# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game state."""
        self.clear()

        # Draw border
        for x in range(grid.width + 2):
            self.window.addch(0, x, '#')
            self.window.addch(grid.height + 1, x, '#')
        for y in range(1, grid.height + 1):
            self.window.addch(y, 0, '#')
            self.window.addch(y, grid.width + 1, '#')

        # Draw food
        fx, fy = food.position
        sy, sx = grid.to_screen_coords((fx, fy))
        self.window.addch(sy + 1, sx + 1, '*')

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            cy, cx = grid.to_screen_coords((sx, sy))
            char = '@' if idx == 0 else 'O'
            self.window.addch(cy + 1, cx + 1, char)

        # Draw score
        score_text = f"Score: {score}"
        self.window.addstr(grid.height + 3, 0, score_text)

        # Draw game over message
        if game_over:
            msg = "GAME OVER! Press any key to exit."
            self.window.addstr(grid.height // 2, (grid.width - len(msg)) // 2, msg)

        self.window.refresh()


class InputHandler:
    """Translates key presses into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return a new direction based on the key, or keep current."""
        mapping = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        if new_dir != (-self.last_direction[0], -self.last_direction[1]):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per tick (10 FPS)

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (self.grid.width // 2, self.grid.height // 2)
        start_dir: Tuple[int, int] = (1, 0)  # Right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            start_time = time.time()

            # Handle input
            key = self.window.getch()
            if key != -1:
                new_dir = self.input_handler.get_direction(key)
                self.snake.set_direction(new_dir)

            # Update game state
            self.snake.move()

            # Collision checks
            if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
                self.game_over()
            else:
                # Check food consumption
                if self.snake.head() == self.food.position:
                    self.snake.grow()
                    self.score += 1
                    self.food.generate_new(self.grid, self.snake)

            # Render
            self.renderer.draw(
                self.grid,
                self.snake,
                self.food,
                self.score,
                self.game_over_flag,
            )

            # If game over, wait for key press to exit
            if self.game_over_flag:
                self.window.nodelay(False)
                self.window.getch()
                break

            # Maintain tick rate
            elapsed = time.time() - start_time
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Initialize and start the game."""
    game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)
```
----- game.py
```#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple


# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game screen."""
        self.clear()

        # Draw border
        for x in range(grid.width):
            self.window.addch(0, x, curses.ACS_HLINE)
            self.window.addch(grid.height + 1, x, curses.ACS_HLINE)
        for y in range(grid.height + 2):
            self.window.addch(y, 0, curses.ACS_VLINE)
            self.window.addch(y, grid.width + 1, curses.ACS_VLINE)
        self.window.addch(0, 0, curses.ACS_ULCORNER)
        self.window.addch(0, grid.width + 1, curses.ACS_URCORNER)
        self.window.addch(grid.height + 1, 0, curses.ACS_LLCORNER)
        self.window.addch(grid.height + 1, grid.width + 1, curses.ACS_LRCORNER)

        # Draw food
        fx, fy = food.position
        fy_screen, fx_screen = grid.to_screen_coords((fx, fy))
        self.window.addch(fy_screen + 1, fx_screen + 1, curses.ACS_PI)

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            sy_screen, sx_screen = grid.to_screen_coords((sx, sy))
            sy_screen += 1
            sx_screen += 1
            char: str = "@" if idx == 0 else "O"
            self.window.addch(sy_screen, sx_screen, char)

        # Draw score
        score_y: int = grid.height + 3
        score_x: int = 0
        score_text: str = f"Score: {score}"
        self.window.addstr(score_y, score_x, score_text)

        # Draw game over message if needed
        if game_over:
            msg: str = "GAME OVER! Press any key to exit."
            msg_y: int = grid.height // 2 + 1
            msg_x: int = (grid.width - len(msg)) // 2 + 1
            self.window.addstr(msg_y, msg_x, msg)

        self.window.refresh()


class InputHandler:
    """Processes user input and translates it into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default to moving right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return the new direction based on the pressed key."""
        mapping: dict[int, Tuple[int, int]] = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir: Tuple[int, int] = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        cur_dx, cur_dy = self.last_direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per frame

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window

        # Initialize components
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (
            self.grid.width // 2,
            self.grid.height // 2,
        )
        start_dir: Tuple[int, int] = (1, 0)  # Moving right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()

        # Game state
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    # ------------------------------------------------------------------
    # Game loop helpers
    # ------------------------------------------------------------------

    def handle_input(self) -> None:
        """Read user input and update snake direction."""
        key: int = self.window.getch()
        if key != -1:
            new_dir: Tuple[int, int] = self.input_handler.get_direction(key)
            self.snake.set_direction(new_dir)

    def update(self) -> None:
        """Advance game state: move snake, check collisions, handle food."""
        self.snake.move()

        # Collision detection
        if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
            self.game_over()
            return

        # Food consumption
        if self.snake.head() == self.food.position:
            self.snake.grow()
            self.score += 1
            self.food.generate_new(self.grid, self.snake)

    def render(self) -> None:
        """Render the current game state."""
        self.renderer.draw(
            self.grid,
            self.snake,
            self.food,
            self.score,
            self.game_over_flag,
        )

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True

    # ------------------------------------------------------------------
    # Main loop
    # ------------------------------------------------------------------

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            frame_start: float = time.time()

            self.handle_input()
            self.update()
            self.render()

            if self.game_over_flag:
                # Wait for a key press before exiting
                self.window.nodelay(False)
                self.window.getch()
                break

            elapsed: float = time.time() - frame_start
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Curses wrapper entry point."""
    game: Game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)
```
----- snake.py
```## snake.py
"""
Snake component for the console Snake game.

This module implements the :class:`Snake` class as specified in the
design documentation.  The implementation is fully typed, avoids
circular imports, and follows the public interface exactly.
"""

from __future__ import annotations

from typing import List, Tuple

# Import Grid only for type checking; no runtime dependency on grid.py
# to avoid circular imports.
from grid import Grid


class Snake:
    """
    Represents the snake in the game.

    Attributes
    ----------
    body : List[Tuple[int, int]]
        Ordered list of grid coordinates from head to tail.
    direction : Tuple[int, int]
        Current movement direction as a (dx, dy) pair.
    _grow_pending : bool
        Flag indicating whether the snake should grow on the next move.
    """

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        """
        Initialise a new snake.

        Parameters
        ----------
        start_pos : Tuple[int, int]
            Initial head position on the grid.
        start_dir : Tuple[int, int]
            Initial movement direction.
        """
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """
        Move the snake forward by one cell.

        The new head position is calculated from the current head and
        direction.  The new head is inserted at the front of the body
        list.  If a growth is pending, the tail is left intact; otherwise
        the last segment is removed to keep the length constant.
        """
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)

        if self._grow_pending:
            # Consume the growth flag; the snake has grown by one segment.
            self._grow_pending = False
        else:
            # Normal movement: remove the tail segment.
            self.body.pop()

    def grow(self) -> None:
        """
        Schedule the snake to grow on its next move.

        After calling this method, the snake will retain its tail segment
        during the next :meth:`move` call, effectively increasing its
        length by one.
        """
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """
        Change the snake's direction if it is not a 180Â° reversal.

        Parameters
        ----------
        new_dir : Tuple[int, int]
            Desired new direction as a (dx, dy) pair.
        """
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        # Prevent the snake from reversing onto itself.
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """
        Check whether the snake's head collides with its body.

        Returns
        -------
        bool
            ``True`` if the head occupies the same cell as any other
            segment of the body.
        """
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """
        Check whether the snake's head has moved outside the grid.

        Parameters
        ----------
        grid : Grid
            The game grid used for boundary checks.

        Returns
        -------
        bool
            ``True`` if the head position is not within the grid bounds.
        """
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """
        Retrieve the current head position.

        Returns
        -------
        Tuple[int, int]
            The (x, y) coordinates of the snake's head.
        """
        return self.body[0]
```
----- food.py
```## food.py
"""
Food component for the console Snake game.

This module implements the :class:`Food` class as specified in the
design documentation.  It is fully typed, avoids circular imports,
and exposes a clean public interface.

The class maintains a private ``_position`` attribute and exposes it
via a readâonly :pyattr:`position` property.  The ``generate_new`` method
places the food on a random free cell of the grid, avoiding the snake.
"""

from __future__ import annotations

import random
from typing import Tuple, List

# Import Grid and Snake only for type checking; this avoids circular
# imports at runtime while still providing full type information.
from grid import Grid
from snake import Snake


class Food:
    """
    Represents the food item in the game.

    Parameters
    ----------
    grid : Grid
        The game grid used for boundary checks.
    snake : Snake
        The snake instance; used to avoid placing food on the snake.

    Attributes
    ----------
    position : Tuple[int, int]
        Current grid coordinates of the food.
    """

    def __init__(self, grid: Grid, snake: Snake) -> None:
        """
        Initialise a new food instance.

        The default position is overwritten by :meth:`generate_new`.
        """
        self._position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """
        Place food on a random free cell.

        The method scans all cells in the grid, filters out those
        occupied by the snake, and selects one at random.  If the
        snake occupies the entire grid, the current position is
        retained.

        Parameters
        ----------
        grid : Grid
            The game grid used for boundary checks.
        snake : Snake
            The snake instance; used to avoid placing food on the snake.
        """
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]

        if not free_cells:
            # No free space left; keep current position
            return

        self._position = random.choice(free_cells)

    @property
    def position(self) -> Tuple[int, int]:
        """
        Return the current food position.

        Returns
        -------
        Tuple[int, int]
            The (x, y) coordinates of the food.
        """
        return self._position

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(position={self._position!r})"
```
```

## Debug logs
```text



```

## Bug Feedback logs
```text

```

# Format example
## Code: grid.py
```python
## grid.py
...
```

# Instruction: Based on the context, follow "Format example", write code.

## Code: grid.py. Write code with triple quoto, based on the following attentions and context.
1. Only One file: do your best to implement THIS ONLY ONE FILE.
2. COMPLETE CODE: Your code will be part of the entire project, so please implement complete, reliable, reusable code snippets.
3. Set default value: If there is any setting, ALWAYS SET A DEFAULT VALUE, ALWAYS USE STRONG TYPE AND EXPLICIT VARIABLE. AVOID circular import.
4. Follow design: YOU MUST FOLLOW "Data structures and interfaces". DONT CHANGE ANY DESIGN. Do not use public member functions that do not exist in your design.
5. CAREFULLY CHECK THAT YOU DONT MISS ANY NECESSARY CLASS/FUNCTION IN THIS FILE.
6. Before using a external variable/module, make sure you import it first.
7. Write out EVERY CODE DETAIL, DON'T LEAVE TODO.






# System
Role: You are a professional software engineer, and your main task is to review and revise the code. You need to ensure that the code conforms to the google-style standards, is elegantly designed and modularized, easy to read and maintain.
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## System Design
{"Implementation approach":"We will build the game as a small, selfâcontained console application using the standard `curses` library for realâtime keyboard input and screen drawing. The core logic will be split into a handful of focused classes:\n\n* **Game** â owns the main loop, coordinates input, update and rendering, and manages the overall state (running, paused, gameâover).\n* **Snake** â stores the ordered list of grid coordinates that make up the snake, handles movement, growth and collision checks.\n* **Food** â keeps the current food position and can generate a new one that never overlaps the snake.\n* **Grid** â represents the 10Ã10 board, provides bounds checking and a helper to convert coordinates to screen positions.\n* **Renderer** â draws the grid, snake, food and UI elements (score, gameâover message) onto the curses window.\n* **InputHandler** â translates arrowâkey events into direction changes while preventing 180Â° reversals.\n\nThe game loop will run at a fixed tick rate (e.g. 10 frames per second). Each tick we:\n1. Poll for a key press.\n2. Update the snakeâs direction.\n3. Move the snake forward.\n4. Check for collisions (wall, self, food).\n5. Grow the snake and update the score if food is eaten.\n6. Render the updated state.\n\nThis separation keeps the code testable, readable and easily extensible (e.g. adding levels or AI). All state is kept in plain Python data structures (lists, tuples, ints) so no external dependencies are required beyond the standard library.\n\n","File list":["main.py","game.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -grid: Grid\n        -snake: Snake\n        -food: Food\n        -renderer: Renderer\n        -input_handler: InputHandler\n        -score: int\n        -running: bool\n        +__init__(window: curses.window)\n        +start() void\n        +handle_input() void\n        +update() void\n        +render() void\n        +game_over() void\n    }\n    class Snake {\n        -body: List[Tuple[int,int]]\n        -direction: Tuple[int,int]\n        +__init__(start_pos: Tuple[int,int], start_dir: Tuple[int,int])\n        +move() void\n        +grow() void\n        +set_direction(new_dir: Tuple[int,int]) void\n        +collides_with_self() bool\n        +collides_with_wall(grid: Grid) bool\n        +head() Tuple[int,int]\n    }\n    class Food {\n        -position: Tuple[int,int]\n        +__init__(grid: Grid, snake: Snake)\n        +generate_new(grid: Grid, snake: Snake) void\n        +position() Tuple[int,int]\n    }\n    class Grid {\n        -width: int\n        -height: int\n        +__init__(width: int, height: int)\n        +in_bounds(pos: Tuple[int,int]) bool\n        +to_screen_coords(pos: Tuple[int,int]) Tuple[int,int]\n    }\n    class Renderer {\n        -window: curses.window\n        +__init__(window: curses.window)\n        +draw(grid: Grid, snake: Snake, food: Food, score: int, game_over: bool) void\n        +clear() void\n    }\n    class InputHandler {\n        -last_direction: Tuple[int,int]\n        +__init__()\n        +get_direction(key: int) Tuple[int,int]\n    }\n    Game --> Snake\n    Game --> Food\n    Game --> Grid\n    Game --> Renderer\n    Game --> InputHandler\n    Snake --> Grid\n    Food --> Grid\n    Renderer --> Grid\n    Renderer --> Snake\n    Renderer --> Food\n","Program call flow":"\nsequenceDiagram\n    participant M as main\n    participant G as Game\n    participant I as InputHandler\n    participant S as Snake\n    participant F as Food\n    participant R as Renderer\n    participant Gd as Grid\n\n    M->>G: __init__(curses_window)\n    G->>Gd: __init__(10,10)\n    G->>S: __init__(center, RIGHT)\n    G->>F: __init__(Gd, S)\n    G->>R: __init__(curses_window)\n    G->>I: __init__()\n    G->>G: start()\n\n    loop every tick\n        G->>I: get_direction(key)\n        I->>G: set_direction\n        G->>S: move()\n        G->>S: collides_with_self() -> bool\n        alt collision\n            G->>G: game_over()\n            G->>R: draw(..., game_over=true)\n            G->>G: break loop\n        else\n            G->>F: position()\n            alt ate food\n                G->>S: grow()\n                G->>S: score++\n                G->>F: generate_new(Gd, S)\n            end\n            G->>R: draw(..., game_over=false)\n        end\n    end\n","Anything UNCLEAR":"The specification mentions \"optional animations for movement and growth\" but does not detail the desired effect. In a console environment, we can simulate a simple animation by briefly flashing the new head position or adding a short delay after growth. If more elaborate animations (e.g., smooth scrolling) are required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or if a graphical window is expected."}

## Task
{"Required Python packages":["No external packages required; uses only the standard library (curses, typing, etc.)"],"Required Other language third-party packages":["No thirdâparty dependencies required"],"Logic Analysis":[["main.py","Imports Game from game.py, initializes curses, creates Game instance, calls start()"],["game.py","Defines Game class: manages main loop, holds Grid, Snake, Food, Renderer, InputHandler, score, running flag; imports all component classes"],["snake.py","Defines Snake class: body list, direction tuple, move(), grow(), set_direction(), collides_with_self(), collides_with_wall(), head()"],["food.py","Defines Food class: position tuple, generate_new() that picks a random free cell, position() accessor"],["grid.py","Defines Grid class: width, height, in_bounds(), to_screen_coords()"],["renderer.py","Defines Renderer class: draws grid, snake, food, score, gameâover message; uses curses window"],["input_handler.py","Defines InputHandler class: get_direction() translates key codes to direction tuples, prevents 180Â° reversal"]],"Task list":["main.py","game.py","snake.py","food.py","grid.py","renderer.py","input_handler.py"],"Full API spec":"","Shared Knowledge":"All state is stored in plain Python data structures (lists, tuples, ints). The game is a console application using the curses library; no external GUI frameworks are required. Each component is isolated to aid testing and future extension (e.g., adding levels or AI).","Anything UNCLEAR":"The specification mentions optional animations for movement and growth but does not detail the desired effect. In a console environment, a simple flash or brief delay can simulate animation. If a richer graphical animation is required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or a graphical window is expected."}

## Code Files
----- main.py
```#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple, Optional

# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game state."""
        self.clear()

        # Draw border
        for x in range(grid.width + 2):
            self.window.addch(0, x, '#')
            self.window.addch(grid.height + 1, x, '#')
        for y in range(1, grid.height + 1):
            self.window.addch(y, 0, '#')
            self.window.addch(y, grid.width + 1, '#')

        # Draw food
        fx, fy = food.position
        sy, sx = grid.to_screen_coords((fx, fy))
        self.window.addch(sy + 1, sx + 1, '*')

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            cy, cx = grid.to_screen_coords((sx, sy))
            char = '@' if idx == 0 else 'O'
            self.window.addch(cy + 1, cx + 1, char)

        # Draw score
        score_text = f"Score: {score}"
        self.window.addstr(grid.height + 3, 0, score_text)

        # Draw game over message
        if game_over:
            msg = "GAME OVER! Press any key to exit."
            self.window.addstr(grid.height // 2, (grid.width - len(msg)) // 2, msg)

        self.window.refresh()


class InputHandler:
    """Translates key presses into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return a new direction based on the key, or keep current."""
        mapping = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        if new_dir != (-self.last_direction[0], -self.last_direction[1]):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per tick (10 FPS)

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (self.grid.width // 2, self.grid.height // 2)
        start_dir: Tuple[int, int] = (1, 0)  # Right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            start_time = time.time()

            # Handle input
            key = self.window.getch()
            if key != -1:
                new_dir = self.input_handler.get_direction(key)
                self.snake.set_direction(new_dir)

            # Update game state
            self.snake.move()

            # Collision checks
            if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
                self.game_over()
            else:
                # Check food consumption
                if self.snake.head() == self.food.position:
                    self.snake.grow()
                    self.score += 1
                    self.food.generate_new(self.grid, self.snake)

            # Render
            self.renderer.draw(
                self.grid,
                self.snake,
                self.food,
                self.score,
                self.game_over_flag,
            )

            # If game over, wait for key press to exit
            if self.game_over_flag:
                self.window.nodelay(False)
                self.window.getch()
                break

            # Maintain tick rate
            elapsed = time.time() - start_time
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Initialize and start the game."""
    game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)
```
----- game.py
```#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple


# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game screen."""
        self.clear()

        # Draw border
        for x in range(grid.width):
            self.window.addch(0, x, curses.ACS_HLINE)
            self.window.addch(grid.height + 1, x, curses.ACS_HLINE)
        for y in range(grid.height + 2):
            self.window.addch(y, 0, curses.ACS_VLINE)
            self.window.addch(y, grid.width + 1, curses.ACS_VLINE)
        self.window.addch(0, 0, curses.ACS_ULCORNER)
        self.window.addch(0, grid.width + 1, curses.ACS_URCORNER)
        self.window.addch(grid.height + 1, 0, curses.ACS_LLCORNER)
        self.window.addch(grid.height + 1, grid.width + 1, curses.ACS_LRCORNER)

        # Draw food
        fx, fy = food.position
        fy_screen, fx_screen = grid.to_screen_coords((fx, fy))
        self.window.addch(fy_screen + 1, fx_screen + 1, curses.ACS_PI)

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            sy_screen, sx_screen = grid.to_screen_coords((sx, sy))
            sy_screen += 1
            sx_screen += 1
            char: str = "@" if idx == 0 else "O"
            self.window.addch(sy_screen, sx_screen, char)

        # Draw score
        score_y: int = grid.height + 3
        score_x: int = 0
        score_text: str = f"Score: {score}"
        self.window.addstr(score_y, score_x, score_text)

        # Draw game over message if needed
        if game_over:
            msg: str = "GAME OVER! Press any key to exit."
            msg_y: int = grid.height // 2 + 1
            msg_x: int = (grid.width - len(msg)) // 2 + 1
            self.window.addstr(msg_y, msg_x, msg)

        self.window.refresh()


class InputHandler:
    """Processes user input and translates it into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default to moving right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return the new direction based on the pressed key."""
        mapping: dict[int, Tuple[int, int]] = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir: Tuple[int, int] = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        cur_dx, cur_dy = self.last_direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per frame

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window

        # Initialize components
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (
            self.grid.width // 2,
            self.grid.height // 2,
        )
        start_dir: Tuple[int, int] = (1, 0)  # Moving right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()

        # Game state
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    # ------------------------------------------------------------------
    # Game loop helpers
    # ------------------------------------------------------------------

    def handle_input(self) -> None:
        """Read user input and update snake direction."""
        key: int = self.window.getch()
        if key != -1:
            new_dir: Tuple[int, int] = self.input_handler.get_direction(key)
            self.snake.set_direction(new_dir)

    def update(self) -> None:
        """Advance game state: move snake, check collisions, handle food."""
        self.snake.move()

        # Collision detection
        if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
            self.game_over()
            return

        # Food consumption
        if self.snake.head() == self.food.position:
            self.snake.grow()
            self.score += 1
            self.food.generate_new(self.grid, self.snake)

    def render(self) -> None:
        """Render the current game state."""
        self.renderer.draw(
            self.grid,
            self.snake,
            self.food,
            self.score,
            self.game_over_flag,
        )

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True

    # ------------------------------------------------------------------
    # Main loop
    # ------------------------------------------------------------------

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            frame_start: float = time.time()

            self.handle_input()
            self.update()
            self.render()

            if self.game_over_flag:
                # Wait for a key press before exiting
                self.window.nodelay(False)
                self.window.getch()
                break

            elapsed: float = time.time() - frame_start
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Curses wrapper entry point."""
    game: Game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)
```
----- snake.py
```## snake.py
"""
Snake component for the console Snake game.

This module implements the :class:`Snake` class as specified in the
design documentation.  The implementation is fully typed, avoids
circular imports, and follows the public interface exactly.
"""

from __future__ import annotations

from typing import List, Tuple

# Import Grid only for type checking; no runtime dependency on grid.py
# to avoid circular imports.
from grid import Grid


class Snake:
    """
    Represents the snake in the game.

    Attributes
    ----------
    body : List[Tuple[int, int]]
        Ordered list of grid coordinates from head to tail.
    direction : Tuple[int, int]
        Current movement direction as a (dx, dy) pair.
    _grow_pending : bool
        Flag indicating whether the snake should grow on the next move.
    """

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        """
        Initialise a new snake.

        Parameters
        ----------
        start_pos : Tuple[int, int]
            Initial head position on the grid.
        start_dir : Tuple[int, int]
            Initial movement direction.
        """
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """
        Move the snake forward by one cell.

        The new head position is calculated from the current head and
        direction.  The new head is inserted at the front of the body
        list.  If a growth is pending, the tail is left intact; otherwise
        the last segment is removed to keep the length constant.
        """
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)

        if self._grow_pending:
            # Consume the growth flag; the snake has grown by one segment.
            self._grow_pending = False
        else:
            # Normal movement: remove the tail segment.
            self.body.pop()

    def grow(self) -> None:
        """
        Schedule the snake to grow on its next move.

        After calling this method, the snake will retain its tail segment
        during the next :meth:`move` call, effectively increasing its
        length by one.
        """
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """
        Change the snake's direction if it is not a 180Â° reversal.

        Parameters
        ----------
        new_dir : Tuple[int, int]
            Desired new direction as a (dx, dy) pair.
        """
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        # Prevent the snake from reversing onto itself.
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """
        Check whether the snake's head collides with its body.

        Returns
        -------
        bool
            ``True`` if the head occupies the same cell as any other
            segment of the body.
        """
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """
        Check whether the snake's head has moved outside the grid.

        Parameters
        ----------
        grid : Grid
            The game grid used for boundary checks.

        Returns
        -------
        bool
            ``True`` if the head position is not within the grid bounds.
        """
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """
        Retrieve the current head position.

        Returns
        -------
        Tuple[int, int]
            The (x, y) coordinates of the snake's head.
        """
        return self.body[0]
```
----- food.py
```## food.py
"""
Food component for the console Snake game.

This module implements the :class:`Food` class as specified in the
design documentation.  It is fully typed, avoids circular imports,
and exposes a clean public interface.

The class maintains a private ``_position`` attribute and exposes it
via a readâonly :pyattr:`position` property.  The ``generate_new`` method
places the food on a random free cell of the grid, avoiding the snake.
"""

from __future__ import annotations

import random
from typing import Tuple, List

# Import Grid and Snake only for type checking; this avoids circular
# imports at runtime while still providing full type information.
from grid import Grid
from snake import Snake


class Food:
    """
    Represents the food item in the game.

    Parameters
    ----------
    grid : Grid
        The game grid used for boundary checks.
    snake : Snake
        The snake instance; used to avoid placing food on the snake.

    Attributes
    ----------
    position : Tuple[int, int]
        Current grid coordinates of the food.
    """

    def __init__(self, grid: Grid, snake: Snake) -> None:
        """
        Initialise a new food instance.

        The default position is overwritten by :meth:`generate_new`.
        """
        self._position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """
        Place food on a random free cell.

        The method scans all cells in the grid, filters out those
        occupied by the snake, and selects one at random.  If the
        snake occupies the entire grid, the current position is
        retained.

        Parameters
        ----------
        grid : Grid
            The game grid used for boundary checks.
        snake : Snake
            The snake instance; used to avoid placing food on the snake.
        """
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]

        if not free_cells:
            # No free space left; keep current position
            return

        self._position = random.choice(free_cells)

    @property
    def position(self) -> Tuple[int, int]:
        """
        Return the current food position.

        Returns
        -------
        Tuple[int, int]
            The (x, y) coordinates of the food.
        """
        return self._position

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(position={self._position!r})"
```


## Code to be Reviewed: grid.py
```Code
## grid.py
"""
Grid component for the console Snake game.

This module implements the :class:`Grid` class as specified in the
design documentation.  It is intentionally lightweight and free of
runtime dependencies on other game modules to avoid circular imports.
"""

from __future__ import annotations

from typing import Tuple


class Grid:
    """
    Represents the game board.

    Attributes
    ----------
    width : int
        Number of columns in the grid.
    height : int
        Number of rows in the grid.
    """

    def __init__(self, width: int = 10, height: int = 10) -> None:
        """
        Initialise a new grid.

        Parameters
        ----------
        width : int, optional
            Grid width (default 10).
        height : int, optional
            Grid height (default 10).
        """
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """
        Check whether a position lies inside the grid boundaries.

        Parameters
        ----------
        pos : Tuple[int, int]
            (x, y) coordinates to test.

        Returns
        -------
        bool
            ``True`` if the position is within the grid, otherwise
            ``False``.
        """
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert a grid coordinate to screen coordinates used by
        :class:`curses` rendering.

        The screen coordinate system places the origin (0, 0) at the
        topâleft corner of the visible area.  The grid is drawn
        starting at (1, 1) to leave room for a border.

        Parameters
        ----------
        pos : Tuple[int, int]
            (x, y) grid coordinate.

        Returns
        -------
        Tuple[int, int]
            (screen_x, screen_y) coordinate suitable for
            :func:`curses.addch` or :func:`curses.addstr`.
        """
        x, y = pos
        return (x, y)

```



# Format example 1
## Code Review: grid.py
1. No, we should fix the logic of class A due to ...
2. ...
3. ...
4. No, function B is not implemented, ...
5. ...
6. ...

## Actions
1. Fix the `handle_events` method to update the game state only if a move is successful.
   ```python
   def handle_events(self):
       for event in pygame.event.get():
           if event.type == pygame.QUIT:
               return False
           if event.type == pygame.KEYDOWN:
               moved = False
               if event.key == pygame.K_UP:
                   moved = self.game.move('UP')
               elif event.key == pygame.K_DOWN:
                   moved = self.game.move('DOWN')
               elif event.key == pygame.K_LEFT:
                   moved = self.game.move('LEFT')
               elif event.key == pygame.K_RIGHT:
                   moved = self.game.move('RIGHT')
               if moved:
                   # Update the game state only if a move was successful
                   self.render()
       return True
   ```
2. Implement function B

## Code Review Result
LBTM

# Format example 2
## Code Review: grid.py
1. Yes.
2. Yes.
3. Yes.
4. Yes.
5. Yes.
6. Yes.

## Actions
pass

## Code Review Result
LGTM



# Instruction: Based on the actual code situation, follow one of the "Format example". Return only 1 file under review.

## Code Review: Ordered List. Based on the "Code to be Reviewed", provide key, clear, concise, and specific answer. If any answer is no, explain how to fix it step by step.
1. Is the code implemented as per the requirements? If not, how to achieve it? Analyse it step by step.
2. Is the code logic completely correct? If there are errors, please indicate how to correct them.
3. Does the existing code follow the "Data structures and interfaces"?
4. Are all functions implemented? If there is no implementation, please indicate how to achieve it step by step.
5. Have all necessary pre-dependencies been imported? If not, indicate which ones need to be imported
6. Are methods from other files being reused correctly?

## Actions: Ordered List. Things that should be done after CR, such as implementing class A and function B

## Code Review Result: str. If the code doesn't have bugs, we don't need to rewrite it, so answer LGTM and stop. ONLY ANSWER LGTM/LBTM.
LGTM/LBTM






# System
Role: You are a professional software engineer, and your main task is to review and revise the code. You need to ensure that the code conforms to the google-style standards, is elegantly designed and modularized, easy to read and maintain.
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## System Design
{"Implementation approach":"We will build the game as a small, selfâcontained console application using the standard `curses` library for realâtime keyboard input and screen drawing. The core logic will be split into a handful of focused classes:\n\n* **Game** â owns the main loop, coordinates input, update and rendering, and manages the overall state (running, paused, gameâover).\n* **Snake** â stores the ordered list of grid coordinates that make up the snake, handles movement, growth and collision checks.\n* **Food** â keeps the current food position and can generate a new one that never overlaps the snake.\n* **Grid** â represents the 10Ã10 board, provides bounds checking and a helper to convert coordinates to screen positions.\n* **Renderer** â draws the grid, snake, food and UI elements (score, gameâover message) onto the curses window.\n* **InputHandler** â translates arrowâkey events into direction changes while preventing 180Â° reversals.\n\nThe game loop will run at a fixed tick rate (e.g. 10 frames per second). Each tick we:\n1. Poll for a key press.\n2. Update the snakeâs direction.\n3. Move the snake forward.\n4. Check for collisions (wall, self, food).\n5. Grow the snake and update the score if food is eaten.\n6. Render the updated state.\n\nThis separation keeps the code testable, readable and easily extensible (e.g. adding levels or AI). All state is kept in plain Python data structures (lists, tuples, ints) so no external dependencies are required beyond the standard library.\n\n","File list":["main.py","game.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -grid: Grid\n        -snake: Snake\n        -food: Food\n        -renderer: Renderer\n        -input_handler: InputHandler\n        -score: int\n        -running: bool\n        +__init__(window: curses.window)\n        +start() void\n        +handle_input() void\n        +update() void\n        +render() void\n        +game_over() void\n    }\n    class Snake {\n        -body: List[Tuple[int,int]]\n        -direction: Tuple[int,int]\n        +__init__(start_pos: Tuple[int,int], start_dir: Tuple[int,int])\n        +move() void\n        +grow() void\n        +set_direction(new_dir: Tuple[int,int]) void\n        +collides_with_self() bool\n        +collides_with_wall(grid: Grid) bool\n        +head() Tuple[int,int]\n    }\n    class Food {\n        -position: Tuple[int,int]\n        +__init__(grid: Grid, snake: Snake)\n        +generate_new(grid: Grid, snake: Snake) void\n        +position() Tuple[int,int]\n    }\n    class Grid {\n        -width: int\n        -height: int\n        +__init__(width: int, height: int)\n        +in_bounds(pos: Tuple[int,int]) bool\n        +to_screen_coords(pos: Tuple[int,int]) Tuple[int,int]\n    }\n    class Renderer {\n        -window: curses.window\n        +__init__(window: curses.window)\n        +draw(grid: Grid, snake: Snake, food: Food, score: int, game_over: bool) void\n        +clear() void\n    }\n    class InputHandler {\n        -last_direction: Tuple[int,int]\n        +__init__()\n        +get_direction(key: int) Tuple[int,int]\n    }\n    Game --> Snake\n    Game --> Food\n    Game --> Grid\n    Game --> Renderer\n    Game --> InputHandler\n    Snake --> Grid\n    Food --> Grid\n    Renderer --> Grid\n    Renderer --> Snake\n    Renderer --> Food\n","Program call flow":"\nsequenceDiagram\n    participant M as main\n    participant G as Game\n    participant I as InputHandler\n    participant S as Snake\n    participant F as Food\n    participant R as Renderer\n    participant Gd as Grid\n\n    M->>G: __init__(curses_window)\n    G->>Gd: __init__(10,10)\n    G->>S: __init__(center, RIGHT)\n    G->>F: __init__(Gd, S)\n    G->>R: __init__(curses_window)\n    G->>I: __init__()\n    G->>G: start()\n\n    loop every tick\n        G->>I: get_direction(key)\n        I->>G: set_direction\n        G->>S: move()\n        G->>S: collides_with_self() -> bool\n        alt collision\n            G->>G: game_over()\n            G->>R: draw(..., game_over=true)\n            G->>G: break loop\n        else\n            G->>F: position()\n            alt ate food\n                G->>S: grow()\n                G->>S: score++\n                G->>F: generate_new(Gd, S)\n            end\n            G->>R: draw(..., game_over=false)\n        end\n    end\n","Anything UNCLEAR":"The specification mentions \"optional animations for movement and growth\" but does not detail the desired effect. In a console environment, we can simulate a simple animation by briefly flashing the new head position or adding a short delay after growth. If more elaborate animations (e.g., smooth scrolling) are required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or if a graphical window is expected."}

## Task
{"Required Python packages":["No external packages required; uses only the standard library (curses, typing, etc.)"],"Required Other language third-party packages":["No thirdâparty dependencies required"],"Logic Analysis":[["main.py","Imports Game from game.py, initializes curses, creates Game instance, calls start()"],["game.py","Defines Game class: manages main loop, holds Grid, Snake, Food, Renderer, InputHandler, score, running flag; imports all component classes"],["snake.py","Defines Snake class: body list, direction tuple, move(), grow(), set_direction(), collides_with_self(), collides_with_wall(), head()"],["food.py","Defines Food class: position tuple, generate_new() that picks a random free cell, position() accessor"],["grid.py","Defines Grid class: width, height, in_bounds(), to_screen_coords()"],["renderer.py","Defines Renderer class: draws grid, snake, food, score, gameâover message; uses curses window"],["input_handler.py","Defines InputHandler class: get_direction() translates key codes to direction tuples, prevents 180Â° reversal"]],"Task list":["main.py","game.py","snake.py","food.py","grid.py","renderer.py","input_handler.py"],"Full API spec":"","Shared Knowledge":"All state is stored in plain Python data structures (lists, tuples, ints). The game is a console application using the curses library; no external GUI frameworks are required. Each component is isolated to aid testing and future extension (e.g., adding levels or AI).","Anything UNCLEAR":"The specification mentions optional animations for movement and growth but does not detail the desired effect. In a console environment, a simple flash or brief delay can simulate animation. If a richer graphical animation is required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or a graphical window is expected."}

## Code Files
----- main.py
```#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple, Optional

# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game state."""
        self.clear()

        # Draw border
        for x in range(grid.width + 2):
            self.window.addch(0, x, '#')
            self.window.addch(grid.height + 1, x, '#')
        for y in range(1, grid.height + 1):
            self.window.addch(y, 0, '#')
            self.window.addch(y, grid.width + 1, '#')

        # Draw food
        fx, fy = food.position
        sy, sx = grid.to_screen_coords((fx, fy))
        self.window.addch(sy + 1, sx + 1, '*')

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            cy, cx = grid.to_screen_coords((sx, sy))
            char = '@' if idx == 0 else 'O'
            self.window.addch(cy + 1, cx + 1, char)

        # Draw score
        score_text = f"Score: {score}"
        self.window.addstr(grid.height + 3, 0, score_text)

        # Draw game over message
        if game_over:
            msg = "GAME OVER! Press any key to exit."
            self.window.addstr(grid.height // 2, (grid.width - len(msg)) // 2, msg)

        self.window.refresh()


class InputHandler:
    """Translates key presses into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return a new direction based on the key, or keep current."""
        mapping = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        if new_dir != (-self.last_direction[0], -self.last_direction[1]):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per tick (10 FPS)

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (self.grid.width // 2, self.grid.height // 2)
        start_dir: Tuple[int, int] = (1, 0)  # Right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            start_time = time.time()

            # Handle input
            key = self.window.getch()
            if key != -1:
                new_dir = self.input_handler.get_direction(key)
                self.snake.set_direction(new_dir)

            # Update game state
            self.snake.move()

            # Collision checks
            if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
                self.game_over()
            else:
                # Check food consumption
                if self.snake.head() == self.food.position:
                    self.snake.grow()
                    self.score += 1
                    self.food.generate_new(self.grid, self.snake)

            # Render
            self.renderer.draw(
                self.grid,
                self.snake,
                self.food,
                self.score,
                self.game_over_flag,
            )

            # If game over, wait for key press to exit
            if self.game_over_flag:
                self.window.nodelay(False)
                self.window.getch()
                break

            # Maintain tick rate
            elapsed = time.time() - start_time
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Initialize and start the game."""
    game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)
```
----- game.py
```#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple


# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game screen."""
        self.clear()

        # Draw border
        for x in range(grid.width):
            self.window.addch(0, x, curses.ACS_HLINE)
            self.window.addch(grid.height + 1, x, curses.ACS_HLINE)
        for y in range(grid.height + 2):
            self.window.addch(y, 0, curses.ACS_VLINE)
            self.window.addch(y, grid.width + 1, curses.ACS_VLINE)
        self.window.addch(0, 0, curses.ACS_ULCORNER)
        self.window.addch(0, grid.width + 1, curses.ACS_URCORNER)
        self.window.addch(grid.height + 1, 0, curses.ACS_LLCORNER)
        self.window.addch(grid.height + 1, grid.width + 1, curses.ACS_LRCORNER)

        # Draw food
        fx, fy = food.position
        fy_screen, fx_screen = grid.to_screen_coords((fx, fy))
        self.window.addch(fy_screen + 1, fx_screen + 1, curses.ACS_PI)

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            sy_screen, sx_screen = grid.to_screen_coords((sx, sy))
            sy_screen += 1
            sx_screen += 1
            char: str = "@" if idx == 0 else "O"
            self.window.addch(sy_screen, sx_screen, char)

        # Draw score
        score_y: int = grid.height + 3
        score_x: int = 0
        score_text: str = f"Score: {score}"
        self.window.addstr(score_y, score_x, score_text)

        # Draw game over message if needed
        if game_over:
            msg: str = "GAME OVER! Press any key to exit."
            msg_y: int = grid.height // 2 + 1
            msg_x: int = (grid.width - len(msg)) // 2 + 1
            self.window.addstr(msg_y, msg_x, msg)

        self.window.refresh()


class InputHandler:
    """Processes user input and translates it into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default to moving right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return the new direction based on the pressed key."""
        mapping: dict[int, Tuple[int, int]] = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir: Tuple[int, int] = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        cur_dx, cur_dy = self.last_direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per frame

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window

        # Initialize components
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (
            self.grid.width // 2,
            self.grid.height // 2,
        )
        start_dir: Tuple[int, int] = (1, 0)  # Moving right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()

        # Game state
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    # ------------------------------------------------------------------
    # Game loop helpers
    # ------------------------------------------------------------------

    def handle_input(self) -> None:
        """Read user input and update snake direction."""
        key: int = self.window.getch()
        if key != -1:
            new_dir: Tuple[int, int] = self.input_handler.get_direction(key)
            self.snake.set_direction(new_dir)

    def update(self) -> None:
        """Advance game state: move snake, check collisions, handle food."""
        self.snake.move()

        # Collision detection
        if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
            self.game_over()
            return

        # Food consumption
        if self.snake.head() == self.food.position:
            self.snake.grow()
            self.score += 1
            self.food.generate_new(self.grid, self.snake)

    def render(self) -> None:
        """Render the current game state."""
        self.renderer.draw(
            self.grid,
            self.snake,
            self.food,
            self.score,
            self.game_over_flag,
        )

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True

    # ------------------------------------------------------------------
    # Main loop
    # ------------------------------------------------------------------

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            frame_start: float = time.time()

            self.handle_input()
            self.update()
            self.render()

            if self.game_over_flag:
                # Wait for a key press before exiting
                self.window.nodelay(False)
                self.window.getch()
                break

            elapsed: float = time.time() - frame_start
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Curses wrapper entry point."""
    game: Game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)
```
----- snake.py
```## snake.py
"""
Snake component for the console Snake game.

This module implements the :class:`Snake` class as specified in the
design documentation.  The implementation is fully typed, avoids
circular imports, and follows the public interface exactly.
"""

from __future__ import annotations

from typing import List, Tuple

# Import Grid only for type checking; no runtime dependency on grid.py
# to avoid circular imports.
from grid import Grid


class Snake:
    """
    Represents the snake in the game.

    Attributes
    ----------
    body : List[Tuple[int, int]]
        Ordered list of grid coordinates from head to tail.
    direction : Tuple[int, int]
        Current movement direction as a (dx, dy) pair.
    _grow_pending : bool
        Flag indicating whether the snake should grow on the next move.
    """

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        """
        Initialise a new snake.

        Parameters
        ----------
        start_pos : Tuple[int, int]
            Initial head position on the grid.
        start_dir : Tuple[int, int]
            Initial movement direction.
        """
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """
        Move the snake forward by one cell.

        The new head position is calculated from the current head and
        direction.  The new head is inserted at the front of the body
        list.  If a growth is pending, the tail is left intact; otherwise
        the last segment is removed to keep the length constant.
        """
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)

        if self._grow_pending:
            # Consume the growth flag; the snake has grown by one segment.
            self._grow_pending = False
        else:
            # Normal movement: remove the tail segment.
            self.body.pop()

    def grow(self) -> None:
        """
        Schedule the snake to grow on its next move.

        After calling this method, the snake will retain its tail segment
        during the next :meth:`move` call, effectively increasing its
        length by one.
        """
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """
        Change the snake's direction if it is not a 180Â° reversal.

        Parameters
        ----------
        new_dir : Tuple[int, int]
            Desired new direction as a (dx, dy) pair.
        """
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        # Prevent the snake from reversing onto itself.
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """
        Check whether the snake's head collides with its body.

        Returns
        -------
        bool
            ``True`` if the head occupies the same cell as any other
            segment of the body.
        """
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """
        Check whether the snake's head has moved outside the grid.

        Parameters
        ----------
        grid : Grid
            The game grid used for boundary checks.

        Returns
        -------
        bool
            ``True`` if the head position is not within the grid bounds.
        """
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """
        Retrieve the current head position.

        Returns
        -------
        Tuple[int, int]
            The (x, y) coordinates of the snake's head.
        """
        return self.body[0]
```
----- food.py
```## food.py
"""
Food component for the console Snake game.

This module implements the :class:`Food` class as specified in the
design documentation.  It is fully typed, avoids circular imports,
and exposes a clean public interface.

The class maintains a private ``_position`` attribute and exposes it
via a readâonly :pyattr:`position` property.  The ``generate_new`` method
places the food on a random free cell of the grid, avoiding the snake.
"""

from __future__ import annotations

import random
from typing import Tuple, List

# Import Grid and Snake only for type checking; this avoids circular
# imports at runtime while still providing full type information.
from grid import Grid
from snake import Snake


class Food:
    """
    Represents the food item in the game.

    Parameters
    ----------
    grid : Grid
        The game grid used for boundary checks.
    snake : Snake
        The snake instance; used to avoid placing food on the snake.

    Attributes
    ----------
    position : Tuple[int, int]
        Current grid coordinates of the food.
    """

    def __init__(self, grid: Grid, snake: Snake) -> None:
        """
        Initialise a new food instance.

        The default position is overwritten by :meth:`generate_new`.
        """
        self._position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """
        Place food on a random free cell.

        The method scans all cells in the grid, filters out those
        occupied by the snake, and selects one at random.  If the
        snake occupies the entire grid, the current position is
        retained.

        Parameters
        ----------
        grid : Grid
            The game grid used for boundary checks.
        snake : Snake
            The snake instance; used to avoid placing food on the snake.
        """
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]

        if not free_cells:
            # No free space left; keep current position
            return

        self._position = random.choice(free_cells)

    @property
    def position(self) -> Tuple[int, int]:
        """
        Return the current food position.

        Returns
        -------
        Tuple[int, int]
            The (x, y) coordinates of the food.
        """
        return self._position

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(position={self._position!r})"
```


## Code to be Reviewed: grid.py
```Code
## grid.py
"""
Grid component for the console Snake game.

This module implements the :class:`Grid` class as specified in the
design documentation.  It is intentionally lightweight and free of
runtime dependencies on other game modules to avoid circular imports.
"""

from __future__ import annotations

from typing import Tuple


class Grid:
    """
    Represents the game board.

    Attributes
    ----------
    width : int
        Number of columns in the grid.
    height : int
        Number of rows in the grid.
    """

    def __init__(self, width: int = 10, height: int = 10) -> None:
        """
        Initialise a new grid.

        Parameters
        ----------
        width : int, optional
            Grid width (default 10).
        height : int, optional
            Grid height (default 10).
        """
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """
        Check whether a position lies inside the grid boundaries.

        Parameters
        ----------
        pos : Tuple[int, int]
            (x, y) coordinates to test.

        Returns
        -------
        bool
            ``True`` if the position is within the grid, otherwise
            ``False``.
        """
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert a grid coordinate to screen coordinates used by
        :class:`curses` rendering.

        The screen coordinate system places the origin (0, 0) at the
        topâleft corner of the visible area.  The grid is drawn
        starting at (1, 1) to leave room for a border.

        Parameters
        ----------
        pos : Tuple[int, int]
            (x, y) grid coordinate.

        Returns
        -------
        Tuple[int, int]
            (screen_x, screen_y) coordinate suitable for
            :func:`curses.addch` or :func:`curses.addstr`.
        """
        x, y = pos
        return (x, y)

```

## Code Review: grid.py
1. No, the code is not implemented as per the requirements. The `to_screen_coords` method does not convert grid coordinates to screen coordinates correctly; it returns the same tuple `(x, y)` instead of swapping the order to `(y, x)` which is required for curses rendering.
2. The logic of `in_bounds` is correct. The only error is in `to_screen_coords` where the coordinates are not swapped.
3. The existing code follows the "Data structures and interfaces" section: it defines `width`, `height`, `in_bounds`, and `to_screen_coords` as specified.
4. All functions are implemented; only the implementation of `to_screen_coords` is incorrect.
5. All necessary pre-dependencies (`typing.Tuple`) are imported.
6. No methods from other files are being reused incorrectly.

## Actions
1. Update the `to_screen_coords` method to return `(y, x)` instead of `(x, y)`:
   ```python
   def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
       x, y = pos
       # Return screen coordinates with y first (row), then x (column)
       return (y, x)
   ```

## Code Review Result
LBTM

# Instruction: rewrite code based on the Code Review and Actions
## Rewrite Code: CodeBlock. If it still has some bugs, rewrite grid.py with triple quotes. Do your utmost to optimize THIS SINGLE FILE. Return all completed codes and prohibit the return of unfinished codes.
```Code
## grid.py
...
```





# System
Role: You are a professional software engineer, and your main task is to review and revise the code. You need to ensure that the code conforms to the google-style standards, is elegantly designed and modularized, easy to read and maintain.
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## System Design
{"Implementation approach":"We will build the game as a small, selfâcontained console application using the standard `curses` library for realâtime keyboard input and screen drawing. The core logic will be split into a handful of focused classes:\n\n* **Game** â owns the main loop, coordinates input, update and rendering, and manages the overall state (running, paused, gameâover).\n* **Snake** â stores the ordered list of grid coordinates that make up the snake, handles movement, growth and collision checks.\n* **Food** â keeps the current food position and can generate a new one that never overlaps the snake.\n* **Grid** â represents the 10Ã10 board, provides bounds checking and a helper to convert coordinates to screen positions.\n* **Renderer** â draws the grid, snake, food and UI elements (score, gameâover message) onto the curses window.\n* **InputHandler** â translates arrowâkey events into direction changes while preventing 180Â° reversals.\n\nThe game loop will run at a fixed tick rate (e.g. 10 frames per second). Each tick we:\n1. Poll for a key press.\n2. Update the snakeâs direction.\n3. Move the snake forward.\n4. Check for collisions (wall, self, food).\n5. Grow the snake and update the score if food is eaten.\n6. Render the updated state.\n\nThis separation keeps the code testable, readable and easily extensible (e.g. adding levels or AI). All state is kept in plain Python data structures (lists, tuples, ints) so no external dependencies are required beyond the standard library.\n\n","File list":["main.py","game.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -grid: Grid\n        -snake: Snake\n        -food: Food\n        -renderer: Renderer\n        -input_handler: InputHandler\n        -score: int\n        -running: bool\n        +__init__(window: curses.window)\n        +start() void\n        +handle_input() void\n        +update() void\n        +render() void\n        +game_over() void\n    }\n    class Snake {\n        -body: List[Tuple[int,int]]\n        -direction: Tuple[int,int]\n        +__init__(start_pos: Tuple[int,int], start_dir: Tuple[int,int])\n        +move() void\n        +grow() void\n        +set_direction(new_dir: Tuple[int,int]) void\n        +collides_with_self() bool\n        +collides_with_wall(grid: Grid) bool\n        +head() Tuple[int,int]\n    }\n    class Food {\n        -position: Tuple[int,int]\n        +__init__(grid: Grid, snake: Snake)\n        +generate_new(grid: Grid, snake: Snake) void\n        +position() Tuple[int,int]\n    }\n    class Grid {\n        -width: int\n        -height: int\n        +__init__(width: int, height: int)\n        +in_bounds(pos: Tuple[int,int]) bool\n        +to_screen_coords(pos: Tuple[int,int]) Tuple[int,int]\n    }\n    class Renderer {\n        -window: curses.window\n        +__init__(window: curses.window)\n        +draw(grid: Grid, snake: Snake, food: Food, score: int, game_over: bool) void\n        +clear() void\n    }\n    class InputHandler {\n        -last_direction: Tuple[int,int]\n        +__init__()\n        +get_direction(key: int) Tuple[int,int]\n    }\n    Game --> Snake\n    Game --> Food\n    Game --> Grid\n    Game --> Renderer\n    Game --> InputHandler\n    Snake --> Grid\n    Food --> Grid\n    Renderer --> Grid\n    Renderer --> Snake\n    Renderer --> Food\n","Program call flow":"\nsequenceDiagram\n    participant M as main\n    participant G as Game\n    participant I as InputHandler\n    participant S as Snake\n    participant F as Food\n    participant R as Renderer\n    participant Gd as Grid\n\n    M->>G: __init__(curses_window)\n    G->>Gd: __init__(10,10)\n    G->>S: __init__(center, RIGHT)\n    G->>F: __init__(Gd, S)\n    G->>R: __init__(curses_window)\n    G->>I: __init__()\n    G->>G: start()\n\n    loop every tick\n        G->>I: get_direction(key)\n        I->>G: set_direction\n        G->>S: move()\n        G->>S: collides_with_self() -> bool\n        alt collision\n            G->>G: game_over()\n            G->>R: draw(..., game_over=true)\n            G->>G: break loop\n        else\n            G->>F: position()\n            alt ate food\n                G->>S: grow()\n                G->>S: score++\n                G->>F: generate_new(Gd, S)\n            end\n            G->>R: draw(..., game_over=false)\n        end\n    end\n","Anything UNCLEAR":"The specification mentions \"optional animations for movement and growth\" but does not detail the desired effect. In a console environment, we can simulate a simple animation by briefly flashing the new head position or adding a short delay after growth. If more elaborate animations (e.g., smooth scrolling) are required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or if a graphical window is expected."}

## Task
{"Required Python packages":["No external packages required; uses only the standard library (curses, typing, etc.)"],"Required Other language third-party packages":["No thirdâparty dependencies required"],"Logic Analysis":[["main.py","Imports Game from game.py, initializes curses, creates Game instance, calls start()"],["game.py","Defines Game class: manages main loop, holds Grid, Snake, Food, Renderer, InputHandler, score, running flag; imports all component classes"],["snake.py","Defines Snake class: body list, direction tuple, move(), grow(), set_direction(), collides_with_self(), collides_with_wall(), head()"],["food.py","Defines Food class: position tuple, generate_new() that picks a random free cell, position() accessor"],["grid.py","Defines Grid class: width, height, in_bounds(), to_screen_coords()"],["renderer.py","Defines Renderer class: draws grid, snake, food, score, gameâover message; uses curses window"],["input_handler.py","Defines InputHandler class: get_direction() translates key codes to direction tuples, prevents 180Â° reversal"]],"Task list":["main.py","game.py","snake.py","food.py","grid.py","renderer.py","input_handler.py"],"Full API spec":"","Shared Knowledge":"All state is stored in plain Python data structures (lists, tuples, ints). The game is a console application using the curses library; no external GUI frameworks are required. Each component is isolated to aid testing and future extension (e.g., adding levels or AI).","Anything UNCLEAR":"The specification mentions optional animations for movement and growth but does not detail the desired effect. In a console environment, a simple flash or brief delay can simulate animation. If a richer graphical animation is required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or a graphical window is expected."}

## Code Files
----- main.py
```#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple, Optional

# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game state."""
        self.clear()

        # Draw border
        for x in range(grid.width + 2):
            self.window.addch(0, x, '#')
            self.window.addch(grid.height + 1, x, '#')
        for y in range(1, grid.height + 1):
            self.window.addch(y, 0, '#')
            self.window.addch(y, grid.width + 1, '#')

        # Draw food
        fx, fy = food.position
        sy, sx = grid.to_screen_coords((fx, fy))
        self.window.addch(sy + 1, sx + 1, '*')

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            cy, cx = grid.to_screen_coords((sx, sy))
            char = '@' if idx == 0 else 'O'
            self.window.addch(cy + 1, cx + 1, char)

        # Draw score
        score_text = f"Score: {score}"
        self.window.addstr(grid.height + 3, 0, score_text)

        # Draw game over message
        if game_over:
            msg = "GAME OVER! Press any key to exit."
            self.window.addstr(grid.height // 2, (grid.width - len(msg)) // 2, msg)

        self.window.refresh()


class InputHandler:
    """Translates key presses into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return a new direction based on the key, or keep current."""
        mapping = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        if new_dir != (-self.last_direction[0], -self.last_direction[1]):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per tick (10 FPS)

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (self.grid.width // 2, self.grid.height // 2)
        start_dir: Tuple[int, int] = (1, 0)  # Right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            start_time = time.time()

            # Handle input
            key = self.window.getch()
            if key != -1:
                new_dir = self.input_handler.get_direction(key)
                self.snake.set_direction(new_dir)

            # Update game state
            self.snake.move()

            # Collision checks
            if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
                self.game_over()
            else:
                # Check food consumption
                if self.snake.head() == self.food.position:
                    self.snake.grow()
                    self.score += 1
                    self.food.generate_new(self.grid, self.snake)

            # Render
            self.renderer.draw(
                self.grid,
                self.snake,
                self.food,
                self.score,
                self.game_over_flag,
            )

            # If game over, wait for key press to exit
            if self.game_over_flag:
                self.window.nodelay(False)
                self.window.getch()
                break

            # Maintain tick rate
            elapsed = time.time() - start_time
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Initialize and start the game."""
    game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)
```
----- game.py
```#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple


# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game screen."""
        self.clear()

        # Draw border
        for x in range(grid.width):
            self.window.addch(0, x, curses.ACS_HLINE)
            self.window.addch(grid.height + 1, x, curses.ACS_HLINE)
        for y in range(grid.height + 2):
            self.window.addch(y, 0, curses.ACS_VLINE)
            self.window.addch(y, grid.width + 1, curses.ACS_VLINE)
        self.window.addch(0, 0, curses.ACS_ULCORNER)
        self.window.addch(0, grid.width + 1, curses.ACS_URCORNER)
        self.window.addch(grid.height + 1, 0, curses.ACS_LLCORNER)
        self.window.addch(grid.height + 1, grid.width + 1, curses.ACS_LRCORNER)

        # Draw food
        fx, fy = food.position
        fy_screen, fx_screen = grid.to_screen_coords((fx, fy))
        self.window.addch(fy_screen + 1, fx_screen + 1, curses.ACS_PI)

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            sy_screen, sx_screen = grid.to_screen_coords((sx, sy))
            sy_screen += 1
            sx_screen += 1
            char: str = "@" if idx == 0 else "O"
            self.window.addch(sy_screen, sx_screen, char)

        # Draw score
        score_y: int = grid.height + 3
        score_x: int = 0
        score_text: str = f"Score: {score}"
        self.window.addstr(score_y, score_x, score_text)

        # Draw game over message if needed
        if game_over:
            msg: str = "GAME OVER! Press any key to exit."
            msg_y: int = grid.height // 2 + 1
            msg_x: int = (grid.width - len(msg)) // 2 + 1
            self.window.addstr(msg_y, msg_x, msg)

        self.window.refresh()


class InputHandler:
    """Processes user input and translates it into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default to moving right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return the new direction based on the pressed key."""
        mapping: dict[int, Tuple[int, int]] = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir: Tuple[int, int] = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        cur_dx, cur_dy = self.last_direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per frame

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window

        # Initialize components
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (
            self.grid.width // 2,
            self.grid.height // 2,
        )
        start_dir: Tuple[int, int] = (1, 0)  # Moving right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()

        # Game state
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    # ------------------------------------------------------------------
    # Game loop helpers
    # ------------------------------------------------------------------

    def handle_input(self) -> None:
        """Read user input and update snake direction."""
        key: int = self.window.getch()
        if key != -1:
            new_dir: Tuple[int, int] = self.input_handler.get_direction(key)
            self.snake.set_direction(new_dir)

    def update(self) -> None:
        """Advance game state: move snake, check collisions, handle food."""
        self.snake.move()

        # Collision detection
        if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
            self.game_over()
            return

        # Food consumption
        if self.snake.head() == self.food.position:
            self.snake.grow()
            self.score += 1
            self.food.generate_new(self.grid, self.snake)

    def render(self) -> None:
        """Render the current game state."""
        self.renderer.draw(
            self.grid,
            self.snake,
            self.food,
            self.score,
            self.game_over_flag,
        )

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True

    # ------------------------------------------------------------------
    # Main loop
    # ------------------------------------------------------------------

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            frame_start: float = time.time()

            self.handle_input()
            self.update()
            self.render()

            if self.game_over_flag:
                # Wait for a key press before exiting
                self.window.nodelay(False)
                self.window.getch()
                break

            elapsed: float = time.time() - frame_start
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Curses wrapper entry point."""
    game: Game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)
```
----- snake.py
```## snake.py
"""
Snake component for the console Snake game.

This module implements the :class:`Snake` class as specified in the
design documentation.  The implementation is fully typed, avoids
circular imports, and follows the public interface exactly.
"""

from __future__ import annotations

from typing import List, Tuple

# Import Grid only for type checking; no runtime dependency on grid.py
# to avoid circular imports.
from grid import Grid


class Snake:
    """
    Represents the snake in the game.

    Attributes
    ----------
    body : List[Tuple[int, int]]
        Ordered list of grid coordinates from head to tail.
    direction : Tuple[int, int]
        Current movement direction as a (dx, dy) pair.
    _grow_pending : bool
        Flag indicating whether the snake should grow on the next move.
    """

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        """
        Initialise a new snake.

        Parameters
        ----------
        start_pos : Tuple[int, int]
            Initial head position on the grid.
        start_dir : Tuple[int, int]
            Initial movement direction.
        """
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """
        Move the snake forward by one cell.

        The new head position is calculated from the current head and
        direction.  The new head is inserted at the front of the body
        list.  If a growth is pending, the tail is left intact; otherwise
        the last segment is removed to keep the length constant.
        """
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)

        if self._grow_pending:
            # Consume the growth flag; the snake has grown by one segment.
            self._grow_pending = False
        else:
            # Normal movement: remove the tail segment.
            self.body.pop()

    def grow(self) -> None:
        """
        Schedule the snake to grow on its next move.

        After calling this method, the snake will retain its tail segment
        during the next :meth:`move` call, effectively increasing its
        length by one.
        """
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """
        Change the snake's direction if it is not a 180Â° reversal.

        Parameters
        ----------
        new_dir : Tuple[int, int]
            Desired new direction as a (dx, dy) pair.
        """
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        # Prevent the snake from reversing onto itself.
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """
        Check whether the snake's head collides with its body.

        Returns
        -------
        bool
            ``True`` if the head occupies the same cell as any other
            segment of the body.
        """
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """
        Check whether the snake's head has moved outside the grid.

        Parameters
        ----------
        grid : Grid
            The game grid used for boundary checks.

        Returns
        -------
        bool
            ``True`` if the head position is not within the grid bounds.
        """
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """
        Retrieve the current head position.

        Returns
        -------
        Tuple[int, int]
            The (x, y) coordinates of the snake's head.
        """
        return self.body[0]
```
----- food.py
```## food.py
"""
Food component for the console Snake game.

This module implements the :class:`Food` class as specified in the
design documentation.  It is fully typed, avoids circular imports,
and exposes a clean public interface.

The class maintains a private ``_position`` attribute and exposes it
via a readâonly :pyattr:`position` property.  The ``generate_new`` method
places the food on a random free cell of the grid, avoiding the snake.
"""

from __future__ import annotations

import random
from typing import Tuple, List

# Import Grid and Snake only for type checking; this avoids circular
# imports at runtime while still providing full type information.
from grid import Grid
from snake import Snake


class Food:
    """
    Represents the food item in the game.

    Parameters
    ----------
    grid : Grid
        The game grid used for boundary checks.
    snake : Snake
        The snake instance; used to avoid placing food on the snake.

    Attributes
    ----------
    position : Tuple[int, int]
        Current grid coordinates of the food.
    """

    def __init__(self, grid: Grid, snake: Snake) -> None:
        """
        Initialise a new food instance.

        The default position is overwritten by :meth:`generate_new`.
        """
        self._position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """
        Place food on a random free cell.

        The method scans all cells in the grid, filters out those
        occupied by the snake, and selects one at random.  If the
        snake occupies the entire grid, the current position is
        retained.

        Parameters
        ----------
        grid : Grid
            The game grid used for boundary checks.
        snake : Snake
            The snake instance; used to avoid placing food on the snake.
        """
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]

        if not free_cells:
            # No free space left; keep current position
            return

        self._position = random.choice(free_cells)

    @property
    def position(self) -> Tuple[int, int]:
        """
        Return the current food position.

        Returns
        -------
        Tuple[int, int]
            The (x, y) coordinates of the food.
        """
        return self._position

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(position={self._position!r})"
```


## Code to be Reviewed: grid.py
```Code
## grid.py
"""
Grid component for the console Snake game.

This module implements the :class:`Grid` class as specified in the
design documentation.  It is intentionally lightweight and free of
runtime dependencies on other game modules to avoid circular imports.
"""

from __future__ import annotations

from typing import Tuple


class Grid:
    """
    Represents the game board.

    Attributes
    ----------
    width : int
        Number of columns in the grid.
    height : int
        Number of rows in the grid.
    """

    __slots__ = ("width", "height")

    def __init__(self, width: int = 10, height: int = 10) -> None:
        """
        Initialise a new grid.

        Parameters
        ----------
        width : int, optional
            Grid width (default 10).
        height : int, optional
            Grid height (default 10).
        """
        self.width = width
        self.height = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """
        Check whether a position lies inside the grid boundaries.

        Parameters
        ----------
        pos : Tuple[int, int]
            (x, y) coordinates to test.

        Returns
        -------
        bool
            ``True`` if the position is within the grid, otherwise
            ``False``.
        """
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert a grid coordinate to screen coordinates used by
        :class:`curses` rendering.

        The screen coordinate system places the origin (0, 0) at the
        topâleft corner of the visible area.  The grid is drawn
        starting at (1, 1) to leave room for a border.

        Parameters
        ----------
        pos : Tuple[int, int]
            (x, y) grid coordinate.

        Returns
        -------
        Tuple[int, int]
            (screen_y, screen_x) coordinate suitable for
            :func:`curses.addch` or :func:`curses.addstr`.
        """
        x, y = pos
        # Return screen coordinates with y first (row), then x (column)
        return (y, x)

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(width={self.width!r}, height={self.height!r})"

```



# Format example 1
## Code Review: grid.py
1. No, we should fix the logic of class A due to ...
2. ...
3. ...
4. No, function B is not implemented, ...
5. ...
6. ...

## Actions
1. Fix the `handle_events` method to update the game state only if a move is successful.
   ```python
   def handle_events(self):
       for event in pygame.event.get():
           if event.type == pygame.QUIT:
               return False
           if event.type == pygame.KEYDOWN:
               moved = False
               if event.key == pygame.K_UP:
                   moved = self.game.move('UP')
               elif event.key == pygame.K_DOWN:
                   moved = self.game.move('DOWN')
               elif event.key == pygame.K_LEFT:
                   moved = self.game.move('LEFT')
               elif event.key == pygame.K_RIGHT:
                   moved = self.game.move('RIGHT')
               if moved:
                   # Update the game state only if a move was successful
                   self.render()
       return True
   ```
2. Implement function B

## Code Review Result
LBTM

# Format example 2
## Code Review: grid.py
1. Yes.
2. Yes.
3. Yes.
4. Yes.
5. Yes.
6. Yes.

## Actions
pass

## Code Review Result
LGTM



# Instruction: Based on the actual code situation, follow one of the "Format example". Return only 1 file under review.

## Code Review: Ordered List. Based on the "Code to be Reviewed", provide key, clear, concise, and specific answer. If any answer is no, explain how to fix it step by step.
1. Is the code implemented as per the requirements? If not, how to achieve it? Analyse it step by step.
2. Is the code logic completely correct? If there are errors, please indicate how to correct them.
3. Does the existing code follow the "Data structures and interfaces"?
4. Are all functions implemented? If there is no implementation, please indicate how to achieve it step by step.
5. Have all necessary pre-dependencies been imported? If not, indicate which ones need to be imported
6. Are methods from other files being reused correctly?

## Actions: Ordered List. Things that should be done after CR, such as implementing class A and function B

## Code Review Result: str. If the code doesn't have bugs, we don't need to rewrite it, so answer LGTM and stop. ONLY ANSWER LGTM/LBTM.
LGTM/LBTM






NOTICE
Role: You are a professional engineer; the main goal is to write google-style, elegant, modular, easy to read and maintain code
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## Design
{"Implementation approach":"We will build the game as a small, selfâcontained console application using the standard `curses` library for realâtime keyboard input and screen drawing. The core logic will be split into a handful of focused classes:\n\n* **Game** â owns the main loop, coordinates input, update and rendering, and manages the overall state (running, paused, gameâover).\n* **Snake** â stores the ordered list of grid coordinates that make up the snake, handles movement, growth and collision checks.\n* **Food** â keeps the current food position and can generate a new one that never overlaps the snake.\n* **Grid** â represents the 10Ã10 board, provides bounds checking and a helper to convert coordinates to screen positions.\n* **Renderer** â draws the grid, snake, food and UI elements (score, gameâover message) onto the curses window.\n* **InputHandler** â translates arrowâkey events into direction changes while preventing 180Â° reversals.\n\nThe game loop will run at a fixed tick rate (e.g. 10 frames per second). Each tick we:\n1. Poll for a key press.\n2. Update the snakeâs direction.\n3. Move the snake forward.\n4. Check for collisions (wall, self, food).\n5. Grow the snake and update the score if food is eaten.\n6. Render the updated state.\n\nThis separation keeps the code testable, readable and easily extensible (e.g. adding levels or AI). All state is kept in plain Python data structures (lists, tuples, ints) so no external dependencies are required beyond the standard library.\n\n","File list":["main.py","game.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -grid: Grid\n        -snake: Snake\n        -food: Food\n        -renderer: Renderer\n        -input_handler: InputHandler\n        -score: int\n        -running: bool\n        +__init__(window: curses.window)\n        +start() void\n        +handle_input() void\n        +update() void\n        +render() void\n        +game_over() void\n    }\n    class Snake {\n        -body: List[Tuple[int,int]]\n        -direction: Tuple[int,int]\n        +__init__(start_pos: Tuple[int,int], start_dir: Tuple[int,int])\n        +move() void\n        +grow() void\n        +set_direction(new_dir: Tuple[int,int]) void\n        +collides_with_self() bool\n        +collides_with_wall(grid: Grid) bool\n        +head() Tuple[int,int]\n    }\n    class Food {\n        -position: Tuple[int,int]\n        +__init__(grid: Grid, snake: Snake)\n        +generate_new(grid: Grid, snake: Snake) void\n        +position() Tuple[int,int]\n    }\n    class Grid {\n        -width: int\n        -height: int\n        +__init__(width: int, height: int)\n        +in_bounds(pos: Tuple[int,int]) bool\n        +to_screen_coords(pos: Tuple[int,int]) Tuple[int,int]\n    }\n    class Renderer {\n        -window: curses.window\n        +__init__(window: curses.window)\n        +draw(grid: Grid, snake: Snake, food: Food, score: int, game_over: bool) void\n        +clear() void\n    }\n    class InputHandler {\n        -last_direction: Tuple[int,int]\n        +__init__()\n        +get_direction(key: int) Tuple[int,int]\n    }\n    Game --> Snake\n    Game --> Food\n    Game --> Grid\n    Game --> Renderer\n    Game --> InputHandler\n    Snake --> Grid\n    Food --> Grid\n    Renderer --> Grid\n    Renderer --> Snake\n    Renderer --> Food\n","Program call flow":"\nsequenceDiagram\n    participant M as main\n    participant G as Game\n    participant I as InputHandler\n    participant S as Snake\n    participant F as Food\n    participant R as Renderer\n    participant Gd as Grid\n\n    M->>G: __init__(curses_window)\n    G->>Gd: __init__(10,10)\n    G->>S: __init__(center, RIGHT)\n    G->>F: __init__(Gd, S)\n    G->>R: __init__(curses_window)\n    G->>I: __init__()\n    G->>G: start()\n\n    loop every tick\n        G->>I: get_direction(key)\n        I->>G: set_direction\n        G->>S: move()\n        G->>S: collides_with_self() -> bool\n        alt collision\n            G->>G: game_over()\n            G->>R: draw(..., game_over=true)\n            G->>G: break loop\n        else\n            G->>F: position()\n            alt ate food\n                G->>S: grow()\n                G->>S: score++\n                G->>F: generate_new(Gd, S)\n            end\n            G->>R: draw(..., game_over=false)\n        end\n    end\n","Anything UNCLEAR":"The specification mentions \"optional animations for movement and growth\" but does not detail the desired effect. In a console environment, we can simulate a simple animation by briefly flashing the new head position or adding a short delay after growth. If more elaborate animations (e.g., smooth scrolling) are required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or if a graphical window is expected."}

## Task
{"Required Python packages":["No external packages required; uses only the standard library (curses, typing, etc.)"],"Required Other language third-party packages":["No thirdâparty dependencies required"],"Logic Analysis":[["main.py","Imports Game from game.py, initializes curses, creates Game instance, calls start()"],["game.py","Defines Game class: manages main loop, holds Grid, Snake, Food, Renderer, InputHandler, score, running flag; imports all component classes"],["snake.py","Defines Snake class: body list, direction tuple, move(), grow(), set_direction(), collides_with_self(), collides_with_wall(), head()"],["food.py","Defines Food class: position tuple, generate_new() that picks a random free cell, position() accessor"],["grid.py","Defines Grid class: width, height, in_bounds(), to_screen_coords()"],["renderer.py","Defines Renderer class: draws grid, snake, food, score, gameâover message; uses curses window"],["input_handler.py","Defines InputHandler class: get_direction() translates key codes to direction tuples, prevents 180Â° reversal"]],"Task list":["main.py","game.py","snake.py","food.py","grid.py","renderer.py","input_handler.py"],"Full API spec":"","Shared Knowledge":"All state is stored in plain Python data structures (lists, tuples, ints). The game is a console application using the curses library; no external GUI frameworks are required. Each component is isolated to aid testing and future extension (e.g., adding levels or AI).","Anything UNCLEAR":"The specification mentions optional animations for movement and growth but does not detail the desired effect. In a console environment, a simple flash or brief delay can simulate animation. If a richer graphical animation is required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or a graphical window is expected."}

## Legacy Code
```Code
----- main.py
```#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple, Optional

# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game state."""
        self.clear()

        # Draw border
        for x in range(grid.width + 2):
            self.window.addch(0, x, '#')
            self.window.addch(grid.height + 1, x, '#')
        for y in range(1, grid.height + 1):
            self.window.addch(y, 0, '#')
            self.window.addch(y, grid.width + 1, '#')

        # Draw food
        fx, fy = food.position
        sy, sx = grid.to_screen_coords((fx, fy))
        self.window.addch(sy + 1, sx + 1, '*')

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            cy, cx = grid.to_screen_coords((sx, sy))
            char = '@' if idx == 0 else 'O'
            self.window.addch(cy + 1, cx + 1, char)

        # Draw score
        score_text = f"Score: {score}"
        self.window.addstr(grid.height + 3, 0, score_text)

        # Draw game over message
        if game_over:
            msg = "GAME OVER! Press any key to exit."
            self.window.addstr(grid.height // 2, (grid.width - len(msg)) // 2, msg)

        self.window.refresh()


class InputHandler:
    """Translates key presses into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return a new direction based on the key, or keep current."""
        mapping = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        if new_dir != (-self.last_direction[0], -self.last_direction[1]):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per tick (10 FPS)

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (self.grid.width // 2, self.grid.height // 2)
        start_dir: Tuple[int, int] = (1, 0)  # Right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            start_time = time.time()

            # Handle input
            key = self.window.getch()
            if key != -1:
                new_dir = self.input_handler.get_direction(key)
                self.snake.set_direction(new_dir)

            # Update game state
            self.snake.move()

            # Collision checks
            if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
                self.game_over()
            else:
                # Check food consumption
                if self.snake.head() == self.food.position:
                    self.snake.grow()
                    self.score += 1
                    self.food.generate_new(self.grid, self.snake)

            # Render
            self.renderer.draw(
                self.grid,
                self.snake,
                self.food,
                self.score,
                self.game_over_flag,
            )

            # If game over, wait for key press to exit
            if self.game_over_flag:
                self.window.nodelay(False)
                self.window.getch()
                break

            # Maintain tick rate
            elapsed = time.time() - start_time
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Initialize and start the game."""
    game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)
```
----- game.py
```#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple


# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game screen."""
        self.clear()

        # Draw border
        for x in range(grid.width):
            self.window.addch(0, x, curses.ACS_HLINE)
            self.window.addch(grid.height + 1, x, curses.ACS_HLINE)
        for y in range(grid.height + 2):
            self.window.addch(y, 0, curses.ACS_VLINE)
            self.window.addch(y, grid.width + 1, curses.ACS_VLINE)
        self.window.addch(0, 0, curses.ACS_ULCORNER)
        self.window.addch(0, grid.width + 1, curses.ACS_URCORNER)
        self.window.addch(grid.height + 1, 0, curses.ACS_LLCORNER)
        self.window.addch(grid.height + 1, grid.width + 1, curses.ACS_LRCORNER)

        # Draw food
        fx, fy = food.position
        fy_screen, fx_screen = grid.to_screen_coords((fx, fy))
        self.window.addch(fy_screen + 1, fx_screen + 1, curses.ACS_PI)

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            sy_screen, sx_screen = grid.to_screen_coords((sx, sy))
            sy_screen += 1
            sx_screen += 1
            char: str = "@" if idx == 0 else "O"
            self.window.addch(sy_screen, sx_screen, char)

        # Draw score
        score_y: int = grid.height + 3
        score_x: int = 0
        score_text: str = f"Score: {score}"
        self.window.addstr(score_y, score_x, score_text)

        # Draw game over message if needed
        if game_over:
            msg: str = "GAME OVER! Press any key to exit."
            msg_y: int = grid.height // 2 + 1
            msg_x: int = (grid.width - len(msg)) // 2 + 1
            self.window.addstr(msg_y, msg_x, msg)

        self.window.refresh()


class InputHandler:
    """Processes user input and translates it into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default to moving right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return the new direction based on the pressed key."""
        mapping: dict[int, Tuple[int, int]] = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir: Tuple[int, int] = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        cur_dx, cur_dy = self.last_direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per frame

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window

        # Initialize components
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (
            self.grid.width // 2,
            self.grid.height // 2,
        )
        start_dir: Tuple[int, int] = (1, 0)  # Moving right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()

        # Game state
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    # ------------------------------------------------------------------
    # Game loop helpers
    # ------------------------------------------------------------------

    def handle_input(self) -> None:
        """Read user input and update snake direction."""
        key: int = self.window.getch()
        if key != -1:
            new_dir: Tuple[int, int] = self.input_handler.get_direction(key)
            self.snake.set_direction(new_dir)

    def update(self) -> None:
        """Advance game state: move snake, check collisions, handle food."""
        self.snake.move()

        # Collision detection
        if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
            self.game_over()
            return

        # Food consumption
        if self.snake.head() == self.food.position:
            self.snake.grow()
            self.score += 1
            self.food.generate_new(self.grid, self.snake)

    def render(self) -> None:
        """Render the current game state."""
        self.renderer.draw(
            self.grid,
            self.snake,
            self.food,
            self.score,
            self.game_over_flag,
        )

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True

    # ------------------------------------------------------------------
    # Main loop
    # ------------------------------------------------------------------

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            frame_start: float = time.time()

            self.handle_input()
            self.update()
            self.render()

            if self.game_over_flag:
                # Wait for a key press before exiting
                self.window.nodelay(False)
                self.window.getch()
                break

            elapsed: float = time.time() - frame_start
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Curses wrapper entry point."""
    game: Game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)
```
----- snake.py
```## snake.py
"""
Snake component for the console Snake game.

This module implements the :class:`Snake` class as specified in the
design documentation.  The implementation is fully typed, avoids
circular imports, and follows the public interface exactly.
"""

from __future__ import annotations

from typing import List, Tuple

# Import Grid only for type checking; no runtime dependency on grid.py
# to avoid circular imports.
from grid import Grid


class Snake:
    """
    Represents the snake in the game.

    Attributes
    ----------
    body : List[Tuple[int, int]]
        Ordered list of grid coordinates from head to tail.
    direction : Tuple[int, int]
        Current movement direction as a (dx, dy) pair.
    _grow_pending : bool
        Flag indicating whether the snake should grow on the next move.
    """

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        """
        Initialise a new snake.

        Parameters
        ----------
        start_pos : Tuple[int, int]
            Initial head position on the grid.
        start_dir : Tuple[int, int]
            Initial movement direction.
        """
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """
        Move the snake forward by one cell.

        The new head position is calculated from the current head and
        direction.  The new head is inserted at the front of the body
        list.  If a growth is pending, the tail is left intact; otherwise
        the last segment is removed to keep the length constant.
        """
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)

        if self._grow_pending:
            # Consume the growth flag; the snake has grown by one segment.
            self._grow_pending = False
        else:
            # Normal movement: remove the tail segment.
            self.body.pop()

    def grow(self) -> None:
        """
        Schedule the snake to grow on its next move.

        After calling this method, the snake will retain its tail segment
        during the next :meth:`move` call, effectively increasing its
        length by one.
        """
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """
        Change the snake's direction if it is not a 180Â° reversal.

        Parameters
        ----------
        new_dir : Tuple[int, int]
            Desired new direction as a (dx, dy) pair.
        """
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        # Prevent the snake from reversing onto itself.
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """
        Check whether the snake's head collides with its body.

        Returns
        -------
        bool
            ``True`` if the head occupies the same cell as any other
            segment of the body.
        """
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """
        Check whether the snake's head has moved outside the grid.

        Parameters
        ----------
        grid : Grid
            The game grid used for boundary checks.

        Returns
        -------
        bool
            ``True`` if the head position is not within the grid bounds.
        """
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """
        Retrieve the current head position.

        Returns
        -------
        Tuple[int, int]
            The (x, y) coordinates of the snake's head.
        """
        return self.body[0]
```
----- food.py
```## food.py
"""
Food component for the console Snake game.

This module implements the :class:`Food` class as specified in the
design documentation.  It is fully typed, avoids circular imports,
and exposes a clean public interface.

The class maintains a private ``_position`` attribute and exposes it
via a readâonly :pyattr:`position` property.  The ``generate_new`` method
places the food on a random free cell of the grid, avoiding the snake.
"""

from __future__ import annotations

import random
from typing import Tuple, List

# Import Grid and Snake only for type checking; this avoids circular
# imports at runtime while still providing full type information.
from grid import Grid
from snake import Snake


class Food:
    """
    Represents the food item in the game.

    Parameters
    ----------
    grid : Grid
        The game grid used for boundary checks.
    snake : Snake
        The snake instance; used to avoid placing food on the snake.

    Attributes
    ----------
    position : Tuple[int, int]
        Current grid coordinates of the food.
    """

    def __init__(self, grid: Grid, snake: Snake) -> None:
        """
        Initialise a new food instance.

        The default position is overwritten by :meth:`generate_new`.
        """
        self._position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """
        Place food on a random free cell.

        The method scans all cells in the grid, filters out those
        occupied by the snake, and selects one at random.  If the
        snake occupies the entire grid, the current position is
        retained.

        Parameters
        ----------
        grid : Grid
            The game grid used for boundary checks.
        snake : Snake
            The snake instance; used to avoid placing food on the snake.
        """
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]

        if not free_cells:
            # No free space left; keep current position
            return

        self._position = random.choice(free_cells)

    @property
    def position(self) -> Tuple[int, int]:
        """
        Return the current food position.

        Returns
        -------
        Tuple[int, int]
            The (x, y) coordinates of the food.
        """
        return self._position

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(position={self._position!r})"
```
----- grid.py
```## grid.py
"""
Grid component for the console Snake game.

This module implements the :class:`Grid` class as specified in the
design documentation.  It is intentionally lightweight and free of
runtime dependencies on other game modules to avoid circular imports.
"""

from __future__ import annotations

from typing import Tuple


class Grid:
    """
    Represents the game board.

    Attributes
    ----------
    width : int
        Number of columns in the grid.
    height : int
        Number of rows in the grid.
    """

    __slots__ = ("width", "height")

    def __init__(self, width: int = 10, height: int = 10) -> None:
        """
        Initialise a new grid.

        Parameters
        ----------
        width : int, optional
            Grid width (default 10).
        height : int, optional
            Grid height (default 10).
        """
        self.width = width
        self.height = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """
        Check whether a position lies inside the grid boundaries.

        Parameters
        ----------
        pos : Tuple[int, int]
            (x, y) coordinates to test.

        Returns
        -------
        bool
            ``True`` if the position is within the grid, otherwise
            ``False``.
        """
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert a grid coordinate to screen coordinates used by
        :class:`curses` rendering.

        The screen coordinate system places the origin (0, 0) at the
        topâleft corner of the visible area.  The grid is drawn
        starting at (1, 1) to leave room for a border.

        Parameters
        ----------
        pos : Tuple[int, int]
            (x, y) grid coordinate.

        Returns
        -------
        Tuple[int, int]
            (screen_y, screen_x) coordinate suitable for
            :func:`curses.addch` or :func:`curses.addstr`.
        """
        x, y = pos
        # Return screen coordinates with y first (row), then x (column)
        return (y, x)

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(width={self.width!r}, height={self.height!r})"
```
```

## Debug logs
```text



```

## Bug Feedback logs
```text

```

# Format example
## Code: renderer.py
```python
## renderer.py
...
```

# Instruction: Based on the context, follow "Format example", write code.

## Code: renderer.py. Write code with triple quoto, based on the following attentions and context.
1. Only One file: do your best to implement THIS ONLY ONE FILE.
2. COMPLETE CODE: Your code will be part of the entire project, so please implement complete, reliable, reusable code snippets.
3. Set default value: If there is any setting, ALWAYS SET A DEFAULT VALUE, ALWAYS USE STRONG TYPE AND EXPLICIT VARIABLE. AVOID circular import.
4. Follow design: YOU MUST FOLLOW "Data structures and interfaces". DONT CHANGE ANY DESIGN. Do not use public member functions that do not exist in your design.
5. CAREFULLY CHECK THAT YOU DONT MISS ANY NECESSARY CLASS/FUNCTION IN THIS FILE.
6. Before using a external variable/module, make sure you import it first.
7. Write out EVERY CODE DETAIL, DON'T LEAVE TODO.






# System
Role: You are a professional software engineer, and your main task is to review and revise the code. You need to ensure that the code conforms to the google-style standards, is elegantly designed and modularized, easy to read and maintain.
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## System Design
{"Implementation approach":"We will build the game as a small, selfâcontained console application using the standard `curses` library for realâtime keyboard input and screen drawing. The core logic will be split into a handful of focused classes:\n\n* **Game** â owns the main loop, coordinates input, update and rendering, and manages the overall state (running, paused, gameâover).\n* **Snake** â stores the ordered list of grid coordinates that make up the snake, handles movement, growth and collision checks.\n* **Food** â keeps the current food position and can generate a new one that never overlaps the snake.\n* **Grid** â represents the 10Ã10 board, provides bounds checking and a helper to convert coordinates to screen positions.\n* **Renderer** â draws the grid, snake, food and UI elements (score, gameâover message) onto the curses window.\n* **InputHandler** â translates arrowâkey events into direction changes while preventing 180Â° reversals.\n\nThe game loop will run at a fixed tick rate (e.g. 10 frames per second). Each tick we:\n1. Poll for a key press.\n2. Update the snakeâs direction.\n3. Move the snake forward.\n4. Check for collisions (wall, self, food).\n5. Grow the snake and update the score if food is eaten.\n6. Render the updated state.\n\nThis separation keeps the code testable, readable and easily extensible (e.g. adding levels or AI). All state is kept in plain Python data structures (lists, tuples, ints) so no external dependencies are required beyond the standard library.\n\n","File list":["main.py","game.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -grid: Grid\n        -snake: Snake\n        -food: Food\n        -renderer: Renderer\n        -input_handler: InputHandler\n        -score: int\n        -running: bool\n        +__init__(window: curses.window)\n        +start() void\n        +handle_input() void\n        +update() void\n        +render() void\n        +game_over() void\n    }\n    class Snake {\n        -body: List[Tuple[int,int]]\n        -direction: Tuple[int,int]\n        +__init__(start_pos: Tuple[int,int], start_dir: Tuple[int,int])\n        +move() void\n        +grow() void\n        +set_direction(new_dir: Tuple[int,int]) void\n        +collides_with_self() bool\n        +collides_with_wall(grid: Grid) bool\n        +head() Tuple[int,int]\n    }\n    class Food {\n        -position: Tuple[int,int]\n        +__init__(grid: Grid, snake: Snake)\n        +generate_new(grid: Grid, snake: Snake) void\n        +position() Tuple[int,int]\n    }\n    class Grid {\n        -width: int\n        -height: int\n        +__init__(width: int, height: int)\n        +in_bounds(pos: Tuple[int,int]) bool\n        +to_screen_coords(pos: Tuple[int,int]) Tuple[int,int]\n    }\n    class Renderer {\n        -window: curses.window\n        +__init__(window: curses.window)\n        +draw(grid: Grid, snake: Snake, food: Food, score: int, game_over: bool) void\n        +clear() void\n    }\n    class InputHandler {\n        -last_direction: Tuple[int,int]\n        +__init__()\n        +get_direction(key: int) Tuple[int,int]\n    }\n    Game --> Snake\n    Game --> Food\n    Game --> Grid\n    Game --> Renderer\n    Game --> InputHandler\n    Snake --> Grid\n    Food --> Grid\n    Renderer --> Grid\n    Renderer --> Snake\n    Renderer --> Food\n","Program call flow":"\nsequenceDiagram\n    participant M as main\n    participant G as Game\n    participant I as InputHandler\n    participant S as Snake\n    participant F as Food\n    participant R as Renderer\n    participant Gd as Grid\n\n    M->>G: __init__(curses_window)\n    G->>Gd: __init__(10,10)\n    G->>S: __init__(center, RIGHT)\n    G->>F: __init__(Gd, S)\n    G->>R: __init__(curses_window)\n    G->>I: __init__()\n    G->>G: start()\n\n    loop every tick\n        G->>I: get_direction(key)\n        I->>G: set_direction\n        G->>S: move()\n        G->>S: collides_with_self() -> bool\n        alt collision\n            G->>G: game_over()\n            G->>R: draw(..., game_over=true)\n            G->>G: break loop\n        else\n            G->>F: position()\n            alt ate food\n                G->>S: grow()\n                G->>S: score++\n                G->>F: generate_new(Gd, S)\n            end\n            G->>R: draw(..., game_over=false)\n        end\n    end\n","Anything UNCLEAR":"The specification mentions \"optional animations for movement and growth\" but does not detail the desired effect. In a console environment, we can simulate a simple animation by briefly flashing the new head position or adding a short delay after growth. If more elaborate animations (e.g., smooth scrolling) are required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or if a graphical window is expected."}

## Task
{"Required Python packages":["No external packages required; uses only the standard library (curses, typing, etc.)"],"Required Other language third-party packages":["No thirdâparty dependencies required"],"Logic Analysis":[["main.py","Imports Game from game.py, initializes curses, creates Game instance, calls start()"],["game.py","Defines Game class: manages main loop, holds Grid, Snake, Food, Renderer, InputHandler, score, running flag; imports all component classes"],["snake.py","Defines Snake class: body list, direction tuple, move(), grow(), set_direction(), collides_with_self(), collides_with_wall(), head()"],["food.py","Defines Food class: position tuple, generate_new() that picks a random free cell, position() accessor"],["grid.py","Defines Grid class: width, height, in_bounds(), to_screen_coords()"],["renderer.py","Defines Renderer class: draws grid, snake, food, score, gameâover message; uses curses window"],["input_handler.py","Defines InputHandler class: get_direction() translates key codes to direction tuples, prevents 180Â° reversal"]],"Task list":["main.py","game.py","snake.py","food.py","grid.py","renderer.py","input_handler.py"],"Full API spec":"","Shared Knowledge":"All state is stored in plain Python data structures (lists, tuples, ints). The game is a console application using the curses library; no external GUI frameworks are required. Each component is isolated to aid testing and future extension (e.g., adding levels or AI).","Anything UNCLEAR":"The specification mentions optional animations for movement and growth but does not detail the desired effect. In a console environment, a simple flash or brief delay can simulate animation. If a richer graphical animation is required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or a graphical window is expected."}

## Code Files
----- main.py
```#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple, Optional

# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game state."""
        self.clear()

        # Draw border
        for x in range(grid.width + 2):
            self.window.addch(0, x, '#')
            self.window.addch(grid.height + 1, x, '#')
        for y in range(1, grid.height + 1):
            self.window.addch(y, 0, '#')
            self.window.addch(y, grid.width + 1, '#')

        # Draw food
        fx, fy = food.position
        sy, sx = grid.to_screen_coords((fx, fy))
        self.window.addch(sy + 1, sx + 1, '*')

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            cy, cx = grid.to_screen_coords((sx, sy))
            char = '@' if idx == 0 else 'O'
            self.window.addch(cy + 1, cx + 1, char)

        # Draw score
        score_text = f"Score: {score}"
        self.window.addstr(grid.height + 3, 0, score_text)

        # Draw game over message
        if game_over:
            msg = "GAME OVER! Press any key to exit."
            self.window.addstr(grid.height // 2, (grid.width - len(msg)) // 2, msg)

        self.window.refresh()


class InputHandler:
    """Translates key presses into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return a new direction based on the key, or keep current."""
        mapping = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        if new_dir != (-self.last_direction[0], -self.last_direction[1]):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per tick (10 FPS)

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (self.grid.width // 2, self.grid.height // 2)
        start_dir: Tuple[int, int] = (1, 0)  # Right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            start_time = time.time()

            # Handle input
            key = self.window.getch()
            if key != -1:
                new_dir = self.input_handler.get_direction(key)
                self.snake.set_direction(new_dir)

            # Update game state
            self.snake.move()

            # Collision checks
            if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
                self.game_over()
            else:
                # Check food consumption
                if self.snake.head() == self.food.position:
                    self.snake.grow()
                    self.score += 1
                    self.food.generate_new(self.grid, self.snake)

            # Render
            self.renderer.draw(
                self.grid,
                self.snake,
                self.food,
                self.score,
                self.game_over_flag,
            )

            # If game over, wait for key press to exit
            if self.game_over_flag:
                self.window.nodelay(False)
                self.window.getch()
                break

            # Maintain tick rate
            elapsed = time.time() - start_time
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Initialize and start the game."""
    game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)
```
----- game.py
```#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple


# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game screen."""
        self.clear()

        # Draw border
        for x in range(grid.width):
            self.window.addch(0, x, curses.ACS_HLINE)
            self.window.addch(grid.height + 1, x, curses.ACS_HLINE)
        for y in range(grid.height + 2):
            self.window.addch(y, 0, curses.ACS_VLINE)
            self.window.addch(y, grid.width + 1, curses.ACS_VLINE)
        self.window.addch(0, 0, curses.ACS_ULCORNER)
        self.window.addch(0, grid.width + 1, curses.ACS_URCORNER)
        self.window.addch(grid.height + 1, 0, curses.ACS_LLCORNER)
        self.window.addch(grid.height + 1, grid.width + 1, curses.ACS_LRCORNER)

        # Draw food
        fx, fy = food.position
        fy_screen, fx_screen = grid.to_screen_coords((fx, fy))
        self.window.addch(fy_screen + 1, fx_screen + 1, curses.ACS_PI)

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            sy_screen, sx_screen = grid.to_screen_coords((sx, sy))
            sy_screen += 1
            sx_screen += 1
            char: str = "@" if idx == 0 else "O"
            self.window.addch(sy_screen, sx_screen, char)

        # Draw score
        score_y: int = grid.height + 3
        score_x: int = 0
        score_text: str = f"Score: {score}"
        self.window.addstr(score_y, score_x, score_text)

        # Draw game over message if needed
        if game_over:
            msg: str = "GAME OVER! Press any key to exit."
            msg_y: int = grid.height // 2 + 1
            msg_x: int = (grid.width - len(msg)) // 2 + 1
            self.window.addstr(msg_y, msg_x, msg)

        self.window.refresh()


class InputHandler:
    """Processes user input and translates it into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default to moving right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return the new direction based on the pressed key."""
        mapping: dict[int, Tuple[int, int]] = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir: Tuple[int, int] = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        cur_dx, cur_dy = self.last_direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per frame

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window

        # Initialize components
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (
            self.grid.width // 2,
            self.grid.height // 2,
        )
        start_dir: Tuple[int, int] = (1, 0)  # Moving right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()

        # Game state
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    # ------------------------------------------------------------------
    # Game loop helpers
    # ------------------------------------------------------------------

    def handle_input(self) -> None:
        """Read user input and update snake direction."""
        key: int = self.window.getch()
        if key != -1:
            new_dir: Tuple[int, int] = self.input_handler.get_direction(key)
            self.snake.set_direction(new_dir)

    def update(self) -> None:
        """Advance game state: move snake, check collisions, handle food."""
        self.snake.move()

        # Collision detection
        if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
            self.game_over()
            return

        # Food consumption
        if self.snake.head() == self.food.position:
            self.snake.grow()
            self.score += 1
            self.food.generate_new(self.grid, self.snake)

    def render(self) -> None:
        """Render the current game state."""
        self.renderer.draw(
            self.grid,
            self.snake,
            self.food,
            self.score,
            self.game_over_flag,
        )

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True

    # ------------------------------------------------------------------
    # Main loop
    # ------------------------------------------------------------------

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            frame_start: float = time.time()

            self.handle_input()
            self.update()
            self.render()

            if self.game_over_flag:
                # Wait for a key press before exiting
                self.window.nodelay(False)
                self.window.getch()
                break

            elapsed: float = time.time() - frame_start
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Curses wrapper entry point."""
    game: Game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)
```
----- snake.py
```## snake.py
"""
Snake component for the console Snake game.

This module implements the :class:`Snake` class as specified in the
design documentation.  The implementation is fully typed, avoids
circular imports, and follows the public interface exactly.
"""

from __future__ import annotations

from typing import List, Tuple

# Import Grid only for type checking; no runtime dependency on grid.py
# to avoid circular imports.
from grid import Grid


class Snake:
    """
    Represents the snake in the game.

    Attributes
    ----------
    body : List[Tuple[int, int]]
        Ordered list of grid coordinates from head to tail.
    direction : Tuple[int, int]
        Current movement direction as a (dx, dy) pair.
    _grow_pending : bool
        Flag indicating whether the snake should grow on the next move.
    """

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        """
        Initialise a new snake.

        Parameters
        ----------
        start_pos : Tuple[int, int]
            Initial head position on the grid.
        start_dir : Tuple[int, int]
            Initial movement direction.
        """
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """
        Move the snake forward by one cell.

        The new head position is calculated from the current head and
        direction.  The new head is inserted at the front of the body
        list.  If a growth is pending, the tail is left intact; otherwise
        the last segment is removed to keep the length constant.
        """
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)

        if self._grow_pending:
            # Consume the growth flag; the snake has grown by one segment.
            self._grow_pending = False
        else:
            # Normal movement: remove the tail segment.
            self.body.pop()

    def grow(self) -> None:
        """
        Schedule the snake to grow on its next move.

        After calling this method, the snake will retain its tail segment
        during the next :meth:`move` call, effectively increasing its
        length by one.
        """
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """
        Change the snake's direction if it is not a 180Â° reversal.

        Parameters
        ----------
        new_dir : Tuple[int, int]
            Desired new direction as a (dx, dy) pair.
        """
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        # Prevent the snake from reversing onto itself.
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """
        Check whether the snake's head collides with its body.

        Returns
        -------
        bool
            ``True`` if the head occupies the same cell as any other
            segment of the body.
        """
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """
        Check whether the snake's head has moved outside the grid.

        Parameters
        ----------
        grid : Grid
            The game grid used for boundary checks.

        Returns
        -------
        bool
            ``True`` if the head position is not within the grid bounds.
        """
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """
        Retrieve the current head position.

        Returns
        -------
        Tuple[int, int]
            The (x, y) coordinates of the snake's head.
        """
        return self.body[0]
```
----- food.py
```## food.py
"""
Food component for the console Snake game.

This module implements the :class:`Food` class as specified in the
design documentation.  It is fully typed, avoids circular imports,
and exposes a clean public interface.

The class maintains a private ``_position`` attribute and exposes it
via a readâonly :pyattr:`position` property.  The ``generate_new`` method
places the food on a random free cell of the grid, avoiding the snake.
"""

from __future__ import annotations

import random
from typing import Tuple, List

# Import Grid and Snake only for type checking; this avoids circular
# imports at runtime while still providing full type information.
from grid import Grid
from snake import Snake


class Food:
    """
    Represents the food item in the game.

    Parameters
    ----------
    grid : Grid
        The game grid used for boundary checks.
    snake : Snake
        The snake instance; used to avoid placing food on the snake.

    Attributes
    ----------
    position : Tuple[int, int]
        Current grid coordinates of the food.
    """

    def __init__(self, grid: Grid, snake: Snake) -> None:
        """
        Initialise a new food instance.

        The default position is overwritten by :meth:`generate_new`.
        """
        self._position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """
        Place food on a random free cell.

        The method scans all cells in the grid, filters out those
        occupied by the snake, and selects one at random.  If the
        snake occupies the entire grid, the current position is
        retained.

        Parameters
        ----------
        grid : Grid
            The game grid used for boundary checks.
        snake : Snake
            The snake instance; used to avoid placing food on the snake.
        """
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]

        if not free_cells:
            # No free space left; keep current position
            return

        self._position = random.choice(free_cells)

    @property
    def position(self) -> Tuple[int, int]:
        """
        Return the current food position.

        Returns
        -------
        Tuple[int, int]
            The (x, y) coordinates of the food.
        """
        return self._position

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(position={self._position!r})"
```
----- grid.py
```## grid.py
"""
Grid component for the console Snake game.

This module implements the :class:`Grid` class as specified in the
design documentation.  It is intentionally lightweight and free of
runtime dependencies on other game modules to avoid circular imports.
"""

from __future__ import annotations

from typing import Tuple


class Grid:
    """
    Represents the game board.

    Attributes
    ----------
    width : int
        Number of columns in the grid.
    height : int
        Number of rows in the grid.
    """

    __slots__ = ("width", "height")

    def __init__(self, width: int = 10, height: int = 10) -> None:
        """
        Initialise a new grid.

        Parameters
        ----------
        width : int, optional
            Grid width (default 10).
        height : int, optional
            Grid height (default 10).
        """
        self.width = width
        self.height = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """
        Check whether a position lies inside the grid boundaries.

        Parameters
        ----------
        pos : Tuple[int, int]
            (x, y) coordinates to test.

        Returns
        -------
        bool
            ``True`` if the position is within the grid, otherwise
            ``False``.
        """
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert a grid coordinate to screen coordinates used by
        :class:`curses` rendering.

        The screen coordinate system places the origin (0, 0) at the
        topâleft corner of the visible area.  The grid is drawn
        starting at (1, 1) to leave room for a border.

        Parameters
        ----------
        pos : Tuple[int, int]
            (x, y) grid coordinate.

        Returns
        -------
        Tuple[int, int]
            (screen_y, screen_x) coordinate suitable for
            :func:`curses.addch` or :func:`curses.addstr`.
        """
        x, y = pos
        # Return screen coordinates with y first (row), then x (column)
        return (y, x)

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(width={self.width!r}, height={self.height!r})"
```


## Code to be Reviewed: renderer.py
```Code
## renderer.py
"""
Renderer component for the console Snake game.

This module implements the :class:`Renderer` class as specified in the
design documentation.  The implementation is fully typed, avoids
circular imports, and follows the public interface exactly.
"""

from __future__ import annotations

import curses
from typing import Any

# Import type hints for Grid, Snake, and Food.  No circular imports
# are created because these modules do not import renderer.
from grid import Grid
from snake import Snake
from food import Food


class Renderer:
    """
    Handles drawing the game state onto the curses window.

    Parameters
    ----------
    window : curses.window
        The curses window used for rendering.
    """

    __slots__ = ("window",)

    def __init__(self, window: curses.window) -> None:
        """
        Initialise a new renderer.

        Parameters
        ----------
        window : curses.window
            The curses window used for rendering.
        """
        self.window: curses.window = window
        # Nonâblocking input so that getch() does not block the game loop.
        self.window.nodelay(True)
        # Hide the cursor for a cleaner look.
        curses.curs_set(0)

    # ------------------------------------------------------------------
    # Utility methods
    # ------------------------------------------------------------------
    def clear(self) -> None:
        """
        Clear the window before drawing a new frame.
        """
        self.window.erase()

    # ------------------------------------------------------------------
    # Rendering logic
    # ------------------------------------------------------------------
    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """
        Render the entire game screen.

        Parameters
        ----------
        grid : Grid
            The game grid.
        snake : Snake
            The snake instance.
        food : Food
            The food instance.
        score : int
            Current score.
        game_over : bool
            Flag indicating whether the game is over.
        """
        # Clear the window for a fresh frame.
        self.clear()

        # ------------------------------------------------------------------
        # Draw the border
        # ------------------------------------------------------------------
        # Horizontal lines
        hline: Any = curses.ACS_HLINE
        # Vertical lines
        vline: Any = curses.ACS_VLINE
        # Corners
        ulcorner: Any = curses.ACS_ULCORNER
        urcorner: Any = curses.ACS_URCORNER
        llcorner: Any = curses.ACS_LLCORNER
        lrcorner: Any = curses.ACS_LRCORNER

        # Top and bottom horizontal borders
        for x in range(grid.width):
            self.window.addch(0, x, hline)
            self.window.addch(grid.height + 1, x, hline)

        # Left and right vertical borders
        for y in range(grid.height + 2):
            self.window.addch(y, 0, vline)
            self.window.addch(y, grid.width + 1, vline)

        # Corners
        self.window.addch(0, 0, ulcorner)
        self.window.addch(0, grid.width + 1, urcorner)
        self.window.addch(grid.height + 1, 0, llcorner)
        self.window.addch(grid.height + 1, grid.width + 1, lrcorner)

        # ------------------------------------------------------------------
        # Draw the food
        # ------------------------------------------------------------------
        food_pos: tuple[int, int] = food.position
        food_screen_y: int = grid.to_screen_coords(food_pos)[0] + 1
        food_screen_x: int = grid.to_screen_coords(food_pos)[1] + 1
        # Use a distinct character for food.
        food_char: Any = curses.ACS_PI
        self.window.addch(food_screen_y, food_screen_x, food_char)

        # ------------------------------------------------------------------
        # Draw the snake
        # ------------------------------------------------------------------
        for idx, segment in enumerate(snake.body):
            segment_screen_y: int = grid.to_screen_coords(segment)[0] + 1
            segment_screen_x: int = grid.to_screen_coords(segment)[1] + 1
            # Head uses '@', body uses 'O'.
            segment_char: str = "@" if idx == 0 else "O"
            self.window.addch(segment_screen_y, segment_screen_x, segment_char)

        # ------------------------------------------------------------------
        # Draw the score
        # ------------------------------------------------------------------
        score_y: int = grid.height + 3
        score_x: int = 0
        score_text: str = f"Score: {score}"
        self.window.addstr(score_y, score_x, score_text)

        # ------------------------------------------------------------------
        # Draw the game over message if needed
        # ------------------------------------------------------------------
        if game_over:
            msg: str = "GAME OVER! Press any key to exit."
            msg_y: int = grid.height // 2 + 1
            msg_x: int = (grid.width - len(msg)) // 2 + 1
            self.window.addstr(msg_y, msg_x, msg)

        # Refresh the window to display all changes.
        self.window.refresh()

```



# Format example 1
## Code Review: renderer.py
1. No, we should fix the logic of class A due to ...
2. ...
3. ...
4. No, function B is not implemented, ...
5. ...
6. ...

## Actions
1. Fix the `handle_events` method to update the game state only if a move is successful.
   ```python
   def handle_events(self):
       for event in pygame.event.get():
           if event.type == pygame.QUIT:
               return False
           if event.type == pygame.KEYDOWN:
               moved = False
               if event.key == pygame.K_UP:
                   moved = self.game.move('UP')
               elif event.key == pygame.K_DOWN:
                   moved = self.game.move('DOWN')
               elif event.key == pygame.K_LEFT:
                   moved = self.game.move('LEFT')
               elif event.key == pygame.K_RIGHT:
                   moved = self.game.move('RIGHT')
               if moved:
                   # Update the game state only if a move was successful
                   self.render()
       return True
   ```
2. Implement function B

## Code Review Result
LBTM

# Format example 2
## Code Review: renderer.py
1. Yes.
2. Yes.
3. Yes.
4. Yes.
5. Yes.
6. Yes.

## Actions
pass

## Code Review Result
LGTM



# Instruction: Based on the actual code situation, follow one of the "Format example". Return only 1 file under review.

## Code Review: Ordered List. Based on the "Code to be Reviewed", provide key, clear, concise, and specific answer. If any answer is no, explain how to fix it step by step.
1. Is the code implemented as per the requirements? If not, how to achieve it? Analyse it step by step.
2. Is the code logic completely correct? If there are errors, please indicate how to correct them.
3. Does the existing code follow the "Data structures and interfaces"?
4. Are all functions implemented? If there is no implementation, please indicate how to achieve it step by step.
5. Have all necessary pre-dependencies been imported? If not, indicate which ones need to be imported
6. Are methods from other files being reused correctly?

## Actions: Ordered List. Things that should be done after CR, such as implementing class A and function B

## Code Review Result: str. If the code doesn't have bugs, we don't need to rewrite it, so answer LGTM and stop. ONLY ANSWER LGTM/LBTM.
LGTM/LBTM






NOTICE
Role: You are a professional engineer; the main goal is to write google-style, elegant, modular, easy to read and maintain code
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## Design
{"Implementation approach":"We will build the game as a small, selfâcontained console application using the standard `curses` library for realâtime keyboard input and screen drawing. The core logic will be split into a handful of focused classes:\n\n* **Game** â owns the main loop, coordinates input, update and rendering, and manages the overall state (running, paused, gameâover).\n* **Snake** â stores the ordered list of grid coordinates that make up the snake, handles movement, growth and collision checks.\n* **Food** â keeps the current food position and can generate a new one that never overlaps the snake.\n* **Grid** â represents the 10Ã10 board, provides bounds checking and a helper to convert coordinates to screen positions.\n* **Renderer** â draws the grid, snake, food and UI elements (score, gameâover message) onto the curses window.\n* **InputHandler** â translates arrowâkey events into direction changes while preventing 180Â° reversals.\n\nThe game loop will run at a fixed tick rate (e.g. 10 frames per second). Each tick we:\n1. Poll for a key press.\n2. Update the snakeâs direction.\n3. Move the snake forward.\n4. Check for collisions (wall, self, food).\n5. Grow the snake and update the score if food is eaten.\n6. Render the updated state.\n\nThis separation keeps the code testable, readable and easily extensible (e.g. adding levels or AI). All state is kept in plain Python data structures (lists, tuples, ints) so no external dependencies are required beyond the standard library.\n\n","File list":["main.py","game.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -grid: Grid\n        -snake: Snake\n        -food: Food\n        -renderer: Renderer\n        -input_handler: InputHandler\n        -score: int\n        -running: bool\n        +__init__(window: curses.window)\n        +start() void\n        +handle_input() void\n        +update() void\n        +render() void\n        +game_over() void\n    }\n    class Snake {\n        -body: List[Tuple[int,int]]\n        -direction: Tuple[int,int]\n        +__init__(start_pos: Tuple[int,int], start_dir: Tuple[int,int])\n        +move() void\n        +grow() void\n        +set_direction(new_dir: Tuple[int,int]) void\n        +collides_with_self() bool\n        +collides_with_wall(grid: Grid) bool\n        +head() Tuple[int,int]\n    }\n    class Food {\n        -position: Tuple[int,int]\n        +__init__(grid: Grid, snake: Snake)\n        +generate_new(grid: Grid, snake: Snake) void\n        +position() Tuple[int,int]\n    }\n    class Grid {\n        -width: int\n        -height: int\n        +__init__(width: int, height: int)\n        +in_bounds(pos: Tuple[int,int]) bool\n        +to_screen_coords(pos: Tuple[int,int]) Tuple[int,int]\n    }\n    class Renderer {\n        -window: curses.window\n        +__init__(window: curses.window)\n        +draw(grid: Grid, snake: Snake, food: Food, score: int, game_over: bool) void\n        +clear() void\n    }\n    class InputHandler {\n        -last_direction: Tuple[int,int]\n        +__init__()\n        +get_direction(key: int) Tuple[int,int]\n    }\n    Game --> Snake\n    Game --> Food\n    Game --> Grid\n    Game --> Renderer\n    Game --> InputHandler\n    Snake --> Grid\n    Food --> Grid\n    Renderer --> Grid\n    Renderer --> Snake\n    Renderer --> Food\n","Program call flow":"\nsequenceDiagram\n    participant M as main\n    participant G as Game\n    participant I as InputHandler\n    participant S as Snake\n    participant F as Food\n    participant R as Renderer\n    participant Gd as Grid\n\n    M->>G: __init__(curses_window)\n    G->>Gd: __init__(10,10)\n    G->>S: __init__(center, RIGHT)\n    G->>F: __init__(Gd, S)\n    G->>R: __init__(curses_window)\n    G->>I: __init__()\n    G->>G: start()\n\n    loop every tick\n        G->>I: get_direction(key)\n        I->>G: set_direction\n        G->>S: move()\n        G->>S: collides_with_self() -> bool\n        alt collision\n            G->>G: game_over()\n            G->>R: draw(..., game_over=true)\n            G->>G: break loop\n        else\n            G->>F: position()\n            alt ate food\n                G->>S: grow()\n                G->>S: score++\n                G->>F: generate_new(Gd, S)\n            end\n            G->>R: draw(..., game_over=false)\n        end\n    end\n","Anything UNCLEAR":"The specification mentions \"optional animations for movement and growth\" but does not detail the desired effect. In a console environment, we can simulate a simple animation by briefly flashing the new head position or adding a short delay after growth. If more elaborate animations (e.g., smooth scrolling) are required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or if a graphical window is expected."}

## Task
{"Required Python packages":["No external packages required; uses only the standard library (curses, typing, etc.)"],"Required Other language third-party packages":["No thirdâparty dependencies required"],"Logic Analysis":[["main.py","Imports Game from game.py, initializes curses, creates Game instance, calls start()"],["game.py","Defines Game class: manages main loop, holds Grid, Snake, Food, Renderer, InputHandler, score, running flag; imports all component classes"],["snake.py","Defines Snake class: body list, direction tuple, move(), grow(), set_direction(), collides_with_self(), collides_with_wall(), head()"],["food.py","Defines Food class: position tuple, generate_new() that picks a random free cell, position() accessor"],["grid.py","Defines Grid class: width, height, in_bounds(), to_screen_coords()"],["renderer.py","Defines Renderer class: draws grid, snake, food, score, gameâover message; uses curses window"],["input_handler.py","Defines InputHandler class: get_direction() translates key codes to direction tuples, prevents 180Â° reversal"]],"Task list":["main.py","game.py","snake.py","food.py","grid.py","renderer.py","input_handler.py"],"Full API spec":"","Shared Knowledge":"All state is stored in plain Python data structures (lists, tuples, ints). The game is a console application using the curses library; no external GUI frameworks are required. Each component is isolated to aid testing and future extension (e.g., adding levels or AI).","Anything UNCLEAR":"The specification mentions optional animations for movement and growth but does not detail the desired effect. In a console environment, a simple flash or brief delay can simulate animation. If a richer graphical animation is required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or a graphical window is expected."}

## Legacy Code
```Code
----- main.py
```#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple, Optional

# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game state."""
        self.clear()

        # Draw border
        for x in range(grid.width + 2):
            self.window.addch(0, x, '#')
            self.window.addch(grid.height + 1, x, '#')
        for y in range(1, grid.height + 1):
            self.window.addch(y, 0, '#')
            self.window.addch(y, grid.width + 1, '#')

        # Draw food
        fx, fy = food.position
        sy, sx = grid.to_screen_coords((fx, fy))
        self.window.addch(sy + 1, sx + 1, '*')

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            cy, cx = grid.to_screen_coords((sx, sy))
            char = '@' if idx == 0 else 'O'
            self.window.addch(cy + 1, cx + 1, char)

        # Draw score
        score_text = f"Score: {score}"
        self.window.addstr(grid.height + 3, 0, score_text)

        # Draw game over message
        if game_over:
            msg = "GAME OVER! Press any key to exit."
            self.window.addstr(grid.height // 2, (grid.width - len(msg)) // 2, msg)

        self.window.refresh()


class InputHandler:
    """Translates key presses into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return a new direction based on the key, or keep current."""
        mapping = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        if new_dir != (-self.last_direction[0], -self.last_direction[1]):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per tick (10 FPS)

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (self.grid.width // 2, self.grid.height // 2)
        start_dir: Tuple[int, int] = (1, 0)  # Right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            start_time = time.time()

            # Handle input
            key = self.window.getch()
            if key != -1:
                new_dir = self.input_handler.get_direction(key)
                self.snake.set_direction(new_dir)

            # Update game state
            self.snake.move()

            # Collision checks
            if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
                self.game_over()
            else:
                # Check food consumption
                if self.snake.head() == self.food.position:
                    self.snake.grow()
                    self.score += 1
                    self.food.generate_new(self.grid, self.snake)

            # Render
            self.renderer.draw(
                self.grid,
                self.snake,
                self.food,
                self.score,
                self.game_over_flag,
            )

            # If game over, wait for key press to exit
            if self.game_over_flag:
                self.window.nodelay(False)
                self.window.getch()
                break

            # Maintain tick rate
            elapsed = time.time() - start_time
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Initialize and start the game."""
    game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)
```
----- game.py
```#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple


# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game screen."""
        self.clear()

        # Draw border
        for x in range(grid.width):
            self.window.addch(0, x, curses.ACS_HLINE)
            self.window.addch(grid.height + 1, x, curses.ACS_HLINE)
        for y in range(grid.height + 2):
            self.window.addch(y, 0, curses.ACS_VLINE)
            self.window.addch(y, grid.width + 1, curses.ACS_VLINE)
        self.window.addch(0, 0, curses.ACS_ULCORNER)
        self.window.addch(0, grid.width + 1, curses.ACS_URCORNER)
        self.window.addch(grid.height + 1, 0, curses.ACS_LLCORNER)
        self.window.addch(grid.height + 1, grid.width + 1, curses.ACS_LRCORNER)

        # Draw food
        fx, fy = food.position
        fy_screen, fx_screen = grid.to_screen_coords((fx, fy))
        self.window.addch(fy_screen + 1, fx_screen + 1, curses.ACS_PI)

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            sy_screen, sx_screen = grid.to_screen_coords((sx, sy))
            sy_screen += 1
            sx_screen += 1
            char: str = "@" if idx == 0 else "O"
            self.window.addch(sy_screen, sx_screen, char)

        # Draw score
        score_y: int = grid.height + 3
        score_x: int = 0
        score_text: str = f"Score: {score}"
        self.window.addstr(score_y, score_x, score_text)

        # Draw game over message if needed
        if game_over:
            msg: str = "GAME OVER! Press any key to exit."
            msg_y: int = grid.height // 2 + 1
            msg_x: int = (grid.width - len(msg)) // 2 + 1
            self.window.addstr(msg_y, msg_x, msg)

        self.window.refresh()


class InputHandler:
    """Processes user input and translates it into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default to moving right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return the new direction based on the pressed key."""
        mapping: dict[int, Tuple[int, int]] = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir: Tuple[int, int] = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        cur_dx, cur_dy = self.last_direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per frame

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window

        # Initialize components
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (
            self.grid.width // 2,
            self.grid.height // 2,
        )
        start_dir: Tuple[int, int] = (1, 0)  # Moving right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()

        # Game state
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    # ------------------------------------------------------------------
    # Game loop helpers
    # ------------------------------------------------------------------

    def handle_input(self) -> None:
        """Read user input and update snake direction."""
        key: int = self.window.getch()
        if key != -1:
            new_dir: Tuple[int, int] = self.input_handler.get_direction(key)
            self.snake.set_direction(new_dir)

    def update(self) -> None:
        """Advance game state: move snake, check collisions, handle food."""
        self.snake.move()

        # Collision detection
        if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
            self.game_over()
            return

        # Food consumption
        if self.snake.head() == self.food.position:
            self.snake.grow()
            self.score += 1
            self.food.generate_new(self.grid, self.snake)

    def render(self) -> None:
        """Render the current game state."""
        self.renderer.draw(
            self.grid,
            self.snake,
            self.food,
            self.score,
            self.game_over_flag,
        )

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True

    # ------------------------------------------------------------------
    # Main loop
    # ------------------------------------------------------------------

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            frame_start: float = time.time()

            self.handle_input()
            self.update()
            self.render()

            if self.game_over_flag:
                # Wait for a key press before exiting
                self.window.nodelay(False)
                self.window.getch()
                break

            elapsed: float = time.time() - frame_start
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Curses wrapper entry point."""
    game: Game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)
```
----- snake.py
```## snake.py
"""
Snake component for the console Snake game.

This module implements the :class:`Snake` class as specified in the
design documentation.  The implementation is fully typed, avoids
circular imports, and follows the public interface exactly.
"""

from __future__ import annotations

from typing import List, Tuple

# Import Grid only for type checking; no runtime dependency on grid.py
# to avoid circular imports.
from grid import Grid


class Snake:
    """
    Represents the snake in the game.

    Attributes
    ----------
    body : List[Tuple[int, int]]
        Ordered list of grid coordinates from head to tail.
    direction : Tuple[int, int]
        Current movement direction as a (dx, dy) pair.
    _grow_pending : bool
        Flag indicating whether the snake should grow on the next move.
    """

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        """
        Initialise a new snake.

        Parameters
        ----------
        start_pos : Tuple[int, int]
            Initial head position on the grid.
        start_dir : Tuple[int, int]
            Initial movement direction.
        """
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """
        Move the snake forward by one cell.

        The new head position is calculated from the current head and
        direction.  The new head is inserted at the front of the body
        list.  If a growth is pending, the tail is left intact; otherwise
        the last segment is removed to keep the length constant.
        """
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)

        if self._grow_pending:
            # Consume the growth flag; the snake has grown by one segment.
            self._grow_pending = False
        else:
            # Normal movement: remove the tail segment.
            self.body.pop()

    def grow(self) -> None:
        """
        Schedule the snake to grow on its next move.

        After calling this method, the snake will retain its tail segment
        during the next :meth:`move` call, effectively increasing its
        length by one.
        """
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """
        Change the snake's direction if it is not a 180Â° reversal.

        Parameters
        ----------
        new_dir : Tuple[int, int]
            Desired new direction as a (dx, dy) pair.
        """
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        # Prevent the snake from reversing onto itself.
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """
        Check whether the snake's head collides with its body.

        Returns
        -------
        bool
            ``True`` if the head occupies the same cell as any other
            segment of the body.
        """
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """
        Check whether the snake's head has moved outside the grid.

        Parameters
        ----------
        grid : Grid
            The game grid used for boundary checks.

        Returns
        -------
        bool
            ``True`` if the head position is not within the grid bounds.
        """
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """
        Retrieve the current head position.

        Returns
        -------
        Tuple[int, int]
            The (x, y) coordinates of the snake's head.
        """
        return self.body[0]
```
----- food.py
```## food.py
"""
Food component for the console Snake game.

This module implements the :class:`Food` class as specified in the
design documentation.  It is fully typed, avoids circular imports,
and exposes a clean public interface.

The class maintains a private ``_position`` attribute and exposes it
via a readâonly :pyattr:`position` property.  The ``generate_new`` method
places the food on a random free cell of the grid, avoiding the snake.
"""

from __future__ import annotations

import random
from typing import Tuple, List

# Import Grid and Snake only for type checking; this avoids circular
# imports at runtime while still providing full type information.
from grid import Grid
from snake import Snake


class Food:
    """
    Represents the food item in the game.

    Parameters
    ----------
    grid : Grid
        The game grid used for boundary checks.
    snake : Snake
        The snake instance; used to avoid placing food on the snake.

    Attributes
    ----------
    position : Tuple[int, int]
        Current grid coordinates of the food.
    """

    def __init__(self, grid: Grid, snake: Snake) -> None:
        """
        Initialise a new food instance.

        The default position is overwritten by :meth:`generate_new`.
        """
        self._position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """
        Place food on a random free cell.

        The method scans all cells in the grid, filters out those
        occupied by the snake, and selects one at random.  If the
        snake occupies the entire grid, the current position is
        retained.

        Parameters
        ----------
        grid : Grid
            The game grid used for boundary checks.
        snake : Snake
            The snake instance; used to avoid placing food on the snake.
        """
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]

        if not free_cells:
            # No free space left; keep current position
            return

        self._position = random.choice(free_cells)

    @property
    def position(self) -> Tuple[int, int]:
        """
        Return the current food position.

        Returns
        -------
        Tuple[int, int]
            The (x, y) coordinates of the food.
        """
        return self._position

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(position={self._position!r})"
```
----- grid.py
```## grid.py
"""
Grid component for the console Snake game.

This module implements the :class:`Grid` class as specified in the
design documentation.  It is intentionally lightweight and free of
runtime dependencies on other game modules to avoid circular imports.
"""

from __future__ import annotations

from typing import Tuple


class Grid:
    """
    Represents the game board.

    Attributes
    ----------
    width : int
        Number of columns in the grid.
    height : int
        Number of rows in the grid.
    """

    __slots__ = ("width", "height")

    def __init__(self, width: int = 10, height: int = 10) -> None:
        """
        Initialise a new grid.

        Parameters
        ----------
        width : int, optional
            Grid width (default 10).
        height : int, optional
            Grid height (default 10).
        """
        self.width = width
        self.height = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """
        Check whether a position lies inside the grid boundaries.

        Parameters
        ----------
        pos : Tuple[int, int]
            (x, y) coordinates to test.

        Returns
        -------
        bool
            ``True`` if the position is within the grid, otherwise
            ``False``.
        """
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert a grid coordinate to screen coordinates used by
        :class:`curses` rendering.

        The screen coordinate system places the origin (0, 0) at the
        topâleft corner of the visible area.  The grid is drawn
        starting at (1, 1) to leave room for a border.

        Parameters
        ----------
        pos : Tuple[int, int]
            (x, y) grid coordinate.

        Returns
        -------
        Tuple[int, int]
            (screen_y, screen_x) coordinate suitable for
            :func:`curses.addch` or :func:`curses.addstr`.
        """
        x, y = pos
        # Return screen coordinates with y first (row), then x (column)
        return (y, x)

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(width={self.width!r}, height={self.height!r})"
```
----- renderer.py
```## renderer.py
"""
Renderer component for the console Snake game.

This module implements the :class:`Renderer` class as specified in the
design documentation.  The implementation is fully typed, avoids
circular imports, and follows the public interface exactly.
"""

from __future__ import annotations

import curses
from typing import Any

# Import type hints for Grid, Snake, and Food.  No circular imports
# are created because these modules do not import renderer.
from grid import Grid
from snake import Snake
from food import Food


class Renderer:
    """
    Handles drawing the game state onto the curses window.

    Parameters
    ----------
    window : curses.window
        The curses window used for rendering.
    """

    __slots__ = ("window",)

    def __init__(self, window: curses.window) -> None:
        """
        Initialise a new renderer.

        Parameters
        ----------
        window : curses.window
            The curses window used for rendering.
        """
        self.window: curses.window = window
        # Nonâblocking input so that getch() does not block the game loop.
        self.window.nodelay(True)
        # Hide the cursor for a cleaner look.
        curses.curs_set(0)

    # ------------------------------------------------------------------
    # Utility methods
    # ------------------------------------------------------------------
    def clear(self) -> None:
        """
        Clear the window before drawing a new frame.
        """
        self.window.erase()

    # ------------------------------------------------------------------
    # Rendering logic
    # ------------------------------------------------------------------
    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """
        Render the entire game screen.

        Parameters
        ----------
        grid : Grid
            The game grid.
        snake : Snake
            The snake instance.
        food : Food
            The food instance.
        score : int
            Current score.
        game_over : bool
            Flag indicating whether the game is over.
        """
        # Clear the window for a fresh frame.
        self.clear()

        # ------------------------------------------------------------------
        # Draw the border
        # ------------------------------------------------------------------
        # Horizontal lines
        hline: Any = curses.ACS_HLINE
        # Vertical lines
        vline: Any = curses.ACS_VLINE
        # Corners
        ulcorner: Any = curses.ACS_ULCORNER
        urcorner: Any = curses.ACS_URCORNER
        llcorner: Any = curses.ACS_LLCORNER
        lrcorner: Any = curses.ACS_LRCORNER

        # Top and bottom horizontal borders
        for x in range(grid.width):
            self.window.addch(0, x, hline)
            self.window.addch(grid.height + 1, x, hline)

        # Left and right vertical borders
        for y in range(grid.height + 2):
            self.window.addch(y, 0, vline)
            self.window.addch(y, grid.width + 1, vline)

        # Corners
        self.window.addch(0, 0, ulcorner)
        self.window.addch(0, grid.width + 1, urcorner)
        self.window.addch(grid.height + 1, 0, llcorner)
        self.window.addch(grid.height + 1, grid.width + 1, lrcorner)

        # ------------------------------------------------------------------
        # Draw the food
        # ------------------------------------------------------------------
        food_pos: tuple[int, int] = food.position
        food_screen_y: int = grid.to_screen_coords(food_pos)[0] + 1
        food_screen_x: int = grid.to_screen_coords(food_pos)[1] + 1
        # Use a distinct character for food.
        food_char: Any = curses.ACS_PI
        self.window.addch(food_screen_y, food_screen_x, food_char)

        # ------------------------------------------------------------------
        # Draw the snake
        # ------------------------------------------------------------------
        for idx, segment in enumerate(snake.body):
            segment_screen_y: int = grid.to_screen_coords(segment)[0] + 1
            segment_screen_x: int = grid.to_screen_coords(segment)[1] + 1
            # Head uses '@', body uses 'O'.
            segment_char: str = "@" if idx == 0 else "O"
            self.window.addch(segment_screen_y, segment_screen_x, segment_char)

        # ------------------------------------------------------------------
        # Draw the score
        # ------------------------------------------------------------------
        score_y: int = grid.height + 3
        score_x: int = 0
        score_text: str = f"Score: {score}"
        self.window.addstr(score_y, score_x, score_text)

        # ------------------------------------------------------------------
        # Draw the game over message if needed
        # ------------------------------------------------------------------
        if game_over:
            msg: str = "GAME OVER! Press any key to exit."
            msg_y: int = grid.height // 2 + 1
            msg_x: int = (grid.width - len(msg)) // 2 + 1
            self.window.addstr(msg_y, msg_x, msg)

        # Refresh the window to display all changes.
        self.window.refresh()
```
```

## Debug logs
```text



```

## Bug Feedback logs
```text

```

# Format example
## Code: input_handler.py
```python
## input_handler.py
...
```

# Instruction: Based on the context, follow "Format example", write code.

## Code: input_handler.py. Write code with triple quoto, based on the following attentions and context.
1. Only One file: do your best to implement THIS ONLY ONE FILE.
2. COMPLETE CODE: Your code will be part of the entire project, so please implement complete, reliable, reusable code snippets.
3. Set default value: If there is any setting, ALWAYS SET A DEFAULT VALUE, ALWAYS USE STRONG TYPE AND EXPLICIT VARIABLE. AVOID circular import.
4. Follow design: YOU MUST FOLLOW "Data structures and interfaces". DONT CHANGE ANY DESIGN. Do not use public member functions that do not exist in your design.
5. CAREFULLY CHECK THAT YOU DONT MISS ANY NECESSARY CLASS/FUNCTION IN THIS FILE.
6. Before using a external variable/module, make sure you import it first.
7. Write out EVERY CODE DETAIL, DON'T LEAVE TODO.






# System
Role: You are a professional software engineer, and your main task is to review and revise the code. You need to ensure that the code conforms to the google-style standards, is elegantly designed and modularized, easy to read and maintain.
Language: Please use the same language as the user requirement, but the title and code should be still in English. For example, if the user speaks Chinese, the specific text of your answer should also be in Chinese.
ATTENTION: Use '##' to SPLIT SECTIONS, not '#'. Output format carefully referenced "Format example".

# Context
## System Design
{"Implementation approach":"We will build the game as a small, selfâcontained console application using the standard `curses` library for realâtime keyboard input and screen drawing. The core logic will be split into a handful of focused classes:\n\n* **Game** â owns the main loop, coordinates input, update and rendering, and manages the overall state (running, paused, gameâover).\n* **Snake** â stores the ordered list of grid coordinates that make up the snake, handles movement, growth and collision checks.\n* **Food** â keeps the current food position and can generate a new one that never overlaps the snake.\n* **Grid** â represents the 10Ã10 board, provides bounds checking and a helper to convert coordinates to screen positions.\n* **Renderer** â draws the grid, snake, food and UI elements (score, gameâover message) onto the curses window.\n* **InputHandler** â translates arrowâkey events into direction changes while preventing 180Â° reversals.\n\nThe game loop will run at a fixed tick rate (e.g. 10 frames per second). Each tick we:\n1. Poll for a key press.\n2. Update the snakeâs direction.\n3. Move the snake forward.\n4. Check for collisions (wall, self, food).\n5. Grow the snake and update the score if food is eaten.\n6. Render the updated state.\n\nThis separation keeps the code testable, readable and easily extensible (e.g. adding levels or AI). All state is kept in plain Python data structures (lists, tuples, ints) so no external dependencies are required beyond the standard library.\n\n","File list":["main.py","game.py"],"Data structures and interfaces":"\nclassDiagram\n    class Game {\n        -grid: Grid\n        -snake: Snake\n        -food: Food\n        -renderer: Renderer\n        -input_handler: InputHandler\n        -score: int\n        -running: bool\n        +__init__(window: curses.window)\n        +start() void\n        +handle_input() void\n        +update() void\n        +render() void\n        +game_over() void\n    }\n    class Snake {\n        -body: List[Tuple[int,int]]\n        -direction: Tuple[int,int]\n        +__init__(start_pos: Tuple[int,int], start_dir: Tuple[int,int])\n        +move() void\n        +grow() void\n        +set_direction(new_dir: Tuple[int,int]) void\n        +collides_with_self() bool\n        +collides_with_wall(grid: Grid) bool\n        +head() Tuple[int,int]\n    }\n    class Food {\n        -position: Tuple[int,int]\n        +__init__(grid: Grid, snake: Snake)\n        +generate_new(grid: Grid, snake: Snake) void\n        +position() Tuple[int,int]\n    }\n    class Grid {\n        -width: int\n        -height: int\n        +__init__(width: int, height: int)\n        +in_bounds(pos: Tuple[int,int]) bool\n        +to_screen_coords(pos: Tuple[int,int]) Tuple[int,int]\n    }\n    class Renderer {\n        -window: curses.window\n        +__init__(window: curses.window)\n        +draw(grid: Grid, snake: Snake, food: Food, score: int, game_over: bool) void\n        +clear() void\n    }\n    class InputHandler {\n        -last_direction: Tuple[int,int]\n        +__init__()\n        +get_direction(key: int) Tuple[int,int]\n    }\n    Game --> Snake\n    Game --> Food\n    Game --> Grid\n    Game --> Renderer\n    Game --> InputHandler\n    Snake --> Grid\n    Food --> Grid\n    Renderer --> Grid\n    Renderer --> Snake\n    Renderer --> Food\n","Program call flow":"\nsequenceDiagram\n    participant M as main\n    participant G as Game\n    participant I as InputHandler\n    participant S as Snake\n    participant F as Food\n    participant R as Renderer\n    participant Gd as Grid\n\n    M->>G: __init__(curses_window)\n    G->>Gd: __init__(10,10)\n    G->>S: __init__(center, RIGHT)\n    G->>F: __init__(Gd, S)\n    G->>R: __init__(curses_window)\n    G->>I: __init__()\n    G->>G: start()\n\n    loop every tick\n        G->>I: get_direction(key)\n        I->>G: set_direction\n        G->>S: move()\n        G->>S: collides_with_self() -> bool\n        alt collision\n            G->>G: game_over()\n            G->>R: draw(..., game_over=true)\n            G->>G: break loop\n        else\n            G->>F: position()\n            alt ate food\n                G->>S: grow()\n                G->>S: score++\n                G->>F: generate_new(Gd, S)\n            end\n            G->>R: draw(..., game_over=false)\n        end\n    end\n","Anything UNCLEAR":"The specification mentions \"optional animations for movement and growth\" but does not detail the desired effect. In a console environment, we can simulate a simple animation by briefly flashing the new head position or adding a short delay after growth. If more elaborate animations (e.g., smooth scrolling) are required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or if a graphical window is expected."}

## Task
{"Required Python packages":["No external packages required; uses only the standard library (curses, typing, etc.)"],"Required Other language third-party packages":["No thirdâparty dependencies required"],"Logic Analysis":[["main.py","Imports Game from game.py, initializes curses, creates Game instance, calls start()"],["game.py","Defines Game class: manages main loop, holds Grid, Snake, Food, Renderer, InputHandler, score, running flag; imports all component classes"],["snake.py","Defines Snake class: body list, direction tuple, move(), grow(), set_direction(), collides_with_self(), collides_with_wall(), head()"],["food.py","Defines Food class: position tuple, generate_new() that picks a random free cell, position() accessor"],["grid.py","Defines Grid class: width, height, in_bounds(), to_screen_coords()"],["renderer.py","Defines Renderer class: draws grid, snake, food, score, gameâover message; uses curses window"],["input_handler.py","Defines InputHandler class: get_direction() translates key codes to direction tuples, prevents 180Â° reversal"]],"Task list":["main.py","game.py","snake.py","food.py","grid.py","renderer.py","input_handler.py"],"Full API spec":"","Shared Knowledge":"All state is stored in plain Python data structures (lists, tuples, ints). The game is a console application using the curses library; no external GUI frameworks are required. Each component is isolated to aid testing and future extension (e.g., adding levels or AI).","Anything UNCLEAR":"The specification mentions optional animations for movement and growth but does not detail the desired effect. In a console environment, a simple flash or brief delay can simulate animation. If a richer graphical animation is required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or a graphical window is expected."}

## Code Files
----- main.py
```#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple, Optional

# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game state."""
        self.clear()

        # Draw border
        for x in range(grid.width + 2):
            self.window.addch(0, x, '#')
            self.window.addch(grid.height + 1, x, '#')
        for y in range(1, grid.height + 1):
            self.window.addch(y, 0, '#')
            self.window.addch(y, grid.width + 1, '#')

        # Draw food
        fx, fy = food.position
        sy, sx = grid.to_screen_coords((fx, fy))
        self.window.addch(sy + 1, sx + 1, '*')

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            cy, cx = grid.to_screen_coords((sx, sy))
            char = '@' if idx == 0 else 'O'
            self.window.addch(cy + 1, cx + 1, char)

        # Draw score
        score_text = f"Score: {score}"
        self.window.addstr(grid.height + 3, 0, score_text)

        # Draw game over message
        if game_over:
            msg = "GAME OVER! Press any key to exit."
            self.window.addstr(grid.height // 2, (grid.width - len(msg)) // 2, msg)

        self.window.refresh()


class InputHandler:
    """Translates key presses into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return a new direction based on the key, or keep current."""
        mapping = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        if new_dir != (-self.last_direction[0], -self.last_direction[1]):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per tick (10 FPS)

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (self.grid.width // 2, self.grid.height // 2)
        start_dir: Tuple[int, int] = (1, 0)  # Right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            start_time = time.time()

            # Handle input
            key = self.window.getch()
            if key != -1:
                new_dir = self.input_handler.get_direction(key)
                self.snake.set_direction(new_dir)

            # Update game state
            self.snake.move()

            # Collision checks
            if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
                self.game_over()
            else:
                # Check food consumption
                if self.snake.head() == self.food.position:
                    self.snake.grow()
                    self.score += 1
                    self.food.generate_new(self.grid, self.snake)

            # Render
            self.renderer.draw(
                self.grid,
                self.snake,
                self.food,
                self.score,
                self.game_over_flag,
            )

            # If game over, wait for key press to exit
            if self.game_over_flag:
                self.window.nodelay(False)
                self.window.getch()
                break

            # Maintain tick rate
            elapsed = time.time() - start_time
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Initialize and start the game."""
    game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)
```
----- game.py
```#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Snake game implemented as a single, selfâcontained module.
The design follows the specification exactly:
- Game, Snake, Food, Grid, Renderer, InputHandler classes.
- No external dependencies beyond the standard library.
- The game runs in a curses terminal window.
"""

from __future__ import annotations

import curses
import random
import time
from typing import List, Tuple


# ----------------------------------------------------------------------
# Data structures and interfaces
# ----------------------------------------------------------------------


class Grid:
    """Represents the game board."""

    def __init__(self, width: int = 10, height: int = 10) -> None:
        self.width: int = width
        self.height: int = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """Return True if pos is inside the grid."""
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert grid coordinates to curses screen coordinates.
        In curses, y is row, x is column.
        """
        x, y = pos
        return y, x


class Snake:
    """Represents the snake."""

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """Move the snake forward by one cell."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if not self._grow_pending:
            self.body.pop()
        else:
            self._grow_pending = False

    def grow(self) -> None:
        """Set the snake to grow on the next move."""
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change the snake's direction if it is not a 180Â° reversal."""
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """Return True if the snake's head collides with its body."""
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """Return True if the snake's head is outside the grid."""
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """Return the current head position."""
        return self.body[0]


class Food:
    """Represents the food item."""

    def __init__(self, grid: Grid, snake: Snake) -> None:
        self.position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """Place food on a random free cell."""
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]
        if not free_cells:
            # No free space left; keep current position
            return
        self.position = random.choice(free_cells)

    def position(self) -> Tuple[int, int]:
        """Return the current food position."""
        return self.position


class Renderer:
    """Handles drawing the game state onto the curses window."""

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window
        self.window.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor

    def clear(self) -> None:
        """Clear the window."""
        self.window.erase()

    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """Render the entire game screen."""
        self.clear()

        # Draw border
        for x in range(grid.width):
            self.window.addch(0, x, curses.ACS_HLINE)
            self.window.addch(grid.height + 1, x, curses.ACS_HLINE)
        for y in range(grid.height + 2):
            self.window.addch(y, 0, curses.ACS_VLINE)
            self.window.addch(y, grid.width + 1, curses.ACS_VLINE)
        self.window.addch(0, 0, curses.ACS_ULCORNER)
        self.window.addch(0, grid.width + 1, curses.ACS_URCORNER)
        self.window.addch(grid.height + 1, 0, curses.ACS_LLCORNER)
        self.window.addch(grid.height + 1, grid.width + 1, curses.ACS_LRCORNER)

        # Draw food
        fx, fy = food.position
        fy_screen, fx_screen = grid.to_screen_coords((fx, fy))
        self.window.addch(fy_screen + 1, fx_screen + 1, curses.ACS_PI)

        # Draw snake
        for idx, (sx, sy) in enumerate(snake.body):
            sy_screen, sx_screen = grid.to_screen_coords((sx, sy))
            sy_screen += 1
            sx_screen += 1
            char: str = "@" if idx == 0 else "O"
            self.window.addch(sy_screen, sx_screen, char)

        # Draw score
        score_y: int = grid.height + 3
        score_x: int = 0
        score_text: str = f"Score: {score}"
        self.window.addstr(score_y, score_x, score_text)

        # Draw game over message if needed
        if game_over:
            msg: str = "GAME OVER! Press any key to exit."
            msg_y: int = grid.height // 2 + 1
            msg_x: int = (grid.width - len(msg)) // 2 + 1
            self.window.addstr(msg_y, msg_x, msg)

        self.window.refresh()


class InputHandler:
    """Processes user input and translates it into direction changes."""

    def __init__(self) -> None:
        self.last_direction: Tuple[int, int] = (1, 0)  # Default to moving right

    def get_direction(self, key: int) -> Tuple[int, int]:
        """Return the new direction based on the pressed key."""
        mapping: dict[int, Tuple[int, int]] = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }
        new_dir: Tuple[int, int] = mapping.get(key, self.last_direction)
        # Prevent 180Â° reversal
        cur_dx, cur_dy = self.last_direction
        new_dx, new_dy = new_dir
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.last_direction = new_dir
        return self.last_direction


class Game:
    """Main game controller."""

    TICK_RATE: float = 0.1  # Seconds per frame

    def __init__(self, window: curses.window) -> None:
        self.window: curses.window = window

        # Initialize components
        self.grid: Grid = Grid(width=10, height=10)
        start_pos: Tuple[int, int] = (
            self.grid.width // 2,
            self.grid.height // 2,
        )
        start_dir: Tuple[int, int] = (1, 0)  # Moving right
        self.snake: Snake = Snake(start_pos, start_dir)
        self.food: Food = Food(self.grid, self.snake)
        self.renderer: Renderer = Renderer(self.window)
        self.input_handler: InputHandler = InputHandler()

        # Game state
        self.score: int = 0
        self.running: bool = True
        self.game_over_flag: bool = False

    # ------------------------------------------------------------------
    # Game loop helpers
    # ------------------------------------------------------------------

    def handle_input(self) -> None:
        """Read user input and update snake direction."""
        key: int = self.window.getch()
        if key != -1:
            new_dir: Tuple[int, int] = self.input_handler.get_direction(key)
            self.snake.set_direction(new_dir)

    def update(self) -> None:
        """Advance game state: move snake, check collisions, handle food."""
        self.snake.move()

        # Collision detection
        if self.snake.collides_with_wall(self.grid) or self.snake.collides_with_self():
            self.game_over()
            return

        # Food consumption
        if self.snake.head() == self.food.position:
            self.snake.grow()
            self.score += 1
            self.food.generate_new(self.grid, self.snake)

    def render(self) -> None:
        """Render the current game state."""
        self.renderer.draw(
            self.grid,
            self.snake,
            self.food,
            self.score,
            self.game_over_flag,
        )

    def game_over(self) -> None:
        """Handle game over state."""
        self.running = False
        self.game_over_flag = True

    # ------------------------------------------------------------------
    # Main loop
    # ------------------------------------------------------------------

    def start(self) -> None:
        """Run the main game loop."""
        while self.running:
            frame_start: float = time.time()

            self.handle_input()
            self.update()
            self.render()

            if self.game_over_flag:
                # Wait for a key press before exiting
                self.window.nodelay(False)
                self.window.getch()
                break

            elapsed: float = time.time() - frame_start
            if elapsed < self.TICK_RATE:
                time.sleep(self.TICK_RATE - elapsed)


# ----------------------------------------------------------------------
# Entry point
# ----------------------------------------------------------------------


def main(stdscr: curses.window) -> None:
    """Curses wrapper entry point."""
    game: Game = Game(stdscr)
    game.start()


if __name__ == "__main__":
    curses.wrapper(main)
```
----- snake.py
```## snake.py
"""
Snake component for the console Snake game.

This module implements the :class:`Snake` class as specified in the
design documentation.  The implementation is fully typed, avoids
circular imports, and follows the public interface exactly.
"""

from __future__ import annotations

from typing import List, Tuple

# Import Grid only for type checking; no runtime dependency on grid.py
# to avoid circular imports.
from grid import Grid


class Snake:
    """
    Represents the snake in the game.

    Attributes
    ----------
    body : List[Tuple[int, int]]
        Ordered list of grid coordinates from head to tail.
    direction : Tuple[int, int]
        Current movement direction as a (dx, dy) pair.
    _grow_pending : bool
        Flag indicating whether the snake should grow on the next move.
    """

    def __init__(self, start_pos: Tuple[int, int], start_dir: Tuple[int, int]) -> None:
        """
        Initialise a new snake.

        Parameters
        ----------
        start_pos : Tuple[int, int]
            Initial head position on the grid.
        start_dir : Tuple[int, int]
            Initial movement direction.
        """
        self.body: List[Tuple[int, int]] = [start_pos]
        self.direction: Tuple[int, int] = start_dir
        self._grow_pending: bool = False

    def move(self) -> None:
        """
        Move the snake forward by one cell.

        The new head position is calculated from the current head and
        direction.  The new head is inserted at the front of the body
        list.  If a growth is pending, the tail is left intact; otherwise
        the last segment is removed to keep the length constant.
        """
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head: Tuple[int, int] = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)

        if self._grow_pending:
            # Consume the growth flag; the snake has grown by one segment.
            self._grow_pending = False
        else:
            # Normal movement: remove the tail segment.
            self.body.pop()

    def grow(self) -> None:
        """
        Schedule the snake to grow on its next move.

        After calling this method, the snake will retain its tail segment
        during the next :meth:`move` call, effectively increasing its
        length by one.
        """
        self._grow_pending = True

    def set_direction(self, new_dir: Tuple[int, int]) -> None:
        """
        Change the snake's direction if it is not a 180Â° reversal.

        Parameters
        ----------
        new_dir : Tuple[int, int]
            Desired new direction as a (dx, dy) pair.
        """
        cur_dx, cur_dy = self.direction
        new_dx, new_dy = new_dir
        # Prevent the snake from reversing onto itself.
        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.direction = new_dir

    def collides_with_self(self) -> bool:
        """
        Check whether the snake's head collides with its body.

        Returns
        -------
        bool
            ``True`` if the head occupies the same cell as any other
            segment of the body.
        """
        return self.body[0] in self.body[1:]

    def collides_with_wall(self, grid: Grid) -> bool:
        """
        Check whether the snake's head has moved outside the grid.

        Parameters
        ----------
        grid : Grid
            The game grid used for boundary checks.

        Returns
        -------
        bool
            ``True`` if the head position is not within the grid bounds.
        """
        return not grid.in_bounds(self.body[0])

    def head(self) -> Tuple[int, int]:
        """
        Retrieve the current head position.

        Returns
        -------
        Tuple[int, int]
            The (x, y) coordinates of the snake's head.
        """
        return self.body[0]
```
----- food.py
```## food.py
"""
Food component for the console Snake game.

This module implements the :class:`Food` class as specified in the
design documentation.  It is fully typed, avoids circular imports,
and exposes a clean public interface.

The class maintains a private ``_position`` attribute and exposes it
via a readâonly :pyattr:`position` property.  The ``generate_new`` method
places the food on a random free cell of the grid, avoiding the snake.
"""

from __future__ import annotations

import random
from typing import Tuple, List

# Import Grid and Snake only for type checking; this avoids circular
# imports at runtime while still providing full type information.
from grid import Grid
from snake import Snake


class Food:
    """
    Represents the food item in the game.

    Parameters
    ----------
    grid : Grid
        The game grid used for boundary checks.
    snake : Snake
        The snake instance; used to avoid placing food on the snake.

    Attributes
    ----------
    position : Tuple[int, int]
        Current grid coordinates of the food.
    """

    def __init__(self, grid: Grid, snake: Snake) -> None:
        """
        Initialise a new food instance.

        The default position is overwritten by :meth:`generate_new`.
        """
        self._position: Tuple[int, int] = (0, 0)
        self.generate_new(grid, snake)

    def generate_new(self, grid: Grid, snake: Snake) -> None:
        """
        Place food on a random free cell.

        The method scans all cells in the grid, filters out those
        occupied by the snake, and selects one at random.  If the
        snake occupies the entire grid, the current position is
        retained.

        Parameters
        ----------
        grid : Grid
            The game grid used for boundary checks.
        snake : Snake
            The snake instance; used to avoid placing food on the snake.
        """
        free_cells: List[Tuple[int, int]] = [
            (x, y)
            for x in range(grid.width)
            for y in range(grid.height)
            if (x, y) not in snake.body
        ]

        if not free_cells:
            # No free space left; keep current position
            return

        self._position = random.choice(free_cells)

    @property
    def position(self) -> Tuple[int, int]:
        """
        Return the current food position.

        Returns
        -------
        Tuple[int, int]
            The (x, y) coordinates of the food.
        """
        return self._position

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(position={self._position!r})"
```
----- grid.py
```## grid.py
"""
Grid component for the console Snake game.

This module implements the :class:`Grid` class as specified in the
design documentation.  It is intentionally lightweight and free of
runtime dependencies on other game modules to avoid circular imports.
"""

from __future__ import annotations

from typing import Tuple


class Grid:
    """
    Represents the game board.

    Attributes
    ----------
    width : int
        Number of columns in the grid.
    height : int
        Number of rows in the grid.
    """

    __slots__ = ("width", "height")

    def __init__(self, width: int = 10, height: int = 10) -> None:
        """
        Initialise a new grid.

        Parameters
        ----------
        width : int, optional
            Grid width (default 10).
        height : int, optional
            Grid height (default 10).
        """
        self.width = width
        self.height = height

    def in_bounds(self, pos: Tuple[int, int]) -> bool:
        """
        Check whether a position lies inside the grid boundaries.

        Parameters
        ----------
        pos : Tuple[int, int]
            (x, y) coordinates to test.

        Returns
        -------
        bool
            ``True`` if the position is within the grid, otherwise
            ``False``.
        """
        x, y = pos
        return 0 <= x < self.width and 0 <= y < self.height

    def to_screen_coords(self, pos: Tuple[int, int]) -> Tuple[int, int]:
        """
        Convert a grid coordinate to screen coordinates used by
        :class:`curses` rendering.

        The screen coordinate system places the origin (0, 0) at the
        topâleft corner of the visible area.  The grid is drawn
        starting at (1, 1) to leave room for a border.

        Parameters
        ----------
        pos : Tuple[int, int]
            (x, y) grid coordinate.

        Returns
        -------
        Tuple[int, int]
            (screen_y, screen_x) coordinate suitable for
            :func:`curses.addch` or :func:`curses.addstr`.
        """
        x, y = pos
        # Return screen coordinates with y first (row), then x (column)
        return (y, x)

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(width={self.width!r}, height={self.height!r})"
```
----- renderer.py
```## renderer.py
"""
Renderer component for the console Snake game.

This module implements the :class:`Renderer` class as specified in the
design documentation.  The implementation is fully typed, avoids
circular imports, and follows the public interface exactly.
"""

from __future__ import annotations

import curses
from typing import Any

# Import type hints for Grid, Snake, and Food.  No circular imports
# are created because these modules do not import renderer.
from grid import Grid
from snake import Snake
from food import Food


class Renderer:
    """
    Handles drawing the game state onto the curses window.

    Parameters
    ----------
    window : curses.window
        The curses window used for rendering.
    """

    __slots__ = ("window",)

    def __init__(self, window: curses.window) -> None:
        """
        Initialise a new renderer.

        Parameters
        ----------
        window : curses.window
            The curses window used for rendering.
        """
        self.window: curses.window = window
        # Nonâblocking input so that getch() does not block the game loop.
        self.window.nodelay(True)
        # Hide the cursor for a cleaner look.
        curses.curs_set(0)

    # ------------------------------------------------------------------
    # Utility methods
    # ------------------------------------------------------------------
    def clear(self) -> None:
        """
        Clear the window before drawing a new frame.
        """
        self.window.erase()

    # ------------------------------------------------------------------
    # Rendering logic
    # ------------------------------------------------------------------
    def draw(
        self,
        grid: Grid,
        snake: Snake,
        food: Food,
        score: int,
        game_over: bool,
    ) -> None:
        """
        Render the entire game screen.

        Parameters
        ----------
        grid : Grid
            The game grid.
        snake : Snake
            The snake instance.
        food : Food
            The food instance.
        score : int
            Current score.
        game_over : bool
            Flag indicating whether the game is over.
        """
        # Clear the window for a fresh frame.
        self.clear()

        # ------------------------------------------------------------------
        # Draw the border
        # ------------------------------------------------------------------
        # Horizontal lines
        hline: Any = curses.ACS_HLINE
        # Vertical lines
        vline: Any = curses.ACS_VLINE
        # Corners
        ulcorner: Any = curses.ACS_ULCORNER
        urcorner: Any = curses.ACS_URCORNER
        llcorner: Any = curses.ACS_LLCORNER
        lrcorner: Any = curses.ACS_LRCORNER

        # Top and bottom horizontal borders
        for x in range(grid.width):
            self.window.addch(0, x, hline)
            self.window.addch(grid.height + 1, x, hline)

        # Left and right vertical borders
        for y in range(grid.height + 2):
            self.window.addch(y, 0, vline)
            self.window.addch(y, grid.width + 1, vline)

        # Corners
        self.window.addch(0, 0, ulcorner)
        self.window.addch(0, grid.width + 1, urcorner)
        self.window.addch(grid.height + 1, 0, llcorner)
        self.window.addch(grid.height + 1, grid.width + 1, lrcorner)

        # ------------------------------------------------------------------
        # Draw the food
        # ------------------------------------------------------------------
        food_pos: tuple[int, int] = food.position
        food_screen_y: int = grid.to_screen_coords(food_pos)[0] + 1
        food_screen_x: int = grid.to_screen_coords(food_pos)[1] + 1
        # Use a distinct character for food.
        food_char: Any = curses.ACS_PI
        self.window.addch(food_screen_y, food_screen_x, food_char)

        # ------------------------------------------------------------------
        # Draw the snake
        # ------------------------------------------------------------------
        for idx, segment in enumerate(snake.body):
            segment_screen_y: int = grid.to_screen_coords(segment)[0] + 1
            segment_screen_x: int = grid.to_screen_coords(segment)[1] + 1
            # Head uses '@', body uses 'O'.
            segment_char: str = "@" if idx == 0 else "O"
            self.window.addch(segment_screen_y, segment_screen_x, segment_char)

        # ------------------------------------------------------------------
        # Draw the score
        # ------------------------------------------------------------------
        score_y: int = grid.height + 3
        score_x: int = 0
        score_text: str = f"Score: {score}"
        self.window.addstr(score_y, score_x, score_text)

        # ------------------------------------------------------------------
        # Draw the game over message if needed
        # ------------------------------------------------------------------
        if game_over:
            msg: str = "GAME OVER! Press any key to exit."
            msg_y: int = grid.height // 2 + 1
            msg_x: int = (grid.width - len(msg)) // 2 + 1
            self.window.addstr(msg_y, msg_x, msg)

        # Refresh the window to display all changes.
        self.window.refresh()
```


## Code to be Reviewed: input_handler.py
```Code
## input_handler.py
"""
InputHandler component for the console Snake game.

This module implements the :class:`InputHandler` class as specified in
the design documentation.  The implementation is fully typed, avoids
circular imports, and follows the public interface exactly.
"""

from __future__ import annotations

import curses
from typing import Any, Tuple

# No runtime imports from other game modules to avoid circular dependencies.
# The InputHandler only needs the curses module for key mapping constants.

class InputHandler:
    """
    Handles user input and translates it into snake movement directions.

    Attributes
    ----------
    last_direction : Tuple[int, int]
        The most recent direction chosen by the player.  This value
        is updated only when a valid key press is received and the
        direction does not reverse the snake.
    """

    __slots__ = ("last_direction",)

    def __init__(self) -> None:
        """
        Initialise a new InputHandler instance.

        The default direction is set to (0, 0) which represents no
        movement.  This value is overwritten as soon as a valid key
        is pressed.
        """
        self.last_direction: Tuple[int, int] = (0, 0)

    def get_direction(self, key: int) -> Tuple[int, int]:
        """
        Translate a key press into a movement direction.

        Parameters
        ----------
        key : int
            The key code returned by :func:`curses.getch`.

        Returns
        -------
        Tuple[int, int]
            The new direction as a (dx, dy) pair.  If the key press
            does not correspond to a recognised arrow key, the
            previous direction is returned unchanged.
        """
        # Mapping of key codes to direction vectors.
        # The values are defined as (dx, dy) where dx is horizontal
        # movement and dy is vertical movement.
        mapping: dict[int, Tuple[int, int]] = {
            curses.KEY_UP: (0, -1),
            curses.KEY_DOWN: (0, 1),
            curses.KEY_LEFT: (-1, 0),
            curses.KEY_RIGHT: (1, 0),
        }

        # Retrieve the new direction from the mapping; if the key is
        # not present, keep the current direction.
        new_direction: Tuple[int, int] = mapping.get(key, self.last_direction)

        # Prevent the snake from reversing onto itself.  A 180Â°
        # reversal would be indicated by the new direction being the
        # negative of the current direction.
        cur_dx: int = self.last_direction[0]
        cur_dy: int = self.last_direction[1]
        new_dx: int = new_direction[0]
        new_dy: int = new_direction[1]

        if (new_dx, new_dy) != (-cur_dx, -cur_dy):
            self.last_direction = new_direction

        return self.last_direction

```



# Format example 1
## Code Review: input_handler.py
1. No, we should fix the logic of class A due to ...
2. ...
3. ...
4. No, function B is not implemented, ...
5. ...
6. ...

## Actions
1. Fix the `handle_events` method to update the game state only if a move is successful.
   ```python
   def handle_events(self):
       for event in pygame.event.get():
           if event.type == pygame.QUIT:
               return False
           if event.type == pygame.KEYDOWN:
               moved = False
               if event.key == pygame.K_UP:
                   moved = self.game.move('UP')
               elif event.key == pygame.K_DOWN:
                   moved = self.game.move('DOWN')
               elif event.key == pygame.K_LEFT:
                   moved = self.game.move('LEFT')
               elif event.key == pygame.K_RIGHT:
                   moved = self.game.move('RIGHT')
               if moved:
                   # Update the game state only if a move was successful
                   self.render()
       return True
   ```
2. Implement function B

## Code Review Result
LBTM

# Format example 2
## Code Review: input_handler.py
1. Yes.
2. Yes.
3. Yes.
4. Yes.
5. Yes.
6. Yes.

## Actions
pass

## Code Review Result
LGTM



# Instruction: Based on the actual code situation, follow one of the "Format example". Return only 1 file under review.

## Code Review: Ordered List. Based on the "Code to be Reviewed", provide key, clear, concise, and specific answer. If any answer is no, explain how to fix it step by step.
1. Is the code implemented as per the requirements? If not, how to achieve it? Analyse it step by step.
2. Is the code logic completely correct? If there are errors, please indicate how to correct them.
3. Does the existing code follow the "Data structures and interfaces"?
4. Are all functions implemented? If there is no implementation, please indicate how to achieve it step by step.
5. Have all necessary pre-dependencies been imported? If not, indicate which ones need to be imported
6. Are methods from other files being reused correctly?

## Actions: Ordered List. Things that should be done after CR, such as implementing class A and function B

## Code Review Result: str. If the code doesn't have bugs, we don't need to rewrite it, so answer LGTM and stop. ONLY ANSWER LGTM/LBTM.
LGTM/LBTM





