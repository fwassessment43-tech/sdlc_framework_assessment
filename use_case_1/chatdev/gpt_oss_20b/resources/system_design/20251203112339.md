## Implementation approach

We will build the game as a small, self‑contained console application using the standard `curses` library for real‑time keyboard input and screen drawing. The core logic will be split into a handful of focused classes:

* **Game** – owns the main loop, coordinates input, update and rendering, and manages the overall state (running, paused, game‑over).
* **Snake** – stores the ordered list of grid coordinates that make up the snake, handles movement, growth and collision checks.
* **Food** – keeps the current food position and can generate a new one that never overlaps the snake.
* **Grid** – represents the 10×10 board, provides bounds checking and a helper to convert coordinates to screen positions.
* **Renderer** – draws the grid, snake, food and UI elements (score, game‑over message) onto the curses window.
* **InputHandler** – translates arrow‑key events into direction changes while preventing 180° reversals.

The game loop will run at a fixed tick rate (e.g. 10 frames per second). Each tick we:
1. Poll for a key press.
2. Update the snake’s direction.
3. Move the snake forward.
4. Check for collisions (wall, self, food).
5. Grow the snake and update the score if food is eaten.
6. Render the updated state.

This separation keeps the code testable, readable and easily extensible (e.g. adding levels or AI). All state is kept in plain Python data structures (lists, tuples, ints) so no external dependencies are required beyond the standard library.



## File list

- main.py
- game.py

## Data structures and interfaces


classDiagram
    class Game {
        -grid: Grid
        -snake: Snake
        -food: Food
        -renderer: Renderer
        -input_handler: InputHandler
        -score: int
        -running: bool
        +__init__(window: curses.window)
        +start() void
        +handle_input() void
        +update() void
        +render() void
        +game_over() void
    }
    class Snake {
        -body: List[Tuple[int,int]]
        -direction: Tuple[int,int]
        +__init__(start_pos: Tuple[int,int], start_dir: Tuple[int,int])
        +move() void
        +grow() void
        +set_direction(new_dir: Tuple[int,int]) void
        +collides_with_self() bool
        +collides_with_wall(grid: Grid) bool
        +head() Tuple[int,int]
    }
    class Food {
        -position: Tuple[int,int]
        +__init__(grid: Grid, snake: Snake)
        +generate_new(grid: Grid, snake: Snake) void
        +position() Tuple[int,int]
    }
    class Grid {
        -width: int
        -height: int
        +__init__(width: int, height: int)
        +in_bounds(pos: Tuple[int,int]) bool
        +to_screen_coords(pos: Tuple[int,int]) Tuple[int,int]
    }
    class Renderer {
        -window: curses.window
        +__init__(window: curses.window)
        +draw(grid: Grid, snake: Snake, food: Food, score: int, game_over: bool) void
        +clear() void
    }
    class InputHandler {
        -last_direction: Tuple[int,int]
        +__init__()
        +get_direction(key: int) Tuple[int,int]
    }
    Game --> Snake
    Game --> Food
    Game --> Grid
    Game --> Renderer
    Game --> InputHandler
    Snake --> Grid
    Food --> Grid
    Renderer --> Grid
    Renderer --> Snake
    Renderer --> Food


## Program call flow


sequenceDiagram
    participant M as main
    participant G as Game
    participant I as InputHandler
    participant S as Snake
    participant F as Food
    participant R as Renderer
    participant Gd as Grid

    M->>G: __init__(curses_window)
    G->>Gd: __init__(10,10)
    G->>S: __init__(center, RIGHT)
    G->>F: __init__(Gd, S)
    G->>R: __init__(curses_window)
    G->>I: __init__()
    G->>G: start()

    loop every tick
        G->>I: get_direction(key)
        I->>G: set_direction
        G->>S: move()
        G->>S: collides_with_self() -> bool
        alt collision
            G->>G: game_over()
            G->>R: draw(..., game_over=true)
            G->>G: break loop
        else
            G->>F: position()
            alt ate food
                G->>S: grow()
                G->>S: score++
                G->>F: generate_new(Gd, S)
            end
            G->>R: draw(..., game_over=false)
        end
    end


## Anything UNCLEAR

The specification mentions "optional animations for movement and growth" but does not detail the desired effect. In a console environment, we can simulate a simple animation by briefly flashing the new head position or adding a short delay after growth. If more elaborate animations (e.g., smooth scrolling) are required, a different rendering backend (e.g., Pygame) would be necessary. Clarify whether the simple console animation suffices or if a graphical window is expected.

