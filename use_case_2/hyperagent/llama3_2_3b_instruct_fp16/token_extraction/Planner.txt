To develop this ticket management web application, we'll break it down into smaller tasks and implement each component using Python programming language.

**Step 1: Login Page**

We'll use a simple GUI library like Tkinter to create the login page. We won't implement any user management system for now.

```python
import tkinter as tk
from tkinter import messagebox

class LoginPage:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Login Page")

        self.username_label = tk.Label(self.root, text="Username")
        self.username_label.pack()

        self.username_entry = tk.Entry(self.root)
        self.username_entry.pack()

        self.password_label = tk.Label(self.root, text="Password")
        self.password_label.pack()

        self.password_entry = tk.Entry(self.root, show="*")
        self.password_entry.pack()

        self.login_button = tk.Button(self.root, text="Login", command=self.login)
        self.login_button.pack()

    def login(self):
        # TO DO: Implement authentication logic
        username = self.username_entry.get()
        password = self.password_entry.get()
        if username == "admin" and password == "password":
            print("Login successful")
            # Create a new instance of TicketManagementApp
            self.root.destroy()
            TicketManagementApp()
        else:
            messagebox.showerror("Invalid credentials", "Please try again")

    def run(self):
        self.root.mainloop()

if __name__ == "__main__":
    login_page = LoginPage()
    login_page.run()
```

**Step 2: Ticket Management System**

We'll create a GUI using Tkinter to manage tickets. Simple users can insert new tickets and view/modify existing ones, while helpdesk users can change ticket status and exchange messages.

```python
import tkinter as tk
from tkinter import messagebox

class TicketManagementApp:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Ticket Management App")

        # Create a frame for the main menu
        self.main_menu_frame = tk.Frame(self.root)
        self.main_menu_frame.pack()

        # Create buttons for simple users and helpdesk users
        self.simple_user_button = tk.Button(self.main_menu_frame, text="Simple User", command=self.simple_user_menu)
        self.simple_user_button.pack(side=tk.LEFT)

        self.helpdesk_user_button = tk.Button(self.main_menu_frame, text="Helpdesk User", command=self.helpdesk_user_menu)
        self.helpdesk_user_button.pack(side=tk.LEFT)

    def simple_user_menu(self):
        # Create a new instance of SimpleUserMenu
        self.simple_user_menu_instance = SimpleUserMenu()
        self.simple_user_menu_instance.run()

    def helpdesk_user_menu(self):
        # Create a new instance of HelpdeskUserMenu
        self.helpdesk_user_menu_instance = HelpdeskUserMenu()
        self.helpdesk_user_menu_instance.run()

    def run(self):
        self.root.mainloop()

class SimpleUserMenu:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Simple User Menu")

        # Create a frame for the ticket list
        self.ticket_list_frame = tk.Frame(self.root)
        self.ticket_list_frame.pack()

        # Create a button to insert new tickets
        self.insert_ticket_button = tk.Button(self.root, text="Insert New Ticket", command=self.insert_new_ticket)
        self.insert_ticket_button.pack()

    def insert_new_ticket(self):
        # Insert a new ticket into the database
        # TO DO: Implement insertion logic

        # Create a new window to display the inserted ticket
        self.new_ticket_window = tk.Toplevel(self.root)
        self.new_ticket_window.title("New Ticket")

        # Display the inserted ticket in the new window
        # TO DO: Implement display logic

    def run(self):
        self.root.mainloop()

class HelpdeskUserMenu:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Helpdesk User Menu")

        # Create a frame for the ticket list
        self.ticket_list_frame = tk.Frame(self.root)
        self.ticket_list_frame.pack()

        # Create buttons to view and modify tickets
        self.view_ticket_button = tk.Button(self.root, text="View Tickets", command=self.view_tickets)
        self.view_ticket_button.pack()

        self.modify_ticket_button = tk.Button(self.root, text="Modify Ticket", command=self.modify_ticket)
        self.modify_ticket_button.pack()

    def view_tickets(self):
        # View all open and active tickets
        # TO DO: Implement view logic

    def modify_ticket(self):
        # Modify an existing ticket
        # TO DO: Implement modification logic

    def run(self):
        self.root.mainloop()
```

**Step 3: Micro-Services Architecture**

We'll create a micro-services architecture using Flask to provide data visualization and analysis functionalities.

```python
from flask import Flask, request, jsonify
import pandas as pd

app = Flask(__name__)

# Create a database to store ticket data
tickets_db = pd.DataFrame({
    "id": [1, 2, 3],
    "status": ["open", "active", "closed"],
    "description": ["Ticket 1", "Ticket 2", "Ticket 3"]
})

@app.route("/get_tickets", methods=["GET"])
def get_tickets():
    # Get the number of open tickets in the last X hours
    x_hours = int(request.args.get("x_hours"))
    open_tickets = tickets_db[tickets_db["status"] == "open"][tickets_db["created_at"].dt.date - pd.Timestamp.now().date()] <= x_hours
    return jsonify({"count": len(open_tickets)})


@app.route("/get_average_resolution_time", methods=["GET"])
def get_average_resolution_time():
    # Get the average resolution time by month
    monthlyResolutionTime = tickets_db[tickets_db["status"] == "closed"].groupby(tickets_db["created_at"].dt.month)["resolution_time"].mean()
    return jsonify({"average": monthlyResolutionTime.mean()})


@app.route("/get_tickets_by_category", methods=["GET"])
def get_tickets_by_category():
    # Get the number of active tickets per category
    categories = tickets_db[tickets_db["status"] == "active"]["category"].unique()
    active_tickets_per_category = [len(tickets_db[(tickets_db["status"] == "active") & (tickets_db["category"] == category)]) for category in categories]
    return jsonify({"categories": [{"category": category, "count": count} for category, count in zip(categories, active_tickets_per_category)]})

if __name__ == "__main__":
    app.run(debug=True)
```

This is a basic implementation of the ticket management system and micro-services architecture. There are many improvements that can be made to make it more robust and efficient.

**Step 4: Database**

We'll create a database using SQLite to store all the data.

```python
import sqlite3

conn = sqlite3.connect("tickets.db")
cursor = conn.cursor()

# Create a table for tickets
cursor.execute("""
    CREATE TABLE IF NOT EXISTS tickets (
        id INTEGER PRIMARY KEY,
        status TEXT NOT NULL,
        description TEXT NOT NULL,
        created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
    );
""")

# Insert some sample data
cursor.execute("INSERT INTO tickets (status, description) VALUES (?, ?)", ("open", "Ticket 1"))
conn.commit()

if __name__ == "__main__":
    conn.close()
```

This is a basic implementation of the database. There are many improvements that can be made to make it more robust and efficient.

I hope this helps you in creating your ticket management system! Let me know if you have any further questions or need additional assistance.

