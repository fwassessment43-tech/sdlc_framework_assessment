## Implementation approach

We will leverage Flask for the web application framework due to its simplicity and flexibility. For database operations, SQLAlchemy ORM will be used with SQLite as the backend for development purposes. Microservices for analytics will communicate via RESTful APIs.

## File list

- app.py
- models.py
- routes.py
- analytics_service.py

## Data structures and interfaces


classDiagram
    class App {
        +run()
    }
    class TicketModel {
        -id: int
        -title: str
        -description: str
        -status: str
        -created_at: datetime
        -updated_at: datetime
        -comments: list[Comment]
        +__init__(self, title: str, description: str)
    }
    class Comment {
        -id: int
        -ticket_id: int
        -content: str
        -created_at: datetime
        +__init__(self, content: str)
    }
    class AnalyticsService {
        +get_resolution_times() list[dict]
        +get_active_tickets_by_category() list[dict]
    }
    App --> TicketModel
    TicketModel --> Comment
    App --> AnalyticsService


## Program call flow


sequenceDiagram
    participant A as App
    participant TM as TicketModel
    participant C as Comment
    participant AS as AnalyticsService
    A->>TM: create_ticket(title, description)
    TM-->>A: return ticket_id
    A->>C: add_comment(ticket_id, content)
    C-->>A: return comment_id
    A->>AS: get_resolution_times()
    AS-->>A: return resolution_times_list
    A->>AS: get_active_tickets_by_category()
    AS-->>A: return active_tickets_dict


## Anything UNCLEAR

Clarification on the specific GUI framework to be used is needed for more detailed UI design.

