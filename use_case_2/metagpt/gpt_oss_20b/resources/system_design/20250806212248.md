## Implementation approach

We will build a lightweight desktop application using **Tkinter** for the GUI and **Flask** for the REST API that exposes CRUD operations on tickets and messages. The data will be persisted in a **SQLite** database accessed through a thin repository layer. Three separate micro‑services (each a small Flask app) will consume the same database via the API to provide the required analytics. All services will be containerised with Docker and orchestrated with Docker‑Compose. The architecture is intentionally simple to satisfy the requirement of no full authentication layer while still allowing role‑based visibility and status transitions.

Key design decisions:

1. **Role selection** – The login screen simply asks the user to choose *Helpdesk* or *User*; the choice is stored in the GUI session and sent with every API request in a custom header (`X-User-Role`).
2. **Database schema** – Two tables (`tickets` and `messages`) plus a `categories` lookup table. Statuses are stored as strings (`open`, `active`, `closed`).
3. **API layer** – A single Flask app (`api.py`) exposes endpoints for tickets, messages, and status changes. All micro‑services call this API directly.
4. **Micro‑services** – Three minimal Flask apps (`analytics_service1.py`, `analytics_service2.py`, `analytics_service3.py`) each expose a single endpoint that queries the database via the API and returns JSON.
5. **Containerisation** – Dockerfiles for the GUI, API, and each analytics service. A `docker-compose.yml` brings them up together.
6. **Error handling** – The API returns standard HTTP status codes; the GUI displays user‑friendly messages.

This approach keeps the codebase small, testable, and easily deployable while meeting all functional requirements.



## File list

- main.py
- api.py
- db.py
- analytics_service1.py
- analytics_service2.py
- analytics_service3.py
- docker-compose.yml
- requirements.txt

## Data structures and interfaces


classDiagram
    class Ticket {
        -id: int
        -title: str
        -description: str
        -category: str
        -status: str
        -created_at: datetime
        -updated_at: datetime
        -closed_at: datetime | None
        +__init__(self, title: str, description: str, category: str)
        +to_dict() -> dict
    }
    class Message {
        -id: int
        -ticket_id: int
        -author_role: str
        -content: str
        -timestamp: datetime
        +__init__(self, ticket_id: int, author_role: str, content: str)
        +to_dict() -> dict
    }
    class TicketRepository {
        +create(ticket: Ticket) -> int
        +get_by_id(ticket_id: int) -> Ticket | None
        +update(ticket: Ticket) -> None
        +list(filters: dict) -> List[Ticket]
    }
    class MessageRepository {
        +add(message: Message) -> int
        +list_by_ticket(ticket_id: int) -> List[Message]
    }
    class TicketService {
        -repo: TicketRepository
        -msg_repo: MessageRepository
        +create_ticket(title: str, description: str, category: str) -> int
        +get_ticket(ticket_id: int) -> Ticket
        +update_status(ticket_id: int, new_status: str) -> None
        +add_message(ticket_id: int, author_role: str, content: str) -> int
        +list_tickets(role: str, status_filter: List[str]) -> List[Ticket]
    }
    class TicketAPI {
        +app: Flask
        +ticket_service: TicketService
        +run()
    }
    class AnalyticsService1 {
        +count_open_tickets(start: datetime, end: datetime) -> int
    }
    class AnalyticsService2 {
        +average_resolution_time_by_month() -> Dict[str, float]
    }
    class AnalyticsService3 {
        +active_tickets_by_category() -> Dict[str, int]
    }
    class LoginWindow {
        +role: str
        +continue()
    }
    class TicketListWindow {
        +role: str
        +refresh()
    }
    class TicketDetailWindow {
        +ticket_id: int
        +load()
        +add_message()
        +change_status()
    }
    class AnalyticsDashboardWindow {
        +load_service1()
        +load_service2()
        +load_service3()
    }
    TicketService --> TicketRepository
    TicketService --> MessageRepository
    TicketAPI --> TicketService
    AnalyticsService1 --> TicketRepository
    AnalyticsService2 --> TicketRepository
    AnalyticsService3 --> TicketRepository
    LoginWindow --> TicketListWindow
    TicketListWindow --> TicketDetailWindow
    TicketDetailWindow --> TicketAPI
    AnalyticsDashboardWindow --> AnalyticsService1
    AnalyticsDashboardWindow --> AnalyticsService2
    AnalyticsDashboardWindow --> AnalyticsService3


## Program call flow


sequenceDiagram
    participant G as GUI (Tkinter)
    participant A as TicketAPI (Flask)
    participant S as TicketService
    participant R as TicketRepository
    participant M as MessageRepository
    participant D as Database

    G->>A: POST /tickets {title, description, category, role}
    A->>S: create_ticket(...)
    S->>R: create(ticket)
    R->>D: INSERT INTO tickets
    D-->>R: ticket_id
    R-->>S: ticket_id
    S-->>A: 201 {ticket_id}
    A-->>G: 201 {ticket_id}

    G->>A: GET /tickets?role=User&status=open,active
    A->>S: list_tickets(role, status_filter)
    S->>R: list(filters)
    R->>D: SELECT * FROM tickets WHERE ...
    D-->>R: rows
    R-->>S: tickets
    S-->>A: 200 {tickets}
    A-->>G: 200 {tickets}

    G->>A: POST /tickets/42/messages {role, content}
    A->>S: add_message(42, role, content)
    S->>M: add(message)
    M->>D: INSERT INTO messages
    D-->>M: message_id
    M-->>S: message_id
    S-->>A: 201 {message_id}
    A-->>G: 201 {message_id}

    G->>A: PATCH /tickets/42/status {role, new_status}
    A->>S: update_status(42, new_status)
    S->>R: update(ticket)
    R->>D: UPDATE tickets SET status=?, updated_at=? WHERE id=42
    D-->>R: rows_affected
    R-->>S: None
    S-->>A: 204
    A-->>G: 204

    G->>AnalyticsService1: GET /open_tickets?start=...&end=...
    AnalyticsService1->>R: count_open_tickets(start, end)
    R->>D: SELECT COUNT(*) FROM tickets WHERE status='open' AND created_at BETWEEN ...
    D-->>R: count
    R-->>AnalyticsService1: count
    AnalyticsService1-->>G: 200 {count}

    G->>AnalyticsService2: GET /avg_resolution
    AnalyticsService2->>R: average_resolution_time_by_month()
    R->>D: SELECT strftime('%Y-%m', created_at) as month, AVG(julianday(closed_at)-julianday(created_at)) as avg_days FROM tickets WHERE status='closed' GROUP BY month
    D-->>R: rows
    R-->>AnalyticsService2: dict
    AnalyticsService2-->>G: 200 {dict}

    G->>AnalyticsService3: GET /active_by_category
    AnalyticsService3->>R: active_tickets_by_category()
    R->>D: SELECT category, COUNT(*) FROM tickets WHERE status='active' GROUP BY category
    D-->>R: rows
    R-->>AnalyticsService3: dict
    AnalyticsService3-->>G: 200 {dict}


## Anything UNCLEAR

1. **Authentication** – The spec explicitly says no login system; however, role persistence across sessions is unclear. We assume the role is chosen once per GUI session.
2. **Deployment target** – Local machine vs cloud is not specified. Docker‑Compose will work locally; for cloud, services can be deployed to any container platform.
3. **Category list** – The categories are hard‑coded in the GUI; adding new categories would require a UI change or a separate admin interface.
4. **Error handling strategy** – The API should return clear error messages; the GUI should display them in a dialog.
5. **Performance** – SQLite is fine for small workloads; for larger campuses, a PostgreSQL backend would be preferable.

These points should be clarified before production deployment.

